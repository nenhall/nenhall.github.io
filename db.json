{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":1,"renderable":0},{"_id":"source/img/ironman-draw.jpeg","path":"img/ironman-draw.jpeg","modified":1,"renderable":0},{"_id":"source/img/ironman-draw2.jpeg","path":"img/ironman-draw2.jpeg","modified":1,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":1,"renderable":0},{"_id":"themes/beantech/source/css/archive.styl","path":"css/archive.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/beantech.css","path":"css/beantech.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/beantech.min.css","path":"css/beantech.min.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/rocket.styl","path":"css/rocket.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/signature.styl","path":"css/signature.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/toc.styl","path":"css/toc.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/widget.styl","path":"css/widget.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.js","path":"js/hux-blog.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"source/img/header_img/Iron-Man-3.jpg","path":"img/header_img/Iron-Man-3.jpg","modified":1,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":1,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/images/ironman.png","path":"css/images/ironman.png","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket.png","path":"css/images/rocket.png","modified":1,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":1,"renderable":0},{"_id":"themes/beantech/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/header_img/tf-logo-dark.png","path":"img/header_img/tf-logo-dark.png","modified":1,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":1,"renderable":0},{"_id":"source/img/header_img/header-img.JPG","path":"img/header_img/header-img.JPG","modified":1,"renderable":0},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":1,"renderable":0},{"_id":"source/img/header_img/archive-bg.png","path":"img/header_img/archive-bg.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home-bg-2-dark.png","path":"img/header_img/home-bg-2-dark.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"c6e20fc49a7fc6d0d206bd2c1f886426798106ce","modified":1550901543650},{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1550893074665},{"_id":"source/CNAME","hash":"55d5b0b4757a7d65ee4966dd161f394d06d257b7","modified":1550893074665},{"_id":"themes/beantech/.DS_Store","hash":"c60f06b468b23fd4578bc5bf6481e405a6580566","modified":1550900968606},{"_id":"themes/beantech/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1550893074713},{"_id":"themes/beantech/_config.yml","hash":"6afd65c055d9b1c70ae67323cc869f1b4aa60348","modified":1550893074713},{"_id":"source/_posts/.DS_Store","hash":"d2b123b93500c765d5cea62d6bdf92bdf4389475","modified":1550898439395},{"_id":"source/_posts/1677ziyouxing.md","hash":"e266d14694f5c5c344e41f34fdcd37020293375a","modified":1550900617219},{"_id":"source/_posts/KVC实现原理.md","hash":"6d33155fcb733d0c50562b034afd254791836827","modified":1550900333605},{"_id":"source/_posts/KVO实现原理.md","hash":"7a19ad7f8c81c1050f5999537aa74e636e8a0750","modified":1550900340124},{"_id":"source/_posts/Mac开机一直卡在进度条界面.md","hash":"65a98bd2ec1a1d3961274546ca2561458e4f33b5","modified":1550900798726},{"_id":"source/_posts/NSObject的本质.md","hash":"7d8ae48e5af49e5e7ad751fe0d43e705bcd05584","modified":1550900368829},{"_id":"source/_posts/Nodejs-入门篇.md","hash":"ce5c1f7d465dce07bb2cc6f2bd58c2450b581db6","modified":1550900358412},{"_id":"source/_posts/OC对象分类.md","hash":"8441c1be1d436c6f14547d6933c421cac2c154c2","modified":1550900381551},{"_id":"source/_posts/Runtime.md","hash":"3d46569e143618e0d44a403d348058437ff80710","modified":1550900391296},{"_id":"source/_posts/iOS-Block本质.md","hash":"87e3555be39cd906c32e83cb3259ce6936bbfdb6","modified":1550900316780},{"_id":"source/_posts/iOS-Category.md","hash":"74cca9dc9c6d6dd0d1e5f52ff4a93a1f9fa60c1e","modified":1550900326601},{"_id":"source/_posts/iOS-armv7-armv7s-arm64区别与应用32位、64位配置.md","hash":"3332ec8607e978c3ad14e1716a2458dbae90da96","modified":1550900434998},{"_id":"source/_posts/《这一年》滔滔逝水，急急流年.md","hash":"5dc05c814d7e8d298d5eb21cd6b6dcd10205b107","modified":1535535256000},{"_id":"source/_posts/幽暗的岁月-自由的囚徒.md","hash":"a318839e86d7fa1dc2763cab9775909757d8132d","modified":1535535284000},{"_id":"source/_posts/最后一支烟.md","hash":"375c5aadacd7e8ccb23d78c0ec12999ad8ae95c4","modified":1535535264000},{"_id":"source/_posts/王者人生-人生王者.md","hash":"b4769306e3599aca758b48dc6f5933b7e612023e","modified":1535535294000},{"_id":"source/_posts/第十九支烟.md","hash":"1970268cfad4e3409e4e2d5f84a3c277d5fcdffb","modified":1539006560000},{"_id":"source/about/index.md","hash":"ebca34cfe8d13ec641d17fcfec0127a966338f8e","modified":1550893074674},{"_id":"source/archive/index.md","hash":"279ff19668395f5c6b26417da99d2c1f3ecd5886","modified":1550893074674},{"_id":"source/img/.DS_Store","hash":"a061fa318eaf9389843f2d170034067428e6e67d","modified":1550898796314},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1550893074707},{"_id":"source/img/ironman-draw.jpeg","hash":"3bb07c6215d869a217dda939de38c4d53b726f2c","modified":1550897200821},{"_id":"source/img/ironman-draw2.jpeg","hash":"910e5de739d76f7ab75c28eee75ea4533f35ad74","modified":1550897389821},{"_id":"source/tags/index.md","hash":"9d558ce28d0d44c3463517088689bbca44bbb364","modified":1550893074713},{"_id":"themes/beantech/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1550893074714},{"_id":"themes/beantech/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1550893074714},{"_id":"themes/beantech/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1550893074714},{"_id":"themes/beantech/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1550893074714},{"_id":"themes/beantech/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1550893074714},{"_id":"themes/beantech/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1550893074715},{"_id":"themes/beantech/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1550893074715},{"_id":"themes/beantech/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1550893074715},{"_id":"themes/beantech/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1550893074715},{"_id":"themes/beantech/layout/.DS_Store","hash":"33e3f930bc78e03e924f8a0315b0b1137f3ae2f1","modified":1550898276726},{"_id":"themes/beantech/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1550893074715},{"_id":"themes/beantech/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1550893074718},{"_id":"themes/beantech/layout/archive.ejs","hash":"72a150c8dff0031a9107d12eaa7c2e6c6ce950d2","modified":1550893074718},{"_id":"themes/beantech/layout/index.ejs","hash":"dc8a6eaa00d1e7c33a40979afe0953ed5d7b512e","modified":1550893074719},{"_id":"themes/beantech/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1550893074719},{"_id":"themes/beantech/layout/layout.ejs","hash":"a5af5b99ac3456ab5da1a319455904b979b91601","modified":1550893074719},{"_id":"themes/beantech/layout/page.ejs","hash":"c90797e4394c5cb63c2515109480e766d04e486e","modified":1550893074719},{"_id":"themes/beantech/layout/post.ejs","hash":"2d55684fc539dc281f9e2ec0409f09ea6ca43949","modified":1550893074719},{"_id":"themes/beantech/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1550893074719},{"_id":"themes/beantech/source/.DS_Store","hash":"364139252d3c5645d4adb069e53db518398f2374","modified":1550898281739},{"_id":"source/_posts/最后一支烟/psb.jpeg","hash":"7a6f16d39a6d4235ce56e095a460e1969e9defc6","modified":1535534939000},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1550893074676},{"_id":"source/img/header_img/.DS_Store","hash":"374bafcbd997ec7e4384c9a9e4a16a53273e799a","modified":1550898142687},{"_id":"themes/beantech/layout/_partial/footer.ejs","hash":"c31863b1fa66fd915bc4913440be6c610d12af80","modified":1550893074716},{"_id":"themes/beantech/layout/_partial/head.ejs","hash":"3542d15bdf73aa59f05f566b7ecd2255e83ee370","modified":1550893074716},{"_id":"themes/beantech/layout/_partial/header.ejs","hash":"aafb744601042f0270d2e6595129ac8a73ad2608","modified":1550893074716},{"_id":"themes/beantech/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1550893074716},{"_id":"themes/beantech/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1550893074717},{"_id":"themes/beantech/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1550893074717},{"_id":"themes/beantech/layout/_partial/toc.ejs","hash":"837f01e8a20e5023b4b292d1b3141a399567da65","modified":1550893074717},{"_id":"themes/beantech/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1550893074717},{"_id":"themes/beantech/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1550893074717},{"_id":"themes/beantech/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1550893074717},{"_id":"themes/beantech/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1550893074718},{"_id":"themes/beantech/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1550893074718},{"_id":"themes/beantech/layout/_widget/short-about.ejs","hash":"3b10bd768f6ef30a42b1703fbc9a88627f9bfdf1","modified":1550893074718},{"_id":"themes/beantech/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1550893074720},{"_id":"themes/beantech/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1550893074720},{"_id":"themes/beantech/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1550893074720},{"_id":"themes/beantech/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1550893074722},{"_id":"themes/beantech/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1550893074722},{"_id":"themes/beantech/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1550893074723},{"_id":"themes/beantech/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1550893074723},{"_id":"themes/beantech/source/css/toc.styl","hash":"6c9a2d5f6f981624e0c4b64323493e8614efea29","modified":1550893074723},{"_id":"themes/beantech/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1550893074723},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1550893074724},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1550893074725},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1550893074726},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1550893074726},{"_id":"themes/beantech/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1550893074727},{"_id":"themes/beantech/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1550893074727},{"_id":"themes/beantech/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1550893074728},{"_id":"themes/beantech/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1550893074730},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1550893074731},{"_id":"themes/beantech/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1550893074731},{"_id":"themes/beantech/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1550893074731},{"_id":"source/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1550893074684},{"_id":"themes/beantech/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1550893074722},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1550893074725},{"_id":"themes/beantech/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1550893074727},{"_id":"themes/beantech/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1550893074730},{"_id":"source/_posts/Mac开机一直卡在进度条界面/note_head_img.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1535358548000},{"_id":"source/_posts/Nodejs-入门篇/note_head_img.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1535358548000},{"_id":"source/_posts/Runtime/note_head_img.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1535358548000},{"_id":"source/_posts/iOS-Block本质/note_head_img.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1535358548000},{"_id":"source/_posts/iOS-Category/note_head_img.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1535358548000},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1550893074712},{"_id":"themes/beantech/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1550893074721},{"_id":"themes/beantech/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1550893074722},{"_id":"themes/beantech/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1550893074723},{"_id":"source/_posts/1677ziyouxing/1677ziyouxing.png","hash":"9f9ea637eccb68b7646bbec60bc6887b063c9c34","modified":1537621856000},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1550893074682},{"_id":"themes/beantech/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1550893074729},{"_id":"source/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1550893074707},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1550893074711},{"_id":"source/img/header_img/header-img.JPG","hash":"c56c343f3035611310fb01cafe6ce2c18c5c1c5f","modified":1550896128238},{"_id":"source/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1550893074705},{"_id":"source/img/header_img/home-bg-o.png","hash":"630c0a6a47586292f947c649080f49426bf43f71","modified":1550897741979},{"_id":"source/img/header_img/archive-bg.png","hash":"630c0a6a47586292f947c649080f49426bf43f71","modified":1550897741979},{"_id":"source/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1550893074695},{"_id":"public/post-sitemap.xml","hash":"f3dfa6d8632fdb2877d39bd2b1c3f23d0e42469e","modified":1550902772668},{"_id":"public/page-sitemap.xml","hash":"8ce3dae3f4859836993fb7270fd3f838652051a3","modified":1550902772668},{"_id":"public/tag-sitemap.xml","hash":"37e0a85136774709aa68e0cd126194e3557a0586","modified":1550902772985},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1550902772985},{"_id":"public/sitemap.xml","hash":"b7468abfac789e5f811b8ea56d86ccc78352591c","modified":1550902773070},{"_id":"public/404.html","hash":"c4856cf85d12203b2497c6130611cd782cc34687","modified":1550902773084},{"_id":"public/tags/index.html","hash":"cda21dd24a9669570a2ea23277e9f2a733b8e82d","modified":1550902773084},{"_id":"public/2019/02/22/Nodejs-入门篇/index.html","hash":"9dfe4d89458cb16882b36c2f82242516097a15f8","modified":1550902773084},{"_id":"public/2019/02/22/iOS-Block本质/index.html","hash":"c7b1de00b48b4a0de0cee40f5787bc15803e96ab","modified":1550902773084},{"_id":"public/2019/02/22/Runtime/index.html","hash":"4d858e3ed80c5d35aaf97e24c2b88fb533a3fc42","modified":1550902773084},{"_id":"public/2019/02/22/iOS-Category/index.html","hash":"3d22a6181223a707274c0238728d22e876ef6cd7","modified":1550902773085},{"_id":"public/2018/09/22/1677ziyouxing/index.html","hash":"c34c32927d0031701356d42d924418793930dd57","modified":1550902773085},{"_id":"public/2018/08/29/最后一支烟/index.html","hash":"1e2b6907fcd5c2363ed3beb45dbf5214e9c7a938","modified":1550902773085},{"_id":"public/2018/08/29/第十九支烟/index.html","hash":"c68e6edfd91908d9e48e06c26dfd9566fd6c9bd1","modified":1550902773085},{"_id":"public/2018/08/29/《这一年》滔滔逝水，急急流年/index.html","hash":"e50ca205dae57a6005a249432b84f07f79c4b844","modified":1550902773085},{"_id":"public/2018/08/29/iOS-armv7-armv7s-arm64区别与应用32位、64位配置/index.html","hash":"d4961c1be9fd037c681e26d4493ebefbdbf774f9","modified":1550902773085},{"_id":"public/2018/08/29/幽暗的岁月-自由的囚徒/index.html","hash":"39872eb41a8daf8747707293597dd75695f22f30","modified":1550902773085},{"_id":"public/2018/08/29/王者人生-人生王者/index.html","hash":"cfffde4dafc5ddf4656081d799a9f9a4730c9677","modified":1550902773085},{"_id":"public/2018/08/29/Mac开机一直卡在进度条界面/index.html","hash":"3da635ae7b337121a992bf3d636032ff7a0f6bfa","modified":1550902773085},{"_id":"public/2018/08/17/KVO实现原理/index.html","hash":"773cb1a9dacd11f897811ecdadb79451fd9828a5","modified":1550902773085},{"_id":"public/2018/08/17/OC对象分类/index.html","hash":"856020a9a4200120e73ed6bd002a54db775dd739","modified":1550902773085},{"_id":"public/2018/08/17/NSObject的本质/index.html","hash":"8960472bc1d0bae5a132473feef942298ef7905b","modified":1550902773085},{"_id":"public/2018/08/17/KVC实现原理/index.html","hash":"dc8bee4144581945f3be3f9969829ced0411d778","modified":1550902773085},{"_id":"public/about/index.html","hash":"86d3e40816a84d474fc33be862db08788e4828c7","modified":1550902773086},{"_id":"public/archive/index.html","hash":"a7ca4c10a81d21f6dee55baced7c8b40c491ecb7","modified":1550902773086},{"_id":"public/index.html","hash":"b420db8afba9694c3425ed4db50a26b8b1c82933","modified":1550902773086},{"_id":"public/archives/2/index.html","hash":"81f50fd90a4897233c7f442a172125b0a554f448","modified":1550902773086},{"_id":"public/archives/index.html","hash":"198f24f7377f00b18d1a80b9683555fda2e12489","modified":1550902773086},{"_id":"public/archives/archives/2/index.html","hash":"c0b9f46588cbc3b982fafd5fbcb8fc14387c2f7f","modified":1550902773086},{"_id":"public/archives/2018/index.html","hash":"afa84ce1aea81f8d8c873c8fcf418122caebcb72","modified":1550902773086},{"_id":"public/archives/2018/archives/2/index.html","hash":"323bd8edb9b57ed70c5586f3b13ea83ce0e63462","modified":1550902773086},{"_id":"public/archives/2018/08/index.html","hash":"a6f338065e5436ee8ef8289626c45dbbd1131b2e","modified":1550902773086},{"_id":"public/archives/2018/08/archives/2/index.html","hash":"087b1c27b6a26561de56961742ad8c356141ff0a","modified":1550902773086},{"_id":"public/archives/2018/09/index.html","hash":"973ae8243db119e31739f0c851ffb0d6ca67c978","modified":1550902773086},{"_id":"public/archives/2019/index.html","hash":"95914ad8b0646b25fba8dd7e99a21da69f78af25","modified":1550902773086},{"_id":"public/archives/2019/02/index.html","hash":"ad83ebd0276f626deeaf82dd395b21207d3a79f9","modified":1550902773086},{"_id":"public/tags/NSObject/index.html","hash":"bdf1fed1d761772cdf711770be26be2c760edbd5","modified":1550902773086},{"_id":"public/tags/底层原理/index.html","hash":"4171b8d2615ca46b1375759b1bc13e074001b205","modified":1550902773087},{"_id":"public/tags/电脑常识/index.html","hash":"a4e544f200b7f7d116ba415a67589ef2684216ff","modified":1550902773087},{"_id":"public/tags/生活随笔/index.html","hash":"c103929b5fd4140fbb181177a48444dd737edc91","modified":1550902773087},{"_id":"public/tags/游记/index.html","hash":"cd4b96a44985927f77ae7d72fb972291ab88aae5","modified":1550902773087},{"_id":"public/CNAME","hash":"55d5b0b4757a7d65ee4966dd161f394d06d257b7","modified":1550902773102},{"_id":"public/img/ironman-draw.jpeg","hash":"3bb07c6215d869a217dda939de38c4d53b726f2c","modified":1550902773102},{"_id":"public/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1550902773102},{"_id":"public/img/ironman-draw2.jpeg","hash":"910e5de739d76f7ab75c28eee75ea4533f35ad74","modified":1550902773102},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1550902773102},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1550902773102},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1550902773103},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1550902773103},{"_id":"public/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1550902773103},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1550902773103},{"_id":"public/2018/08/29/最后一支烟/psb.jpeg","hash":"7a6f16d39a6d4235ce56e095a460e1969e9defc6","modified":1550902773103},{"_id":"public/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1550902773279},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1550902773279},{"_id":"public/css/archive.css","hash":"8db895ebaeff19ac145c961abcfd5d4a8d67a8ea","modified":1550902773286},{"_id":"public/css/highlight.css","hash":"03d1f0a648e9bdf7b1f57d217313cbac5d0c7eb1","modified":1550902773286},{"_id":"public/css/rocket.css","hash":"9456fd92f729e09d6de8cda70f95d78e0d789c70","modified":1550902773286},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1550902773286},{"_id":"public/css/toc.css","hash":"2062bf4e5b219654e0d4bf470f5eef1be213da95","modified":1550902773286},{"_id":"public/css/widget.css","hash":"da95ad3f1938f24d20f1fa77d7a38f0c392b5ec8","modified":1550902773286},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1550902773286},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1550902773286},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1550902773286},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1550902773286},{"_id":"public/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1550902773286},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1550902773286},{"_id":"public/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1550902773286},{"_id":"public/2018/08/29/Mac开机一直卡在进度条界面/note_head_img.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1550902773286},{"_id":"public/2019/02/22/iOS-Category/note_head_img.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1550902773286},{"_id":"public/2019/02/22/Runtime/note_head_img.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1550902773286},{"_id":"public/2019/02/22/Nodejs-入门篇/note_head_img.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1550902773286},{"_id":"public/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1550902773290},{"_id":"public/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1550902773291},{"_id":"public/2018/09/22/1677ziyouxing/1677ziyouxing.png","hash":"9f9ea637eccb68b7646bbec60bc6887b063c9c34","modified":1550902773291},{"_id":"public/2019/02/22/iOS-Block本质/note_head_img.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1550902773291},{"_id":"public/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1550902773298},{"_id":"public/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1550902773298},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1550902773298},{"_id":"public/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1550902773298},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1550902773306},{"_id":"public/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1550902773311},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1550902773318},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1550902773323},{"_id":"public/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1550902773329},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1550902773333},{"_id":"public/img/header_img/header-img.JPG","hash":"c56c343f3035611310fb01cafe6ce2c18c5c1c5f","modified":1550902773335},{"_id":"public/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1550902773339},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1550902773346},{"_id":"public/img/header_img/archive-bg.png","hash":"630c0a6a47586292f947c649080f49426bf43f71","modified":1550902773346},{"_id":"public/img/header_img/home-bg-o.png","hash":"630c0a6a47586292f947c649080f49426bf43f71","modified":1550902773348},{"_id":"public/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1550902773351}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2019-02-23T06:14:10.586Z","updated":"2019-02-23T03:37:54.665Z","path":"404.html","title":"","comments":1,"_id":"cjsh3gt3q0000ncezvnpl3q6e","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T20:48:33.000Z","description":"Wish for the Best, Prepare for the Worst","header-img":"img/header_img/Iron-Man-3.jpg","comments":1,"_content":"\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Wish for the Best, Prepare for the Worst\"\nheader-img: \"img/header_img/Iron-Man-3.jpg\"\ncomments: true\n---\n\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n","updated":"2019-02-23T03:37:54.674Z","path":"about/index.html","_id":"cjsh3gt4k0002nceztrgthvh4","content":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n"},{"layout":"archive","title":"Archives","header-img":"img/header_img/archive-bg.png","comments":0,"date":"2017-03-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"img/header_img/archive-bg.png\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2019-02-23T03:37:54.674Z","path":"archive/index.html","_id":"cjsh3gt4n0004ncezno5ocvgb","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/header_img/tag-bg.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/header_img/tag-bg.png\"\n---\n","date":"2019-02-23T06:14:10.575Z","updated":"2019-02-23T03:37:54.713Z","path":"tags/index.html","comments":1,"_id":"cjsh3gt4q0007ncezb2lpdek5","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"KVC实现原理","date":"2018-08-17T01:47:59.000Z","catalog":true,"subtitle":"KVC的底层实现原理解析","header-img":"note_head_img.jpg","catagories":["Objective-C"],"_content":"\n#### KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性\n\n#### 常见的API有\n- \\- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;\n- \\- (void)setValue:(id)value forKey:(NSString *)key;\n- \\- (id)valueForKeyPath:(NSString *)keyPath;\n- \\- (id)valueForKey:(NSString *)key; \n\n#### set时的查找顺序：\n\n先查找`setkey： _setkey`如果找到就调用，否则调用`+(BOOL)accessInstanceVariablesDirectly `，如果这个函数返回的是YES，就会按`_key 、_isKey 、key 、isKey`的顺序查找对应的成员变量，如果找到，就调用，否则抛异常，如下图。\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816210006.png)\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816210104.png)\n\n联想到的相关问答：\n\n1. 通过KVC修改属性会触发KVO吗？\n\n   会触发KVO，KVO内部是会调用willChangeValueForKey:、 didChangeVlaueForKey:方法的，口说无凭，我们去重写下对象的这两个方法，看它会不会来；\n\n   ![重写下对象的这两个方法](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816211239.png)\n\n   //断点后\n\n   ![断点后](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816211311.png)\n\n   \n\n### get时的查找顺序\n\n```objective-c\n@interface Person : NSObject\n{//申明对应的成员变量，便于验证\n    @public\n    int age;\n}\n@end\n\n@implementation Person\n//给对应的成员变量赋予不同的值，便于验证识别\n- (int)getAge {\n    return 11;\n}\n\n- (int)age {\n    return 12;\n}\n\n- (int)isAge {\n    return 13;\n}\n\n- (int)_age {\n    return 14;\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        person->_age = 10;\n        //依次注释Person类的另外三个方法，再运行项目，你会发现它会依次进行查找，知道四个方法都没有的时候然后抛异常\n        NSLog(@\"%@\", [person valueForKey:@\"age\"]);\n    }\n    return 0;\n}\n```\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816212048.png)\n\nPlease <a class=\"github-button\" href=\"https://github.com/nenhall/NHHUDExtend\" data-icon=\"octicon-star\" aria-label=\"Star nenhall/NHHUDExtend on GitHub\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/nenhall\" aria-label=\"Follow @nenhall on GitHub\">Follow</a> would also be appreciated!\nPeace!\n\n","source":"_posts/KVC实现原理.md","raw":"---\ntitle: KVC实现原理\ndate: 2018-08-17 09:47:59\ncatalog: true\nsubtitle: KVC的底层实现原理解析\nheader-img: note_head_img.jpg\ncatagories:\n  - Objective-C\ntags:\n  - NSObject\n  - 底层原理\n---\n\n#### KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性\n\n#### 常见的API有\n- \\- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;\n- \\- (void)setValue:(id)value forKey:(NSString *)key;\n- \\- (id)valueForKeyPath:(NSString *)keyPath;\n- \\- (id)valueForKey:(NSString *)key; \n\n#### set时的查找顺序：\n\n先查找`setkey： _setkey`如果找到就调用，否则调用`+(BOOL)accessInstanceVariablesDirectly `，如果这个函数返回的是YES，就会按`_key 、_isKey 、key 、isKey`的顺序查找对应的成员变量，如果找到，就调用，否则抛异常，如下图。\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816210006.png)\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816210104.png)\n\n联想到的相关问答：\n\n1. 通过KVC修改属性会触发KVO吗？\n\n   会触发KVO，KVO内部是会调用willChangeValueForKey:、 didChangeVlaueForKey:方法的，口说无凭，我们去重写下对象的这两个方法，看它会不会来；\n\n   ![重写下对象的这两个方法](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816211239.png)\n\n   //断点后\n\n   ![断点后](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816211311.png)\n\n   \n\n### get时的查找顺序\n\n```objective-c\n@interface Person : NSObject\n{//申明对应的成员变量，便于验证\n    @public\n    int age;\n}\n@end\n\n@implementation Person\n//给对应的成员变量赋予不同的值，便于验证识别\n- (int)getAge {\n    return 11;\n}\n\n- (int)age {\n    return 12;\n}\n\n- (int)isAge {\n    return 13;\n}\n\n- (int)_age {\n    return 14;\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        person->_age = 10;\n        //依次注释Person类的另外三个方法，再运行项目，你会发现它会依次进行查找，知道四个方法都没有的时候然后抛异常\n        NSLog(@\"%@\", [person valueForKey:@\"age\"]);\n    }\n    return 0;\n}\n```\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816212048.png)\n\nPlease <a class=\"github-button\" href=\"https://github.com/nenhall/NHHUDExtend\" data-icon=\"octicon-star\" aria-label=\"Star nenhall/NHHUDExtend on GitHub\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/nenhall\" aria-label=\"Follow @nenhall on GitHub\">Follow</a> would also be appreciated!\nPeace!\n\n","slug":"KVC实现原理","published":1,"updated":"2019-02-23T05:38:53.605Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsh3gt4g0001ncez7g9ctwws","content":"<h4><span id=\"kvc的全称是key-value-coding俗称键值编码可以通过一个key来访问某个属性\">KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性</span></h4>\n<h4><span id=\"常见的api有\">常见的API有</span></h4>\n<ul>\n<li>- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;</li>\n<li>- (void)setValue:(id)value forKey:(NSString *)key;</li>\n<li>- (id)valueForKeyPath:(NSString *)keyPath;</li>\n<li>- (id)valueForKey:(NSString *)key;</li>\n</ul>\n<h4><span id=\"set时的查找顺序\">set时的查找顺序：</span></h4>\n<p>先查找<code>setkey： _setkey</code>如果找到就调用，否则调用<code>+(BOOL)accessInstanceVariablesDirectly</code>，如果这个函数返回的是YES，就会按<code>_key 、_isKey 、key 、isKey</code>的顺序查找对应的成员变量，如果找到，就调用，否则抛异常，如下图。</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816210006.png\" alt><br>\n<img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816210104.png\" alt></p>\n<p>联想到的相关问答：</p>\n<ol>\n<li>\n<p>通过KVC修改属性会触发KVO吗？</p>\n<p>会触发KVO，KVO内部是会调用willChangeValueForKey:、 didChangeVlaueForKey:方法的，口说无凭，我们去重写下对象的这两个方法，看它会不会来；</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816211239.png\" alt=\"重写下对象的这两个方法\"></p>\n<p>//断点后</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816211311.png\" alt=\"断点后\"></p>\n</li>\n</ol>\n<h3><span id=\"get时的查找顺序\">get时的查找顺序</span></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Person : NSObject</span><br><span class=\"line\">&#123;//申明对应的成员变量，便于验证</span><br><span class=\"line\">    @public</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\">//给对应的成员变量赋予不同的值，便于验证识别</span><br><span class=\"line\">- (int)getAge &#123;</span><br><span class=\"line\">    return 11;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)age &#123;</span><br><span class=\"line\">    return 12;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)isAge &#123;</span><br><span class=\"line\">    return 13;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)_age &#123;</span><br><span class=\"line\">    return 14;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        Person *person = [[Person alloc] init];</span><br><span class=\"line\">        person-&gt;_age = 10;</span><br><span class=\"line\">        //依次注释Person类的另外三个方法，再运行项目，你会发现它会依次进行查找，知道四个方法都没有的时候然后抛异常</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;, [person valueForKey:@&quot;age&quot;]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816212048.png\" alt></p>\n<p>Please <a class=\"github-button\" href=\"https://github.com/nenhall/NHHUDExtend\" data-icon=\"octicon-star\" aria-label=\"Star nenhall/NHHUDExtend on GitHub\" target=\"_blank\" rel=\"noopener\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/nenhall\" aria-label=\"Follow @nenhall on GitHub\" target=\"_blank\" rel=\"noopener\">Follow</a> would also be appreciated!<br>\nPeace!</p>\n","site":{"data":{}},"excerpt":"","more":"<h4>KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性</h4>\n<h4>常见的API有</h4>\n<ul>\n<li>- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;</li>\n<li>- (void)setValue:(id)value forKey:(NSString *)key;</li>\n<li>- (id)valueForKeyPath:(NSString *)keyPath;</li>\n<li>- (id)valueForKey:(NSString *)key;</li>\n</ul>\n<h4>set时的查找顺序：</h4>\n<p>先查找<code>setkey： _setkey</code>如果找到就调用，否则调用<code>+(BOOL)accessInstanceVariablesDirectly</code>，如果这个函数返回的是YES，就会按<code>_key 、_isKey 、key 、isKey</code>的顺序查找对应的成员变量，如果找到，就调用，否则抛异常，如下图。</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816210006.png\" alt><br>\n<img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816210104.png\" alt></p>\n<p>联想到的相关问答：</p>\n<ol>\n<li>\n<p>通过KVC修改属性会触发KVO吗？</p>\n<p>会触发KVO，KVO内部是会调用willChangeValueForKey:、 didChangeVlaueForKey:方法的，口说无凭，我们去重写下对象的这两个方法，看它会不会来；</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816211239.png\" alt=\"重写下对象的这两个方法\"></p>\n<p>//断点后</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816211311.png\" alt=\"断点后\"></p>\n</li>\n</ol>\n<h3>get时的查找顺序</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Person : NSObject</span><br><span class=\"line\">&#123;//申明对应的成员变量，便于验证</span><br><span class=\"line\">    @public</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\">//给对应的成员变量赋予不同的值，便于验证识别</span><br><span class=\"line\">- (int)getAge &#123;</span><br><span class=\"line\">    return 11;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)age &#123;</span><br><span class=\"line\">    return 12;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)isAge &#123;</span><br><span class=\"line\">    return 13;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)_age &#123;</span><br><span class=\"line\">    return 14;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        Person *person = [[Person alloc] init];</span><br><span class=\"line\">        person-&gt;_age = 10;</span><br><span class=\"line\">        //依次注释Person类的另外三个方法，再运行项目，你会发现它会依次进行查找，知道四个方法都没有的时候然后抛异常</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;, [person valueForKey:@&quot;age&quot;]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816212048.png\" alt></p>\n<p>Please <a class=\"github-button\" href=\"https://github.com/nenhall/NHHUDExtend\" data-icon=\"octicon-star\" aria-label=\"Star nenhall/NHHUDExtend on GitHub\" target=\"_blank\" rel=\"noopener\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/nenhall\" aria-label=\"Follow @nenhall on GitHub\" target=\"_blank\" rel=\"noopener\">Follow</a> would also be appreciated!<br>\nPeace!</p>\n"},{"title":"Mac开机一直卡在进度条界面","catalog":true,"date":"2018-08-29T09:14:40.000Z","subtitle":null,"header-img":"note_head_img.jpg","catagories":["MacOS"],"_content":"### 现象：\n>早上一开机，就一直卡在进度条界面，进度条满了后就一直停在当前界面了！网上各种搜各种都没解决，折腾了一上午；我遇到两次都这样解决的，第一次的时候折腾了一上午，第二次直接按这流程5分钟解决了，不需要重装系统，在此记录下来也是希望能帮助到更多的同仁。\n\n\n### 原因\n> 造成问题的可能原因：没有正确关机，或者说没有正常关机(不知你是否遇到过执行关机后，电脑一直处于在关机状态，10几分钟还是未能关上)，一般发生在重装系统后几天\n\n### 解决方案\n> 最后在某外国网站上有人说是mac硬盘记忆存储的问题，需要清除记忆存储的数据库，这么一说，突然感觉好像是这样一回事，于是果断的尝试下，我也是第一次试这方法，所以在试这种方法之前还是先把电脑内的重要资料做备份：\n\n***下面的第三、四步你可以选择接性跳过，我第一次用这种方法的时候不确定可不可行，所以增加了这两步来保险起见，第二次遇到这问题的时候我是直接跳过的***\n1. 开机后立即按住`command + R`键进入恢复模式；\n2. 然后选择`磁盘工具`；\n3. 准备一个硬盘或者U盘，通过硬盘工具将你的硬盘或者U盘格式化成mac-日志格式，如果你的U盘本身能直接读书，可以不用格式化；\n4. 通过`磁盘工具`将你电脑的资料备份到你的移动盘：\n    * 首先新建文件夹映像，如下图1\n    * 选择你想备份的文件或者文件夹\n    * 更改保存的位置：即你的移动磁盘，如下图2\n    * 然后点击存储：等待它完成，这个还是有点慢的，跟你的电脑和磁盘、文件大小有关\n    *  备份完成后，你可以把移动盘插到别的电脑上去看下，是否完全成功(非必要操作，毕竟数据无价，确认下比较安全)，确认无误后继续往下操作；\n\n  ![备份资料新建映像](https://upload-images.jianshu.io/upload_images/2443108-4b5ac036e1d6eb8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500)\n  ![备份资料选择保存位置](https://upload-images.jianshu.io/upload_images/2443108-5c517d9046bbf546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500)\n\n5. 关机 > 再开机 > 立即按`command + V`键，进入代码界面：\n    * 等不停的输出`Too many corpses being created`这段代码的时候,说明是缓存太多造成的，如下图：\n    ![0A50DF09064F100993F87B4FD480D1D5.jpg](https://upload-images.jianshu.io/upload_images/2443108-09c6f8d3b70b2412.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300)\n    * 不必要一直看这个输出，知道是这个原因就可以了。\n6.  关机 > 再开机 > 立即按`command + R`键，进入macOS恢复界面，左上角找到终端工具，在终端命令行中按如下顺序执行命令(目的：清除数据库缓存)：\n     * 进入缓存目录\n     ```\n     cd /Volumes/Macintosh\\ HD/var/db/caches/opendiretory/\n     ```\n\n     * 删除缓存数据库\n     ```\n     mv ./mbr_cache ./mbr_cache-old\n     ```\n     > 如果进入缓存目录的时候，提示`opendiretory `目录找不到，是因为**<El Capitan后加入了Rootless(SIP)机制>**需要先关闭SIP：\n     > 1. 关闭SIP，具体关闭步骤参考我另一遍文章有写：[Mac ZSH 好用的插件](https://www.jianshu.com/p/b49544030019)；\n     > 2. 关闭后再回到第6步开始往下继续执行相关操作；\n\n\n7. 完成上面操作后：关机 > 再开机 > 进入正常开机流程\n这次开机会比正常情况下要久，因为缓存清了，大概3-5分钟；\n\n8. 成功进入用户登录界面，恭喜你！！\n\n**如果你因某种原因无法成功执行第六步，又急着用电脑，建议按上面的步骤备份重要资料，然后进入在线重装系统步骤……也可邮箱联系我nenhall@126.com**\n\n##### 如果备份完后，你还是想要重装系统也可以，那执行完第4步后，不要执行第5步以后的命令了，执行如下操作重装系统：\n1. 把你电脑的磁盘(Macintosh HD)格式抹除了\n![磁盘抹除](https://upload-images.jianshu.io/upload_images/2443108-1c308f7a88c56c9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500)\n2. 退出磁盘；\n3. 连接上网络，然后选择在线安装mac0x\n9. 进入在线安装过程，至此问题解决；\n\n<br>\n\n### 附 几条mac其它命令的释义：\n**都是开机后需要立即执行的组合操作的**\n\n##### option + command + R + P\n> 屏幕会三闪,是NVRem, 作用是重置系统,缓存重置,解决系统卡顿的问题.\n\n##### command + R\n> 这个是macOS实用工具,包括时间机器,修复磁盘(Macintosh HD急救),安装系统, 操作终端等功能.\n\n##### shift\n> 这个是安全模式(目前我还没有进去看过)\n\n##### D\n> 这个功能是硬件自检,启动会自动检测硬件是否有问题.\n\n##### command + shift + option + R 或者 command + option + R\n> 这个作用是强制装系统,彻底的重装系统,属于抹除安装(意思是你的Macintosh HD盘上的所有资料都会被清除)\n\n*第二次更新此文章增加了图片及SIP权限开启的方法；因为我的电脑之前开启过，所以没遇到这问题*","source":"_posts/Mac开机一直卡在进度条界面.md","raw":"---\ntitle: Mac开机一直卡在进度条界面\ncatalog: true\ndate: 2018-08-29 17:14:40\nsubtitle:\nheader-img: note_head_img.jpg\ncatagories:\n  - MacOS\ntags:\n  - 电脑常识\n---\n### 现象：\n>早上一开机，就一直卡在进度条界面，进度条满了后就一直停在当前界面了！网上各种搜各种都没解决，折腾了一上午；我遇到两次都这样解决的，第一次的时候折腾了一上午，第二次直接按这流程5分钟解决了，不需要重装系统，在此记录下来也是希望能帮助到更多的同仁。\n\n\n### 原因\n> 造成问题的可能原因：没有正确关机，或者说没有正常关机(不知你是否遇到过执行关机后，电脑一直处于在关机状态，10几分钟还是未能关上)，一般发生在重装系统后几天\n\n### 解决方案\n> 最后在某外国网站上有人说是mac硬盘记忆存储的问题，需要清除记忆存储的数据库，这么一说，突然感觉好像是这样一回事，于是果断的尝试下，我也是第一次试这方法，所以在试这种方法之前还是先把电脑内的重要资料做备份：\n\n***下面的第三、四步你可以选择接性跳过，我第一次用这种方法的时候不确定可不可行，所以增加了这两步来保险起见，第二次遇到这问题的时候我是直接跳过的***\n1. 开机后立即按住`command + R`键进入恢复模式；\n2. 然后选择`磁盘工具`；\n3. 准备一个硬盘或者U盘，通过硬盘工具将你的硬盘或者U盘格式化成mac-日志格式，如果你的U盘本身能直接读书，可以不用格式化；\n4. 通过`磁盘工具`将你电脑的资料备份到你的移动盘：\n    * 首先新建文件夹映像，如下图1\n    * 选择你想备份的文件或者文件夹\n    * 更改保存的位置：即你的移动磁盘，如下图2\n    * 然后点击存储：等待它完成，这个还是有点慢的，跟你的电脑和磁盘、文件大小有关\n    *  备份完成后，你可以把移动盘插到别的电脑上去看下，是否完全成功(非必要操作，毕竟数据无价，确认下比较安全)，确认无误后继续往下操作；\n\n  ![备份资料新建映像](https://upload-images.jianshu.io/upload_images/2443108-4b5ac036e1d6eb8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500)\n  ![备份资料选择保存位置](https://upload-images.jianshu.io/upload_images/2443108-5c517d9046bbf546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500)\n\n5. 关机 > 再开机 > 立即按`command + V`键，进入代码界面：\n    * 等不停的输出`Too many corpses being created`这段代码的时候,说明是缓存太多造成的，如下图：\n    ![0A50DF09064F100993F87B4FD480D1D5.jpg](https://upload-images.jianshu.io/upload_images/2443108-09c6f8d3b70b2412.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300)\n    * 不必要一直看这个输出，知道是这个原因就可以了。\n6.  关机 > 再开机 > 立即按`command + R`键，进入macOS恢复界面，左上角找到终端工具，在终端命令行中按如下顺序执行命令(目的：清除数据库缓存)：\n     * 进入缓存目录\n     ```\n     cd /Volumes/Macintosh\\ HD/var/db/caches/opendiretory/\n     ```\n\n     * 删除缓存数据库\n     ```\n     mv ./mbr_cache ./mbr_cache-old\n     ```\n     > 如果进入缓存目录的时候，提示`opendiretory `目录找不到，是因为**<El Capitan后加入了Rootless(SIP)机制>**需要先关闭SIP：\n     > 1. 关闭SIP，具体关闭步骤参考我另一遍文章有写：[Mac ZSH 好用的插件](https://www.jianshu.com/p/b49544030019)；\n     > 2. 关闭后再回到第6步开始往下继续执行相关操作；\n\n\n7. 完成上面操作后：关机 > 再开机 > 进入正常开机流程\n这次开机会比正常情况下要久，因为缓存清了，大概3-5分钟；\n\n8. 成功进入用户登录界面，恭喜你！！\n\n**如果你因某种原因无法成功执行第六步，又急着用电脑，建议按上面的步骤备份重要资料，然后进入在线重装系统步骤……也可邮箱联系我nenhall@126.com**\n\n##### 如果备份完后，你还是想要重装系统也可以，那执行完第4步后，不要执行第5步以后的命令了，执行如下操作重装系统：\n1. 把你电脑的磁盘(Macintosh HD)格式抹除了\n![磁盘抹除](https://upload-images.jianshu.io/upload_images/2443108-1c308f7a88c56c9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500)\n2. 退出磁盘；\n3. 连接上网络，然后选择在线安装mac0x\n9. 进入在线安装过程，至此问题解决；\n\n<br>\n\n### 附 几条mac其它命令的释义：\n**都是开机后需要立即执行的组合操作的**\n\n##### option + command + R + P\n> 屏幕会三闪,是NVRem, 作用是重置系统,缓存重置,解决系统卡顿的问题.\n\n##### command + R\n> 这个是macOS实用工具,包括时间机器,修复磁盘(Macintosh HD急救),安装系统, 操作终端等功能.\n\n##### shift\n> 这个是安全模式(目前我还没有进去看过)\n\n##### D\n> 这个功能是硬件自检,启动会自动检测硬件是否有问题.\n\n##### command + shift + option + R 或者 command + option + R\n> 这个作用是强制装系统,彻底的重装系统,属于抹除安装(意思是你的Macintosh HD盘上的所有资料都会被清除)\n\n*第二次更新此文章增加了图片及SIP权限开启的方法；因为我的电脑之前开启过，所以没遇到这问题*","slug":"Mac开机一直卡在进度条界面","published":1,"updated":"2019-02-23T05:46:38.726Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsh3gt4l0003ncezglifk3ue","content":"<h3><span id=\"现象\">现象：</span></h3>\n<blockquote>\n<p>早上一开机，就一直卡在进度条界面，进度条满了后就一直停在当前界面了！网上各种搜各种都没解决，折腾了一上午；我遇到两次都这样解决的，第一次的时候折腾了一上午，第二次直接按这流程5分钟解决了，不需要重装系统，在此记录下来也是希望能帮助到更多的同仁。</p>\n</blockquote>\n<h3><span id=\"原因\">原因</span></h3>\n<blockquote>\n<p>造成问题的可能原因：没有正确关机，或者说没有正常关机(不知你是否遇到过执行关机后，电脑一直处于在关机状态，10几分钟还是未能关上)，一般发生在重装系统后几天</p>\n</blockquote>\n<h3><span id=\"解决方案\">解决方案</span></h3>\n<blockquote>\n<p>最后在某外国网站上有人说是mac硬盘记忆存储的问题，需要清除记忆存储的数据库，这么一说，突然感觉好像是这样一回事，于是果断的尝试下，我也是第一次试这方法，所以在试这种方法之前还是先把电脑内的重要资料做备份：</p>\n</blockquote>\n<p><strong><em>下面的第三、四步你可以选择接性跳过，我第一次用这种方法的时候不确定可不可行，所以增加了这两步来保险起见，第二次遇到这问题的时候我是直接跳过的</em></strong></p>\n<ol>\n<li>开机后立即按住<code>command + R</code>键进入恢复模式；</li>\n<li>然后选择<code>磁盘工具</code>；</li>\n<li>准备一个硬盘或者U盘，通过硬盘工具将你的硬盘或者U盘格式化成mac-日志格式，如果你的U盘本身能直接读书，可以不用格式化；</li>\n<li>通过<code>磁盘工具</code>将你电脑的资料备份到你的移动盘：\n<ul>\n<li>首先新建文件夹映像，如下图1</li>\n<li>选择你想备份的文件或者文件夹</li>\n<li>更改保存的位置：即你的移动磁盘，如下图2</li>\n<li>然后点击存储：等待它完成，这个还是有点慢的，跟你的电脑和磁盘、文件大小有关</li>\n<li>备份完成后，你可以把移动盘插到别的电脑上去看下，是否完全成功(非必要操作，毕竟数据无价，确认下比较安全)，确认无误后继续往下操作；</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2443108-4b5ac036e1d6eb8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500\" alt=\"备份资料新建映像\"><br>\n<img src=\"https://upload-images.jianshu.io/upload_images/2443108-5c517d9046bbf546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500\" alt=\"备份资料选择保存位置\"></p>\n<ol start=\"5\">\n<li>\n<p>关机 &gt; 再开机 &gt; 立即按<code>command + V</code>键，进入代码界面：</p>\n<ul>\n<li>等不停的输出<code>Too many corpses being created</code>这段代码的时候,说明是缓存太多造成的，如下图：<br>\n<img src=\"https://upload-images.jianshu.io/upload_images/2443108-09c6f8d3b70b2412.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300\" alt=\"0A50DF09064F100993F87B4FD480D1D5.jpg\"></li>\n<li>不必要一直看这个输出，知道是这个原因就可以了。</li>\n</ul>\n</li>\n<li>\n<p>关机 &gt; 再开机 &gt; 立即按<code>command + R</code>键，进入macOS恢复界面，左上角找到终端工具，在终端命令行中按如下顺序执行命令(目的：清除数据库缓存)：</p>\n<ul>\n<li>进入缓存目录</li>\n</ul>\n <figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd <span class=\"regexp\">/Volumes/</span>Macintosh\\ HD<span class=\"regexp\">/var/</span>db<span class=\"regexp\">/caches/</span>opendiretory<span class=\"regexp\">/</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除缓存数据库</li>\n</ul>\n <figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv <span class=\"string\">./mbr_cache</span> <span class=\"string\">./mbr_cache-old</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果进入缓存目录的时候，提示<code>opendiretory</code>目录找不到，是因为**&lt;El Capitan后加入了Rootless(SIP)机制&gt;**需要先关闭SIP：</p>\n<ol>\n<li>关闭SIP，具体关闭步骤参考我另一遍文章有写：<a href=\"https://www.jianshu.com/p/b49544030019\">Mac ZSH 好用的插件</a>；</li>\n<li>关闭后再回到第6步开始往下继续执行相关操作；</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<ol start=\"7\">\n<li>\n<p>完成上面操作后：关机 &gt; 再开机 &gt; 进入正常开机流程<br>\n这次开机会比正常情况下要久，因为缓存清了，大概3-5分钟；</p>\n</li>\n<li>\n<p>成功进入用户登录界面，恭喜你！！</p>\n</li>\n</ol>\n<p><strong>如果你因某种原因无法成功执行第六步，又急着用电脑，建议按上面的步骤备份重要资料，然后进入在线重装系统步骤……也可邮箱联系我nenhall@126.com</strong></p>\n<h5><span id=\"如果备份完后你还是想要重装系统也可以那执行完第4步后不要执行第5步以后的命令了执行如下操作重装系统\">如果备份完后，你还是想要重装系统也可以，那执行完第4步后，不要执行第5步以后的命令了，执行如下操作重装系统：</span></h5>\n<ol>\n<li>把你电脑的磁盘(Macintosh HD)格式抹除了<br>\n<img src=\"https://upload-images.jianshu.io/upload_images/2443108-1c308f7a88c56c9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500\" alt=\"磁盘抹除\"></li>\n<li>退出磁盘；</li>\n<li>连接上网络，然后选择在线安装mac0x</li>\n<li>进入在线安装过程，至此问题解决；</li>\n</ol>\n<br>\n<h3><span id=\"附-几条mac其它命令的释义\">附 几条mac其它命令的释义：</span></h3>\n<p><strong>都是开机后需要立即执行的组合操作的</strong></p>\n<h5><span id=\"option-command-r-p\">option + command + R + P</span></h5>\n<blockquote>\n<p>屏幕会三闪,是NVRem, 作用是重置系统,缓存重置,解决系统卡顿的问题.</p>\n</blockquote>\n<h5><span id=\"command-r\">command + R</span></h5>\n<blockquote>\n<p>这个是macOS实用工具,包括时间机器,修复磁盘(Macintosh HD急救),安装系统, 操作终端等功能.</p>\n</blockquote>\n<h5><span id=\"shift\">shift</span></h5>\n<blockquote>\n<p>这个是安全模式(目前我还没有进去看过)</p>\n</blockquote>\n<h5><span id=\"d\">D</span></h5>\n<blockquote>\n<p>这个功能是硬件自检,启动会自动检测硬件是否有问题.</p>\n</blockquote>\n<h5><span id=\"command-shift-option-r-或者-command-option-r\">command + shift + option + R 或者 command + option + R</span></h5>\n<blockquote>\n<p>这个作用是强制装系统,彻底的重装系统,属于抹除安装(意思是你的Macintosh HD盘上的所有资料都会被清除)</p>\n</blockquote>\n<p><em>第二次更新此文章增加了图片及SIP权限开启的方法；因为我的电脑之前开启过，所以没遇到这问题</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h3>现象：</h3>\n<blockquote>\n<p>早上一开机，就一直卡在进度条界面，进度条满了后就一直停在当前界面了！网上各种搜各种都没解决，折腾了一上午；我遇到两次都这样解决的，第一次的时候折腾了一上午，第二次直接按这流程5分钟解决了，不需要重装系统，在此记录下来也是希望能帮助到更多的同仁。</p>\n</blockquote>\n<h3>原因</h3>\n<blockquote>\n<p>造成问题的可能原因：没有正确关机，或者说没有正常关机(不知你是否遇到过执行关机后，电脑一直处于在关机状态，10几分钟还是未能关上)，一般发生在重装系统后几天</p>\n</blockquote>\n<h3>解决方案</h3>\n<blockquote>\n<p>最后在某外国网站上有人说是mac硬盘记忆存储的问题，需要清除记忆存储的数据库，这么一说，突然感觉好像是这样一回事，于是果断的尝试下，我也是第一次试这方法，所以在试这种方法之前还是先把电脑内的重要资料做备份：</p>\n</blockquote>\n<p><strong><em>下面的第三、四步你可以选择接性跳过，我第一次用这种方法的时候不确定可不可行，所以增加了这两步来保险起见，第二次遇到这问题的时候我是直接跳过的</em></strong></p>\n<ol>\n<li>开机后立即按住<code>command + R</code>键进入恢复模式；</li>\n<li>然后选择<code>磁盘工具</code>；</li>\n<li>准备一个硬盘或者U盘，通过硬盘工具将你的硬盘或者U盘格式化成mac-日志格式，如果你的U盘本身能直接读书，可以不用格式化；</li>\n<li>通过<code>磁盘工具</code>将你电脑的资料备份到你的移动盘：\n<ul>\n<li>首先新建文件夹映像，如下图1</li>\n<li>选择你想备份的文件或者文件夹</li>\n<li>更改保存的位置：即你的移动磁盘，如下图2</li>\n<li>然后点击存储：等待它完成，这个还是有点慢的，跟你的电脑和磁盘、文件大小有关</li>\n<li>备份完成后，你可以把移动盘插到别的电脑上去看下，是否完全成功(非必要操作，毕竟数据无价，确认下比较安全)，确认无误后继续往下操作；</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2443108-4b5ac036e1d6eb8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500\" alt=\"备份资料新建映像\"><br>\n<img src=\"https://upload-images.jianshu.io/upload_images/2443108-5c517d9046bbf546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500\" alt=\"备份资料选择保存位置\"></p>\n<ol start=\"5\">\n<li>\n<p>关机 &gt; 再开机 &gt; 立即按<code>command + V</code>键，进入代码界面：</p>\n<ul>\n<li>等不停的输出<code>Too many corpses being created</code>这段代码的时候,说明是缓存太多造成的，如下图：<br>\n<img src=\"https://upload-images.jianshu.io/upload_images/2443108-09c6f8d3b70b2412.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300\" alt=\"0A50DF09064F100993F87B4FD480D1D5.jpg\"></li>\n<li>不必要一直看这个输出，知道是这个原因就可以了。</li>\n</ul>\n</li>\n<li>\n<p>关机 &gt; 再开机 &gt; 立即按<code>command + R</code>键，进入macOS恢复界面，左上角找到终端工具，在终端命令行中按如下顺序执行命令(目的：清除数据库缓存)：</p>\n<ul>\n<li>进入缓存目录</li>\n</ul>\n <figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd <span class=\"regexp\">/Volumes/</span>Macintosh\\ HD<span class=\"regexp\">/var/</span>db<span class=\"regexp\">/caches/</span>opendiretory<span class=\"regexp\">/</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除缓存数据库</li>\n</ul>\n <figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv <span class=\"string\">./mbr_cache</span> <span class=\"string\">./mbr_cache-old</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果进入缓存目录的时候，提示<code>opendiretory</code>目录找不到，是因为**&lt;El Capitan后加入了Rootless(SIP)机制&gt;**需要先关闭SIP：</p>\n<ol>\n<li>关闭SIP，具体关闭步骤参考我另一遍文章有写：<a href=\"https://www.jianshu.com/p/b49544030019\">Mac ZSH 好用的插件</a>；</li>\n<li>关闭后再回到第6步开始往下继续执行相关操作；</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<ol start=\"7\">\n<li>\n<p>完成上面操作后：关机 &gt; 再开机 &gt; 进入正常开机流程<br>\n这次开机会比正常情况下要久，因为缓存清了，大概3-5分钟；</p>\n</li>\n<li>\n<p>成功进入用户登录界面，恭喜你！！</p>\n</li>\n</ol>\n<p><strong>如果你因某种原因无法成功执行第六步，又急着用电脑，建议按上面的步骤备份重要资料，然后进入在线重装系统步骤……也可邮箱联系我nenhall@126.com</strong></p>\n<h5>如果备份完后，你还是想要重装系统也可以，那执行完第4步后，不要执行第5步以后的命令了，执行如下操作重装系统：</h5>\n<ol>\n<li>把你电脑的磁盘(Macintosh HD)格式抹除了<br>\n<img src=\"https://upload-images.jianshu.io/upload_images/2443108-1c308f7a88c56c9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500\" alt=\"磁盘抹除\"></li>\n<li>退出磁盘；</li>\n<li>连接上网络，然后选择在线安装mac0x</li>\n<li>进入在线安装过程，至此问题解决；</li>\n</ol>\n<br>\n<h3>附 几条mac其它命令的释义：</h3>\n<p><strong>都是开机后需要立即执行的组合操作的</strong></p>\n<h5>option + command + R + P</h5>\n<blockquote>\n<p>屏幕会三闪,是NVRem, 作用是重置系统,缓存重置,解决系统卡顿的问题.</p>\n</blockquote>\n<h5>command + R</h5>\n<blockquote>\n<p>这个是macOS实用工具,包括时间机器,修复磁盘(Macintosh HD急救),安装系统, 操作终端等功能.</p>\n</blockquote>\n<h5>shift</h5>\n<blockquote>\n<p>这个是安全模式(目前我还没有进去看过)</p>\n</blockquote>\n<h5>D</h5>\n<blockquote>\n<p>这个功能是硬件自检,启动会自动检测硬件是否有问题.</p>\n</blockquote>\n<h5>command + shift + option + R 或者 command + option + R</h5>\n<blockquote>\n<p>这个作用是强制装系统,彻底的重装系统,属于抹除安装(意思是你的Macintosh HD盘上的所有资料都会被清除)</p>\n</blockquote>\n<p><em>第二次更新此文章增加了图片及SIP权限开启的方法；因为我的电脑之前开启过，所以没遇到这问题</em></p>\n"},{"title":"NSObject的本质","date":"2018-08-17T01:47:59.000Z","catagories":["Objective-C"],"_content":"### NSObject的编译过程：\n\n> 1. 我们平时编写的oc代码，底层实现其实都是C/C++代码：\n>    Objective-C > C/C++ > 汇编语言 > 机器语言代码\n> 2. Objective-C对象主要是基于C/C++的结构体来实现的.\n\n### OC代码转成C++代码：\n\n**我们需要借助转换后的代码来分析**\n\n>  终端命令：`xcrun -sdk iphoneos clang -arch arm64 -rewrite-obj xxx.m -o xxx.cpp`\n>  不指定平台与架构:`clang -rewrite-obj xxx.m -o xxx.cpp`\n>  iphoneos代表要编译的平台，-arch arm64代表平台架构 xxx代表文件名，-o为输出文件；如果报缺少某个库，加参数：-framework 库名\n\n### NSObject的Implementation：\n\n参考：[苹果源码](https://opensource.apple.com/tarballs) 、[刚才转换出来的xxx.cpp文件](xxx.cpp) 、[GNU源码](http://www.gnu.org/software/libc/)\n\n#### 借助转换后后C++代码来分析，以下转换后的关键代码：\n\n```objective-c\n//NSObject 定义:也就是说NSObject其实是一个isa指针，指向Class，\n//而Class又指向了一个`objc_class`，`objc_class`就是一个结构体，如下:\n@interface NSobject {\n    Class isa;\n}\n@end\n\n//NSObject Implementation\nstruct NSObject_IMPL {\n    Class isa; // isa是一个指针，在64位环境下占8个字节\n};\ntypedef struct objc_class *Class;//`objc_class`就是一个结构体\n\n/// Represents an instance of a class.\nstruct objc_object {\n    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;\n};\n\nNSObject *obj = [[NSObject alloc] init];\n        \n// 获得NSObject实例对象的成员变量所占用的大小 >> 8\nNSLog(@\"%zd\", class_getInstanceSize([NSObject class]));\n        \n// 获得obj指针所指向内存的大小 >> 16\nNSLog(@\"%zd\", malloc_size((__bridge const void *)obj));\n```\n\n### 相关问题一：NSObject占用多少个字节\n\n> 从上面的打印可知，Class isa本身占用8个字节，NSObject *obj占16个字节，为什么占16个呢？\n\n- 进一步分析证明：创建一个继承自`NSObject`带有成员变量的`Student`对象，如下：\n  - 猜想：按上面的结论一个`NSObject`实例对象占用16个字节，那下面可能这个`Student`实例对象应该占用4+4+16 = 24；\n  - 实际：是占用了16个字节， 因为8+4+4=16，没有超过16，也就相当于NSObject的16个字节，有8个其实像是预留的，具体看下面的代码结论。\n\n```objective-c\n//申明一个继承自NSObject对象的Student\n@interface Student : NSObject {\t\n    @public\n    int _sex;\n    int _age;\n}\n@end\n@implementation Student\n@end\n\n//转换成c++后的代码：\nstruct Student_IMPL {\n    struct NSObject_IMPL NSObject_IVARS;//8个字节\n    int _grade;//4个字节\n    int _age;  //4个字节\n};\n\nstruct NSObject_IMPL {\n    Class isa;//8个字节\n};\n\n//实例化一个Student对象，查看其占用的内存大小\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Student *stu = [[Student alloc] init];\n        stu->_grade = 3;\n        stu->_age = 5;\n        \n        NSLog(@\"%zd\", class_getInstanceSize([Student class]));\n        // >>这里打印出来的结果是 16\n        \n        NSLog(@\"%zd\", malloc_size((__bridge const void *)stu));\n        // >>这里打印出来的结果是 16\n        \n        //用这个方法可以证明stu其实就是`Student_IMPL`这个结构体\n        //下方面打印出来的结果跟上面赋值的结果一致\n        struct Student_IMPL *stuImpl = (__bridge struct Student_IMPL *)stu;\n        NSLog(@\"grade is %d, age is %d\", stuImpl->_grade, stuImpl->_age);\n    }\n    return 0;\n}\n```\n\n- 从NSObject源码分析：\n\n```c++\n// objc-runtime-new.h\n/* NSObject在调用alloc初始化的时候，底层是调用：\n * _objc_rootAllocWithZone() > class_createInstance() > calloc(size_t, size_t)\n * class_createInstance() 最终会调用如下方法来分配内存\n */\nsize_t instanceSize(size_t extraBytes) {\n        size_t size = alignedInstanceSize() + extraBytes;\n        // CF requires all objects be at least 16 bytes.\n     \t// 所有CF对象都必须最少16个字节\n        if (size < 16) size = 16;\n        return size;\n    }\n```\n\n> ##### 结论：\n>\n> 1. 系统分配了16个字节给NSObject对象(通过`malloc_size()`函数获得对应对象所指向内存中的大小)\n> 2. 在64bit环境下，NSObject对象内部只使用了8个字节的空间(通过`class_getInstanceSize()`函数获得实例对象的大小)，还有8个字节是预留的；\n> 3. 如果结构体大小小于16个字节时，底层会最小按16来分配，超过16个字节后， 结构体的大小必须是最大成员大小的倍数(如Student结构体中最大为8，如Student超过16后，则会按8的倍数去分配)；\n> 4. 但在最终分配大小的时候iOS系统做了内存分配的优化，及内存对齐机制，注意这里所说的内存对齐不是指结构体的那个内存对齐，最终分配给结构体的大小为16的倍数(可以从苹果的libmalloc源码中查看，如下图)；\n> 5. 整体逻辑跟iOS本身的内存对齐机制、及运行机制有关；\n>    ![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_libmalloc1.png)\n>    ![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_libmalloc2.png)\n>    ![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_libmalloc3.png)\n\n###### 其它查看内存大小的方式\n\n> 1. 通过xcode的工具来辅助性的查看：Xcode > Debug > Debug Workflew > View Memory > 然后在内存地址栏中输入你要查询的内存地址；\n> 2. 通过LLDB命令来打印内存地址：`(lldb) memory read 0x10331a920` 也可以简写成：`x 0x10331a920`;\n> 3. 指定的格式来打印内存地址：`(lldb) x/3xg 0x10331a920`，命令释义：以0x10331a920这个内存地址去读取3串内存地址，每串8个字节数以16进制的格式打印；\n>\n> ```\n> (lldb) memory read/数量+格式+字节数  内存地址\n> (lldb) x/数量+格式+字节数  内存地址\n> 数量：你想读取的个数\n> 格式：x是16进制，f是浮点，d是10进制\n> 字节数：\n> b：byte 1字节，h：half word 2字节\n> w：word 4字节，g：giant word 8字节\n> ```\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_lldb_cmd.png)\n\n###### 写内存\n\n> 写内存：`(lldb) memory write 0x10331a928 9`\n> 释义：改`0x10331a920`内存起的第28个字节为9，如下图\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_memory_write.png)\n\n注意点：\n\n> sizeof( )它是个运算符，不是函数，在编译的时候就确定，编译之后就是个常量，如：\n>\n> Student *stu = [[Student alloc] init];\n>\n> NSLog(@\"%zd\",sizeof( stu )); 打印出来并不是stu占用多少空间，而是*stu这个指针占用的内存空间，结果：8；\n>\n> `class_getInstanceSize()`函数返回的仅仅是对象需要占用的内存大小，并非最终系统分配的内存大小。\n\n\n\n### 相关问题二：对象的isa指针指向哪里？\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816214104.png)\n\n### 相关问题三：OC的类信息存放在哪里？\n\n实例对象里面只存放成员变量，方法不是放在实例对象里的，因为同一类可能实例化成多个对象，但会有相同的方法，这样就只需要创建一份方法，不必须每个实例对象各存一份，每个实例对象里面只存放自已特有的东西。","source":"_posts/NSObject的本质.md","raw":"---\ntitle: NSObject的本质\ndate: 2018-08-17 09:47:59\ncatagories:\n  - Objective-C\ntags:\n  - NSObject\n  - 底层原理\n---\n### NSObject的编译过程：\n\n> 1. 我们平时编写的oc代码，底层实现其实都是C/C++代码：\n>    Objective-C > C/C++ > 汇编语言 > 机器语言代码\n> 2. Objective-C对象主要是基于C/C++的结构体来实现的.\n\n### OC代码转成C++代码：\n\n**我们需要借助转换后的代码来分析**\n\n>  终端命令：`xcrun -sdk iphoneos clang -arch arm64 -rewrite-obj xxx.m -o xxx.cpp`\n>  不指定平台与架构:`clang -rewrite-obj xxx.m -o xxx.cpp`\n>  iphoneos代表要编译的平台，-arch arm64代表平台架构 xxx代表文件名，-o为输出文件；如果报缺少某个库，加参数：-framework 库名\n\n### NSObject的Implementation：\n\n参考：[苹果源码](https://opensource.apple.com/tarballs) 、[刚才转换出来的xxx.cpp文件](xxx.cpp) 、[GNU源码](http://www.gnu.org/software/libc/)\n\n#### 借助转换后后C++代码来分析，以下转换后的关键代码：\n\n```objective-c\n//NSObject 定义:也就是说NSObject其实是一个isa指针，指向Class，\n//而Class又指向了一个`objc_class`，`objc_class`就是一个结构体，如下:\n@interface NSobject {\n    Class isa;\n}\n@end\n\n//NSObject Implementation\nstruct NSObject_IMPL {\n    Class isa; // isa是一个指针，在64位环境下占8个字节\n};\ntypedef struct objc_class *Class;//`objc_class`就是一个结构体\n\n/// Represents an instance of a class.\nstruct objc_object {\n    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;\n};\n\nNSObject *obj = [[NSObject alloc] init];\n        \n// 获得NSObject实例对象的成员变量所占用的大小 >> 8\nNSLog(@\"%zd\", class_getInstanceSize([NSObject class]));\n        \n// 获得obj指针所指向内存的大小 >> 16\nNSLog(@\"%zd\", malloc_size((__bridge const void *)obj));\n```\n\n### 相关问题一：NSObject占用多少个字节\n\n> 从上面的打印可知，Class isa本身占用8个字节，NSObject *obj占16个字节，为什么占16个呢？\n\n- 进一步分析证明：创建一个继承自`NSObject`带有成员变量的`Student`对象，如下：\n  - 猜想：按上面的结论一个`NSObject`实例对象占用16个字节，那下面可能这个`Student`实例对象应该占用4+4+16 = 24；\n  - 实际：是占用了16个字节， 因为8+4+4=16，没有超过16，也就相当于NSObject的16个字节，有8个其实像是预留的，具体看下面的代码结论。\n\n```objective-c\n//申明一个继承自NSObject对象的Student\n@interface Student : NSObject {\t\n    @public\n    int _sex;\n    int _age;\n}\n@end\n@implementation Student\n@end\n\n//转换成c++后的代码：\nstruct Student_IMPL {\n    struct NSObject_IMPL NSObject_IVARS;//8个字节\n    int _grade;//4个字节\n    int _age;  //4个字节\n};\n\nstruct NSObject_IMPL {\n    Class isa;//8个字节\n};\n\n//实例化一个Student对象，查看其占用的内存大小\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Student *stu = [[Student alloc] init];\n        stu->_grade = 3;\n        stu->_age = 5;\n        \n        NSLog(@\"%zd\", class_getInstanceSize([Student class]));\n        // >>这里打印出来的结果是 16\n        \n        NSLog(@\"%zd\", malloc_size((__bridge const void *)stu));\n        // >>这里打印出来的结果是 16\n        \n        //用这个方法可以证明stu其实就是`Student_IMPL`这个结构体\n        //下方面打印出来的结果跟上面赋值的结果一致\n        struct Student_IMPL *stuImpl = (__bridge struct Student_IMPL *)stu;\n        NSLog(@\"grade is %d, age is %d\", stuImpl->_grade, stuImpl->_age);\n    }\n    return 0;\n}\n```\n\n- 从NSObject源码分析：\n\n```c++\n// objc-runtime-new.h\n/* NSObject在调用alloc初始化的时候，底层是调用：\n * _objc_rootAllocWithZone() > class_createInstance() > calloc(size_t, size_t)\n * class_createInstance() 最终会调用如下方法来分配内存\n */\nsize_t instanceSize(size_t extraBytes) {\n        size_t size = alignedInstanceSize() + extraBytes;\n        // CF requires all objects be at least 16 bytes.\n     \t// 所有CF对象都必须最少16个字节\n        if (size < 16) size = 16;\n        return size;\n    }\n```\n\n> ##### 结论：\n>\n> 1. 系统分配了16个字节给NSObject对象(通过`malloc_size()`函数获得对应对象所指向内存中的大小)\n> 2. 在64bit环境下，NSObject对象内部只使用了8个字节的空间(通过`class_getInstanceSize()`函数获得实例对象的大小)，还有8个字节是预留的；\n> 3. 如果结构体大小小于16个字节时，底层会最小按16来分配，超过16个字节后， 结构体的大小必须是最大成员大小的倍数(如Student结构体中最大为8，如Student超过16后，则会按8的倍数去分配)；\n> 4. 但在最终分配大小的时候iOS系统做了内存分配的优化，及内存对齐机制，注意这里所说的内存对齐不是指结构体的那个内存对齐，最终分配给结构体的大小为16的倍数(可以从苹果的libmalloc源码中查看，如下图)；\n> 5. 整体逻辑跟iOS本身的内存对齐机制、及运行机制有关；\n>    ![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_libmalloc1.png)\n>    ![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_libmalloc2.png)\n>    ![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_libmalloc3.png)\n\n###### 其它查看内存大小的方式\n\n> 1. 通过xcode的工具来辅助性的查看：Xcode > Debug > Debug Workflew > View Memory > 然后在内存地址栏中输入你要查询的内存地址；\n> 2. 通过LLDB命令来打印内存地址：`(lldb) memory read 0x10331a920` 也可以简写成：`x 0x10331a920`;\n> 3. 指定的格式来打印内存地址：`(lldb) x/3xg 0x10331a920`，命令释义：以0x10331a920这个内存地址去读取3串内存地址，每串8个字节数以16进制的格式打印；\n>\n> ```\n> (lldb) memory read/数量+格式+字节数  内存地址\n> (lldb) x/数量+格式+字节数  内存地址\n> 数量：你想读取的个数\n> 格式：x是16进制，f是浮点，d是10进制\n> 字节数：\n> b：byte 1字节，h：half word 2字节\n> w：word 4字节，g：giant word 8字节\n> ```\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_lldb_cmd.png)\n\n###### 写内存\n\n> 写内存：`(lldb) memory write 0x10331a928 9`\n> 释义：改`0x10331a920`内存起的第28个字节为9，如下图\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_memory_write.png)\n\n注意点：\n\n> sizeof( )它是个运算符，不是函数，在编译的时候就确定，编译之后就是个常量，如：\n>\n> Student *stu = [[Student alloc] init];\n>\n> NSLog(@\"%zd\",sizeof( stu )); 打印出来并不是stu占用多少空间，而是*stu这个指针占用的内存空间，结果：8；\n>\n> `class_getInstanceSize()`函数返回的仅仅是对象需要占用的内存大小，并非最终系统分配的内存大小。\n\n\n\n### 相关问题二：对象的isa指针指向哪里？\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816214104.png)\n\n### 相关问题三：OC的类信息存放在哪里？\n\n实例对象里面只存放成员变量，方法不是放在实例对象里的，因为同一类可能实例化成多个对象，但会有相同的方法，这样就只需要创建一份方法，不必须每个实例对象各存一份，每个实例对象里面只存放自已特有的东西。","slug":"NSObject的本质","published":1,"updated":"2019-02-23T05:39:28.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsh3gt4p0006ncez1bzbecfc","content":"<h3><span id=\"nsobject的编译过程\">NSObject的编译过程：</span></h3>\n<blockquote>\n<ol>\n<li>我们平时编写的oc代码，底层实现其实都是C/C++代码：<br>\nObjective-C &gt; C/C++ &gt; 汇编语言 &gt; 机器语言代码</li>\n<li>Objective-C对象主要是基于C/C++的结构体来实现的.</li>\n</ol>\n</blockquote>\n<h3><span id=\"oc代码转成c代码\">OC代码转成C++代码：</span></h3>\n<p><strong>我们需要借助转换后的代码来分析</strong></p>\n<blockquote>\n<p>终端命令：<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-obj xxx.m -o xxx.cpp</code><br>\n不指定平台与架构:<code>clang -rewrite-obj xxx.m -o xxx.cpp</code><br>\niphoneos代表要编译的平台，-arch arm64代表平台架构 xxx代表文件名，-o为输出文件；如果报缺少某个库，加参数：-framework 库名</p>\n</blockquote>\n<h3><span id=\"nsobject的implementation\">NSObject的Implementation：</span></h3>\n<p>参考：<a href=\"https://opensource.apple.com/tarballs\" target=\"_blank\" rel=\"noopener\">苹果源码</a> 、<a href=\"xxx.cpp\">刚才转换出来的xxx.cpp文件</a> 、<a href=\"http://www.gnu.org/software/libc/\" target=\"_blank\" rel=\"noopener\">GNU源码</a></p>\n<h4><span id=\"借助转换后后c代码来分析以下转换后的关键代码\">借助转换后后C++代码来分析，以下转换后的关键代码：</span></h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//NSObject 定义:也就是说NSObject其实是一个isa指针，指向Class，</span><br><span class=\"line\">//而Class又指向了一个`objc_class`，`objc_class`就是一个结构体，如下:</span><br><span class=\"line\">@interface NSobject &#123;</span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">//NSObject Implementation</span><br><span class=\"line\">struct NSObject_IMPL &#123;</span><br><span class=\"line\">    Class isa; // isa是一个指针，在64位环境下占8个字节</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">typedef struct objc_class *Class;//`objc_class`就是一个结构体</span><br><span class=\"line\"></span><br><span class=\"line\">/// Represents an instance of a class.</span><br><span class=\"line\">struct objc_object &#123;</span><br><span class=\"line\">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">NSObject *obj = [[NSObject alloc] init];</span><br><span class=\"line\">        </span><br><span class=\"line\">// 获得NSObject实例对象的成员变量所占用的大小 &gt;&gt; 8</span><br><span class=\"line\">NSLog(@&quot;%zd&quot;, class_getInstanceSize([NSObject class]));</span><br><span class=\"line\">        </span><br><span class=\"line\">// 获得obj指针所指向内存的大小 &gt;&gt; 16</span><br><span class=\"line\">NSLog(@&quot;%zd&quot;, malloc_size((__bridge const void *)obj));</span><br></pre></td></tr></table></figure>\n<h3><span id=\"相关问题一nsobject占用多少个字节\">相关问题一：NSObject占用多少个字节</span></h3>\n<blockquote>\n<p>从上面的打印可知，Class isa本身占用8个字节，NSObject *obj占16个字节，为什么占16个呢？</p>\n</blockquote>\n<ul>\n<li>进一步分析证明：创建一个继承自<code>NSObject</code>带有成员变量的<code>Student</code>对象，如下：\n<ul>\n<li>猜想：按上面的结论一个<code>NSObject</code>实例对象占用16个字节，那下面可能这个<code>Student</code>实例对象应该占用4+4+16 = 24；</li>\n<li>实际：是占用了16个字节， 因为8+4+4=16，没有超过16，也就相当于NSObject的16个字节，有8个其实像是预留的，具体看下面的代码结论。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//申明一个继承自NSObject对象的Student</span><br><span class=\"line\">@interface Student : NSObject &#123;\t</span><br><span class=\"line\">    @public</span><br><span class=\"line\">    int _sex;</span><br><span class=\"line\">    int _age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\">@implementation Student</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">//转换成c++后的代码：</span><br><span class=\"line\">struct Student_IMPL &#123;</span><br><span class=\"line\">    struct NSObject_IMPL NSObject_IVARS;//8个字节</span><br><span class=\"line\">    int _grade;//4个字节</span><br><span class=\"line\">    int _age;  //4个字节</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct NSObject_IMPL &#123;</span><br><span class=\"line\">    Class isa;//8个字节</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//实例化一个Student对象，查看其占用的内存大小</span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        Student *stu = [[Student alloc] init];</span><br><span class=\"line\">        stu-&gt;_grade = 3;</span><br><span class=\"line\">        stu-&gt;_age = 5;</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSLog(@&quot;%zd&quot;, class_getInstanceSize([Student class]));</span><br><span class=\"line\">        // &gt;&gt;这里打印出来的结果是 16</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSLog(@&quot;%zd&quot;, malloc_size((__bridge const void *)stu));</span><br><span class=\"line\">        // &gt;&gt;这里打印出来的结果是 16</span><br><span class=\"line\">        </span><br><span class=\"line\">        //用这个方法可以证明stu其实就是`Student_IMPL`这个结构体</span><br><span class=\"line\">        //下方面打印出来的结果跟上面赋值的结果一致</span><br><span class=\"line\">        struct Student_IMPL *stuImpl = (__bridge struct Student_IMPL *)stu;</span><br><span class=\"line\">        NSLog(@&quot;grade is %d, age is %d&quot;, stuImpl-&gt;_grade, stuImpl-&gt;_age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>从NSObject源码分析：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// objc-runtime-new.h</span></span><br><span class=\"line\"><span class=\"comment\">/* NSObject在调用alloc初始化的时候，底层是调用：</span></span><br><span class=\"line\"><span class=\"comment\"> * _objc_rootAllocWithZone() &gt; class_createInstance() &gt; calloc(size_t, size_t)</span></span><br><span class=\"line\"><span class=\"comment\"> * class_createInstance() 最终会调用如下方法来分配内存</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">size_t</span> instanceSize(<span class=\"keyword\">size_t</span> extraBytes) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">size_t</span> size = alignedInstanceSize() + extraBytes;</span><br><span class=\"line\">        <span class=\"comment\">// CF requires all objects be at least 16 bytes.</span></span><br><span class=\"line\">     \t<span class=\"comment\">// 所有CF对象都必须最少16个字节</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">16</span>) size = <span class=\"number\">16</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<h5><span id=\"结论\">结论：</span></h5>\n<ol>\n<li>系统分配了16个字节给NSObject对象(通过<code>malloc_size()</code>函数获得对应对象所指向内存中的大小)</li>\n<li>在64bit环境下，NSObject对象内部只使用了8个字节的空间(通过<code>class_getInstanceSize()</code>函数获得实例对象的大小)，还有8个字节是预留的；</li>\n<li>如果结构体大小小于16个字节时，底层会最小按16来分配，超过16个字节后， 结构体的大小必须是最大成员大小的倍数(如Student结构体中最大为8，如Student超过16后，则会按8的倍数去分配)；</li>\n<li>但在最终分配大小的时候iOS系统做了内存分配的优化，及内存对齐机制，注意这里所说的内存对齐不是指结构体的那个内存对齐，最终分配给结构体的大小为16的倍数(可以从苹果的libmalloc源码中查看，如下图)；</li>\n<li>整体逻辑跟iOS本身的内存对齐机制、及运行机制有关；<br>\n<img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_libmalloc1.png\" alt><br>\n<img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_libmalloc2.png\" alt><br>\n<img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_libmalloc3.png\" alt></li>\n</ol>\n</blockquote>\n<h6><span id=\"其它查看内存大小的方式\">其它查看内存大小的方式</span></h6>\n<blockquote>\n<ol>\n<li>通过xcode的工具来辅助性的查看：Xcode &gt; Debug &gt; Debug Workflew &gt; View Memory &gt; 然后在内存地址栏中输入你要查询的内存地址；</li>\n<li>通过LLDB命令来打印内存地址：<code>(lldb) memory read 0x10331a920</code> 也可以简写成：<code>x 0x10331a920</code>;</li>\n<li>指定的格式来打印内存地址：<code>(lldb) x/3xg 0x10331a920</code>，命令释义：以0x10331a920这个内存地址去读取3串内存地址，每串8个字节数以16进制的格式打印；</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> (lldb) memory <span class=\"built_in\">read</span>/数量+格式+字节数  内存地址</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> (lldb) x/数量+格式+字节数  内存地址</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> 数量：你想读取的个数</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> 格式：x是16进制，f是浮点，d是10进制</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> 字节数：</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> b：byte 1字节，h：half word 2字节</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> w：word 4字节，g：giant word 8字节</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"></span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_lldb_cmd.png\" alt></p>\n<h6><span id=\"写内存\">写内存</span></h6>\n<blockquote>\n<p>写内存：<code>(lldb) memory write 0x10331a928 9</code><br>\n释义：改<code>0x10331a920</code>内存起的第28个字节为9，如下图</p>\n</blockquote>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_memory_write.png\" alt></p>\n<p>注意点：</p>\n<blockquote>\n<p>sizeof( )它是个运算符，不是函数，在编译的时候就确定，编译之后就是个常量，如：</p>\n<p>Student *stu = [[Student alloc] init];</p>\n<p>NSLog(@&quot;%zd&quot;,sizeof( stu )); 打印出来并不是stu占用多少空间，而是*stu这个指针占用的内存空间，结果：8；</p>\n<p><code>class_getInstanceSize()</code>函数返回的仅仅是对象需要占用的内存大小，并非最终系统分配的内存大小。</p>\n</blockquote>\n<h3><span id=\"相关问题二对象的isa指针指向哪里\">相关问题二：对象的isa指针指向哪里？</span></h3>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816214104.png\" alt></p>\n<h3><span id=\"相关问题三oc的类信息存放在哪里\">相关问题三：OC的类信息存放在哪里？</span></h3>\n<p>实例对象里面只存放成员变量，方法不是放在实例对象里的，因为同一类可能实例化成多个对象，但会有相同的方法，这样就只需要创建一份方法，不必须每个实例对象各存一份，每个实例对象里面只存放自已特有的东西。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>NSObject的编译过程：</h3>\n<blockquote>\n<ol>\n<li>我们平时编写的oc代码，底层实现其实都是C/C++代码：<br>\nObjective-C &gt; C/C++ &gt; 汇编语言 &gt; 机器语言代码</li>\n<li>Objective-C对象主要是基于C/C++的结构体来实现的.</li>\n</ol>\n</blockquote>\n<h3>OC代码转成C++代码：</h3>\n<p><strong>我们需要借助转换后的代码来分析</strong></p>\n<blockquote>\n<p>终端命令：<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-obj xxx.m -o xxx.cpp</code><br>\n不指定平台与架构:<code>clang -rewrite-obj xxx.m -o xxx.cpp</code><br>\niphoneos代表要编译的平台，-arch arm64代表平台架构 xxx代表文件名，-o为输出文件；如果报缺少某个库，加参数：-framework 库名</p>\n</blockquote>\n<h3>NSObject的Implementation：</h3>\n<p>参考：<a href=\"https://opensource.apple.com/tarballs\" target=\"_blank\" rel=\"noopener\">苹果源码</a> 、<a href=\"xxx.cpp\">刚才转换出来的xxx.cpp文件</a> 、<a href=\"http://www.gnu.org/software/libc/\" target=\"_blank\" rel=\"noopener\">GNU源码</a></p>\n<h4>借助转换后后C++代码来分析，以下转换后的关键代码：</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//NSObject 定义:也就是说NSObject其实是一个isa指针，指向Class，</span><br><span class=\"line\">//而Class又指向了一个`objc_class`，`objc_class`就是一个结构体，如下:</span><br><span class=\"line\">@interface NSobject &#123;</span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">//NSObject Implementation</span><br><span class=\"line\">struct NSObject_IMPL &#123;</span><br><span class=\"line\">    Class isa; // isa是一个指针，在64位环境下占8个字节</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">typedef struct objc_class *Class;//`objc_class`就是一个结构体</span><br><span class=\"line\"></span><br><span class=\"line\">/// Represents an instance of a class.</span><br><span class=\"line\">struct objc_object &#123;</span><br><span class=\"line\">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">NSObject *obj = [[NSObject alloc] init];</span><br><span class=\"line\">        </span><br><span class=\"line\">// 获得NSObject实例对象的成员变量所占用的大小 &gt;&gt; 8</span><br><span class=\"line\">NSLog(@&quot;%zd&quot;, class_getInstanceSize([NSObject class]));</span><br><span class=\"line\">        </span><br><span class=\"line\">// 获得obj指针所指向内存的大小 &gt;&gt; 16</span><br><span class=\"line\">NSLog(@&quot;%zd&quot;, malloc_size((__bridge const void *)obj));</span><br></pre></td></tr></table></figure>\n<h3>相关问题一：NSObject占用多少个字节</h3>\n<blockquote>\n<p>从上面的打印可知，Class isa本身占用8个字节，NSObject *obj占16个字节，为什么占16个呢？</p>\n</blockquote>\n<ul>\n<li>进一步分析证明：创建一个继承自<code>NSObject</code>带有成员变量的<code>Student</code>对象，如下：\n<ul>\n<li>猜想：按上面的结论一个<code>NSObject</code>实例对象占用16个字节，那下面可能这个<code>Student</code>实例对象应该占用4+4+16 = 24；</li>\n<li>实际：是占用了16个字节， 因为8+4+4=16，没有超过16，也就相当于NSObject的16个字节，有8个其实像是预留的，具体看下面的代码结论。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//申明一个继承自NSObject对象的Student</span><br><span class=\"line\">@interface Student : NSObject &#123;\t</span><br><span class=\"line\">    @public</span><br><span class=\"line\">    int _sex;</span><br><span class=\"line\">    int _age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\">@implementation Student</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">//转换成c++后的代码：</span><br><span class=\"line\">struct Student_IMPL &#123;</span><br><span class=\"line\">    struct NSObject_IMPL NSObject_IVARS;//8个字节</span><br><span class=\"line\">    int _grade;//4个字节</span><br><span class=\"line\">    int _age;  //4个字节</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct NSObject_IMPL &#123;</span><br><span class=\"line\">    Class isa;//8个字节</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//实例化一个Student对象，查看其占用的内存大小</span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        Student *stu = [[Student alloc] init];</span><br><span class=\"line\">        stu-&gt;_grade = 3;</span><br><span class=\"line\">        stu-&gt;_age = 5;</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSLog(@&quot;%zd&quot;, class_getInstanceSize([Student class]));</span><br><span class=\"line\">        // &gt;&gt;这里打印出来的结果是 16</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSLog(@&quot;%zd&quot;, malloc_size((__bridge const void *)stu));</span><br><span class=\"line\">        // &gt;&gt;这里打印出来的结果是 16</span><br><span class=\"line\">        </span><br><span class=\"line\">        //用这个方法可以证明stu其实就是`Student_IMPL`这个结构体</span><br><span class=\"line\">        //下方面打印出来的结果跟上面赋值的结果一致</span><br><span class=\"line\">        struct Student_IMPL *stuImpl = (__bridge struct Student_IMPL *)stu;</span><br><span class=\"line\">        NSLog(@&quot;grade is %d, age is %d&quot;, stuImpl-&gt;_grade, stuImpl-&gt;_age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>从NSObject源码分析：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// objc-runtime-new.h</span></span><br><span class=\"line\"><span class=\"comment\">/* NSObject在调用alloc初始化的时候，底层是调用：</span></span><br><span class=\"line\"><span class=\"comment\"> * _objc_rootAllocWithZone() &gt; class_createInstance() &gt; calloc(size_t, size_t)</span></span><br><span class=\"line\"><span class=\"comment\"> * class_createInstance() 最终会调用如下方法来分配内存</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">size_t</span> instanceSize(<span class=\"keyword\">size_t</span> extraBytes) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">size_t</span> size = alignedInstanceSize() + extraBytes;</span><br><span class=\"line\">        <span class=\"comment\">// CF requires all objects be at least 16 bytes.</span></span><br><span class=\"line\">     \t<span class=\"comment\">// 所有CF对象都必须最少16个字节</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">16</span>) size = <span class=\"number\">16</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<h5>结论：</h5>\n<ol>\n<li>系统分配了16个字节给NSObject对象(通过<code>malloc_size()</code>函数获得对应对象所指向内存中的大小)</li>\n<li>在64bit环境下，NSObject对象内部只使用了8个字节的空间(通过<code>class_getInstanceSize()</code>函数获得实例对象的大小)，还有8个字节是预留的；</li>\n<li>如果结构体大小小于16个字节时，底层会最小按16来分配，超过16个字节后， 结构体的大小必须是最大成员大小的倍数(如Student结构体中最大为8，如Student超过16后，则会按8的倍数去分配)；</li>\n<li>但在最终分配大小的时候iOS系统做了内存分配的优化，及内存对齐机制，注意这里所说的内存对齐不是指结构体的那个内存对齐，最终分配给结构体的大小为16的倍数(可以从苹果的libmalloc源码中查看，如下图)；</li>\n<li>整体逻辑跟iOS本身的内存对齐机制、及运行机制有关；<br>\n<img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_libmalloc1.png\" alt><br>\n<img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_libmalloc2.png\" alt><br>\n<img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_libmalloc3.png\" alt></li>\n</ol>\n</blockquote>\n<h6>其它查看内存大小的方式</h6>\n<blockquote>\n<ol>\n<li>通过xcode的工具来辅助性的查看：Xcode &gt; Debug &gt; Debug Workflew &gt; View Memory &gt; 然后在内存地址栏中输入你要查询的内存地址；</li>\n<li>通过LLDB命令来打印内存地址：<code>(lldb) memory read 0x10331a920</code> 也可以简写成：<code>x 0x10331a920</code>;</li>\n<li>指定的格式来打印内存地址：<code>(lldb) x/3xg 0x10331a920</code>，命令释义：以0x10331a920这个内存地址去读取3串内存地址，每串8个字节数以16进制的格式打印；</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> (lldb) memory <span class=\"built_in\">read</span>/数量+格式+字节数  内存地址</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> (lldb) x/数量+格式+字节数  内存地址</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> 数量：你想读取的个数</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> 格式：x是16进制，f是浮点，d是10进制</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> 字节数：</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> b：byte 1字节，h：half word 2字节</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> w：word 4字节，g：giant word 8字节</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"></span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_lldb_cmd.png\" alt></p>\n<h6>写内存</h6>\n<blockquote>\n<p>写内存：<code>(lldb) memory write 0x10331a928 9</code><br>\n释义：改<code>0x10331a920</code>内存起的第28个字节为9，如下图</p>\n</blockquote>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/NSObject_memory_write.png\" alt></p>\n<p>注意点：</p>\n<blockquote>\n<p>sizeof( )它是个运算符，不是函数，在编译的时候就确定，编译之后就是个常量，如：</p>\n<p>Student *stu = [[Student alloc] init];</p>\n<p>NSLog(@&quot;%zd&quot;,sizeof( stu )); 打印出来并不是stu占用多少空间，而是*stu这个指针占用的内存空间，结果：8；</p>\n<p><code>class_getInstanceSize()</code>函数返回的仅仅是对象需要占用的内存大小，并非最终系统分配的内存大小。</p>\n</blockquote>\n<h3>相关问题二：对象的isa指针指向哪里？</h3>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816214104.png\" alt></p>\n<h3>相关问题三：OC的类信息存放在哪里？</h3>\n<p>实例对象里面只存放成员变量，方法不是放在实例对象里的，因为同一类可能实例化成多个对象，但会有相同的方法，这样就只需要创建一份方法，不必须每个实例对象各存一份，每个实例对象里面只存放自已特有的东西。</p>\n"},{"title":"OC对象分类","date":"2018-08-17T01:47:59.000Z","catagories":["Objective-C"],"_content":"OC对象分类\n> OC对象分类：instance对象(实例对象)、class对象(类对象)、meta-class对象(元类对象)；\n\n### instance对象\n**定义：**通过类alloc出来的对象，就是instance对象，每次调用alloc都会产生新的instance对象；\n**instance对象在内存中存储的信息包括：**\n1. isa指针；\n2. 其它成员变量；\n\n\n\n\n### class对象\n注意：每个类对象在内存中都是唯一的(只有一份)，每个类只有一个元类\n\n获取类对象：[obj class]、object_getClass(obj);\n\n**class对象在内存中存储的信息包括：**\n\n> meta-class对象和class对象的内存结构是一样的，但是用途不一样，在内存中包括的信息主要如下：\n\n1. ias指针；\n2. superclass指针；\n3. 类的属性信息(@property)、类的对象方法信息(instance method)\n4. 类的协议信息(protocol)、类的成员变量信息(ivar)。\n5. 类方法也是放在元类里面的；\n\n\n### meta-class对象\n获得元类对象：\n\n```\n//将类对象当做参数传入，获得元类对象：\nClass metaClass = object_getClass([NSObject class]);\n```\n\n判定一个对象是不是元类：\n\n```\nclass_isMetaClass(obj);\n```\n\n**获取类对象、元类对象的三个方法的区别：**\n\n1. object_getClass([NSObject class]);\n   1. 传入字符串类名，返因对应的类对象；\n\n2. object_getClass(obj)\n   1. 传入的obj可能是instance对象，class对象、meta-class对象；\n   2. 返回：\n      * 如果传的是instance对象，返回class对象；\n      * 如果传的是class对象，返回meta-class对象；\n      * 如果传的是meta-class对象，返回的是NSObject(基类)的meta-class对象；\n\n3. -(Class)class 、+(Class)class\n   返回的就是类对象\n\n### isa指针：存放那些信息？\n\n1. 实例对象(instance)：\n\n   isa、其它成员变量；\n\n2. 类对象(class)：\n\n   isa、superclass、属性、对象方法、协议、成员变量；\n\n3. meta-class：\n\n   isa、superclass、类方法\n\n**instance的isa指向class(类对象)：**当调用对象方法时，通过instance的isa找到class，最后找到对象的方法实现进行调用；\n\n**class的isa指向meta-class：**当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用；**\n\n**meta-class的isa指向基类有meta-class**\n\n**class的superclass指向父类的class，如果没有父类，superclass指针为nil；**\n\n**meta-class的superclass指向的是父类的meta-class**\n\n**注意：**由于NSObject没有superclass，但也不是为空，而是：基类的meta-class对象的superclass指向的是基类的class(类对象)(如下图三)，\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180731212009.png)\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180731212009.png)\n\n![](http://pbflin9sq.bkt.clouddn.com/20180801204622.png)\n\n按上面的流程，举个例分析说明：\n\n```objective-c\nStudent *stu = [[Student alloc] init];\n[stu test];//调用对象方法\n[stu classTest];//调用类方法\n```\n\n> stu调用`test`的调用流程：首先test是对象方法，而对象方法是放在class里面，\n> 流程：通过stu通过自己的isa找到他自己的class，在class对象中找test方法，如果有就展开调用,如果没有class通过isa去superclass的里面找(一层层的往上找，直到继承关系走完)，如果还没有，superclass通过自己的isa去meta-class里面找，最后走到NSObject，如果还是没有找到就会报错：\"unreconized selector sent to instance\"\n> 注意：如果在调用类方法`classTest`，因找不到方法崩溃之前，其实还有最后一步流程，也是我们一般没注意的地方，在基类的meta-class对象找不到`classTest`方法时，它还会去基类的类对象里面找(即上图右上角转角那个箭头)，如果则调用，否则才报错。\n>\n> 可能你觉得很奇怪，meta-class里面存放的是类方法，类里面存放的是对象方法，为什么meta-class类对象里面找不到方法时会找到类的对象方法里面去？具体这个根runtime机制有关，后面有时间我会写runtime相关的问题；\n\n可以进行如下测试：\n\n```objective-c\n@implementation NSObject (Test)\n+ (void)test {\n    NSLog(@\"+[NSObject test] - %p\", self);\n}\n\n- (void)test {\n    NSLog(@\"-[NSObject test] - %p\", self);\n}\n@end\n\n// Person\n@interface Person : NSObject\n\n- (void)test;\n\n@end\n\n@implementation Person\n- (void)test {\n    NSLog(@\"+[Person test] - %p\", self);\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"[Person class] - %p\", [Person class]);\n        NSLog(@\"[NSObject class] - %p\", [NSObject class]);\n        [Person test];\n        [NSObject test];\n    }\n    return 0;\n}\n```\n\n上面我们在NSObject类扩展中申明和实现了一个实例方法，调用的时候调用的是类方法，但你会神奇的发现不会崩溃，而且调用者分别是Person、NSObject；其实就是我们上面所说到的**在基类的meta-class对象找不到`test`方法时，它还会去基类的类对象里面找**.\n\n### 结论：\n\n#### 对象的isa指针指向哪里？\n\n* **instance对象的isa指向class对象；**\n* **class对象的isa指向meta-class对象；**\n* **meta-class对象的isa指向基类的meta-class对象**\n\n#### OC的类信息存放在哪里？\n\n* **对象方法、属性、成员变量、协议信息，存放在class对象中；\n* **类方法，存放在meta-class对象中；**\n* **成员变量的具体值，存放在instance对象；**\n\n#### 窥探struct objc_class结构体\n\n从objc_runtime源码得到如下结构图：\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180801223018.png)\n\n已经编译好一个从objc_runtime源码抽出来工程，可以清楚看到objc_class的内部结构：\n\n代码地址：[窥struct objc_class结构体](https://github.com/nenhall/struct-objc_class)","source":"_posts/OC对象分类.md","raw":"---\ntitle: OC对象分类\ndate: 2018-08-17 09:47:59\ncatagories:\n  - Objective-C\ntags:\n  - NSObject\n  - 底层原理\n---\nOC对象分类\n> OC对象分类：instance对象(实例对象)、class对象(类对象)、meta-class对象(元类对象)；\n\n### instance对象\n**定义：**通过类alloc出来的对象，就是instance对象，每次调用alloc都会产生新的instance对象；\n**instance对象在内存中存储的信息包括：**\n1. isa指针；\n2. 其它成员变量；\n\n\n\n\n### class对象\n注意：每个类对象在内存中都是唯一的(只有一份)，每个类只有一个元类\n\n获取类对象：[obj class]、object_getClass(obj);\n\n**class对象在内存中存储的信息包括：**\n\n> meta-class对象和class对象的内存结构是一样的，但是用途不一样，在内存中包括的信息主要如下：\n\n1. ias指针；\n2. superclass指针；\n3. 类的属性信息(@property)、类的对象方法信息(instance method)\n4. 类的协议信息(protocol)、类的成员变量信息(ivar)。\n5. 类方法也是放在元类里面的；\n\n\n### meta-class对象\n获得元类对象：\n\n```\n//将类对象当做参数传入，获得元类对象：\nClass metaClass = object_getClass([NSObject class]);\n```\n\n判定一个对象是不是元类：\n\n```\nclass_isMetaClass(obj);\n```\n\n**获取类对象、元类对象的三个方法的区别：**\n\n1. object_getClass([NSObject class]);\n   1. 传入字符串类名，返因对应的类对象；\n\n2. object_getClass(obj)\n   1. 传入的obj可能是instance对象，class对象、meta-class对象；\n   2. 返回：\n      * 如果传的是instance对象，返回class对象；\n      * 如果传的是class对象，返回meta-class对象；\n      * 如果传的是meta-class对象，返回的是NSObject(基类)的meta-class对象；\n\n3. -(Class)class 、+(Class)class\n   返回的就是类对象\n\n### isa指针：存放那些信息？\n\n1. 实例对象(instance)：\n\n   isa、其它成员变量；\n\n2. 类对象(class)：\n\n   isa、superclass、属性、对象方法、协议、成员变量；\n\n3. meta-class：\n\n   isa、superclass、类方法\n\n**instance的isa指向class(类对象)：**当调用对象方法时，通过instance的isa找到class，最后找到对象的方法实现进行调用；\n\n**class的isa指向meta-class：**当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用；**\n\n**meta-class的isa指向基类有meta-class**\n\n**class的superclass指向父类的class，如果没有父类，superclass指针为nil；**\n\n**meta-class的superclass指向的是父类的meta-class**\n\n**注意：**由于NSObject没有superclass，但也不是为空，而是：基类的meta-class对象的superclass指向的是基类的class(类对象)(如下图三)，\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180731212009.png)\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180731212009.png)\n\n![](http://pbflin9sq.bkt.clouddn.com/20180801204622.png)\n\n按上面的流程，举个例分析说明：\n\n```objective-c\nStudent *stu = [[Student alloc] init];\n[stu test];//调用对象方法\n[stu classTest];//调用类方法\n```\n\n> stu调用`test`的调用流程：首先test是对象方法，而对象方法是放在class里面，\n> 流程：通过stu通过自己的isa找到他自己的class，在class对象中找test方法，如果有就展开调用,如果没有class通过isa去superclass的里面找(一层层的往上找，直到继承关系走完)，如果还没有，superclass通过自己的isa去meta-class里面找，最后走到NSObject，如果还是没有找到就会报错：\"unreconized selector sent to instance\"\n> 注意：如果在调用类方法`classTest`，因找不到方法崩溃之前，其实还有最后一步流程，也是我们一般没注意的地方，在基类的meta-class对象找不到`classTest`方法时，它还会去基类的类对象里面找(即上图右上角转角那个箭头)，如果则调用，否则才报错。\n>\n> 可能你觉得很奇怪，meta-class里面存放的是类方法，类里面存放的是对象方法，为什么meta-class类对象里面找不到方法时会找到类的对象方法里面去？具体这个根runtime机制有关，后面有时间我会写runtime相关的问题；\n\n可以进行如下测试：\n\n```objective-c\n@implementation NSObject (Test)\n+ (void)test {\n    NSLog(@\"+[NSObject test] - %p\", self);\n}\n\n- (void)test {\n    NSLog(@\"-[NSObject test] - %p\", self);\n}\n@end\n\n// Person\n@interface Person : NSObject\n\n- (void)test;\n\n@end\n\n@implementation Person\n- (void)test {\n    NSLog(@\"+[Person test] - %p\", self);\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"[Person class] - %p\", [Person class]);\n        NSLog(@\"[NSObject class] - %p\", [NSObject class]);\n        [Person test];\n        [NSObject test];\n    }\n    return 0;\n}\n```\n\n上面我们在NSObject类扩展中申明和实现了一个实例方法，调用的时候调用的是类方法，但你会神奇的发现不会崩溃，而且调用者分别是Person、NSObject；其实就是我们上面所说到的**在基类的meta-class对象找不到`test`方法时，它还会去基类的类对象里面找**.\n\n### 结论：\n\n#### 对象的isa指针指向哪里？\n\n* **instance对象的isa指向class对象；**\n* **class对象的isa指向meta-class对象；**\n* **meta-class对象的isa指向基类的meta-class对象**\n\n#### OC的类信息存放在哪里？\n\n* **对象方法、属性、成员变量、协议信息，存放在class对象中；\n* **类方法，存放在meta-class对象中；**\n* **成员变量的具体值，存放在instance对象；**\n\n#### 窥探struct objc_class结构体\n\n从objc_runtime源码得到如下结构图：\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180801223018.png)\n\n已经编译好一个从objc_runtime源码抽出来工程，可以清楚看到objc_class的内部结构：\n\n代码地址：[窥struct objc_class结构体](https://github.com/nenhall/struct-objc_class)","slug":"OC对象分类","published":1,"updated":"2019-02-23T05:39:41.551Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsh3gt4r0008ncezwfd7ltua","content":"<p>OC对象分类</p>\n<blockquote>\n<p>OC对象分类：instance对象(实例对象)、class对象(类对象)、meta-class对象(元类对象)；</p>\n</blockquote>\n<h3><span id=\"instance对象\">instance对象</span></h3>\n<p>**定义：**通过类alloc出来的对象，就是instance对象，每次调用alloc都会产生新的instance对象；<br>\n<strong>instance对象在内存中存储的信息包括：</strong></p>\n<ol>\n<li>isa指针；</li>\n<li>其它成员变量；</li>\n</ol>\n<h3><span id=\"class对象\">class对象</span></h3>\n<p>注意：每个类对象在内存中都是唯一的(只有一份)，每个类只有一个元类</p>\n<p>获取类对象：[obj class]、object_getClass(obj);</p>\n<p><strong>class对象在内存中存储的信息包括：</strong></p>\n<blockquote>\n<p>meta-class对象和class对象的内存结构是一样的，但是用途不一样，在内存中包括的信息主要如下：</p>\n</blockquote>\n<ol>\n<li>ias指针；</li>\n<li>superclass指针；</li>\n<li>类的属性信息(@property)、类的对象方法信息(instance method)</li>\n<li>类的协议信息(protocol)、类的成员变量信息(ivar)。</li>\n<li>类方法也是放在元类里面的；</li>\n</ol>\n<h3><span id=\"meta-class对象\">meta-class对象</span></h3>\n<p>获得元类对象：</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将类对象当做参数传入，获得元类对象：</span></span><br><span class=\"line\">Class metaClass = <span class=\"keyword\">object</span><span class=\"number\">_</span>getClass([NSObject <span class=\"keyword\">class</span>]);</span><br></pre></td></tr></table></figure>\n<p>判定一个对象是不是元类：</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class_isMetaClass(<span class=\"name\">obj</span>)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p><strong>获取类对象、元类对象的三个方法的区别：</strong></p>\n<ol>\n<li>\n<p>object_getClass([NSObject class]);</p>\n<ol>\n<li>传入字符串类名，返因对应的类对象；</li>\n</ol>\n</li>\n<li>\n<p>object_getClass(obj)</p>\n<ol>\n<li>传入的obj可能是instance对象，class对象、meta-class对象；</li>\n<li>返回：\n<ul>\n<li>如果传的是instance对象，返回class对象；</li>\n<li>如果传的是class对象，返回meta-class对象；</li>\n<li>如果传的是meta-class对象，返回的是NSObject(基类)的meta-class对象；</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>-(Class)class 、+(Class)class<br>\n返回的就是类对象</p>\n</li>\n</ol>\n<h3><span id=\"isa指针存放那些信息\">isa指针：存放那些信息？</span></h3>\n<ol>\n<li>\n<p>实例对象(instance)：</p>\n<p>isa、其它成员变量；</p>\n</li>\n<li>\n<p>类对象(class)：</p>\n<p>isa、superclass、属性、对象方法、协议、成员变量；</p>\n</li>\n<li>\n<p>meta-class：</p>\n<p>isa、superclass、类方法</p>\n</li>\n</ol>\n<p>**instance的isa指向class(类对象)：**当调用对象方法时，通过instance的isa找到class，最后找到对象的方法实现进行调用；</p>\n<p>**class的isa指向meta-class：<strong>当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用；</strong></p>\n<p><strong>meta-class的isa指向基类有meta-class</strong></p>\n<p><strong>class的superclass指向父类的class，如果没有父类，superclass指针为nil；</strong></p>\n<p><strong>meta-class的superclass指向的是父类的meta-class</strong></p>\n<p>**注意：**由于NSObject没有superclass，但也不是为空，而是：基类的meta-class对象的superclass指向的是基类的class(类对象)(如下图三)，</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180731212009.png\" alt></p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180731212009.png\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/20180801204622.png\" alt></p>\n<p>按上面的流程，举个例分析说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student *stu = [[Student alloc] init];</span><br><span class=\"line\">[stu test];//调用对象方法</span><br><span class=\"line\">[stu classTest];//调用类方法</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>stu调用<code>test</code>的调用流程：首先test是对象方法，而对象方法是放在class里面，<br>\n流程：通过stu通过自己的isa找到他自己的class，在class对象中找test方法，如果有就展开调用,如果没有class通过isa去superclass的里面找(一层层的往上找，直到继承关系走完)，如果还没有，superclass通过自己的isa去meta-class里面找，最后走到NSObject，如果还是没有找到就会报错：&quot;unreconized selector sent to instance&quot;<br>\n注意：如果在调用类方法<code>classTest</code>，因找不到方法崩溃之前，其实还有最后一步流程，也是我们一般没注意的地方，在基类的meta-class对象找不到<code>classTest</code>方法时，它还会去基类的类对象里面找(即上图右上角转角那个箭头)，如果则调用，否则才报错。</p>\n<p>可能你觉得很奇怪，meta-class里面存放的是类方法，类里面存放的是对象方法，为什么meta-class类对象里面找不到方法时会找到类的对象方法里面去？具体这个根runtime机制有关，后面有时间我会写runtime相关的问题；</p>\n</blockquote>\n<p>可以进行如下测试：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation NSObject (Test)</span><br><span class=\"line\">+ (void)test &#123;</span><br><span class=\"line\">    NSLog(@&quot;+[NSObject test] - %p&quot;, self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)test &#123;</span><br><span class=\"line\">    NSLog(@&quot;-[NSObject test] - %p&quot;, self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">// Person</span><br><span class=\"line\">@interface Person : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)test;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\">- (void)test &#123;</span><br><span class=\"line\">    NSLog(@&quot;+[Person test] - %p&quot;, self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        NSLog(@&quot;[Person class] - %p&quot;, [Person class]);</span><br><span class=\"line\">        NSLog(@&quot;[NSObject class] - %p&quot;, [NSObject class]);</span><br><span class=\"line\">        [Person test];</span><br><span class=\"line\">        [NSObject test];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面我们在NSObject类扩展中申明和实现了一个实例方法，调用的时候调用的是类方法，但你会神奇的发现不会崩溃，而且调用者分别是Person、NSObject；其实就是我们上面所说到的<strong>在基类的meta-class对象找不到<code>test</code>方法时，它还会去基类的类对象里面找</strong>.</p>\n<h3><span id=\"结论\">结论：</span></h3>\n<h4><span id=\"对象的isa指针指向哪里\">对象的isa指针指向哪里？</span></h4>\n<ul>\n<li><strong>instance对象的isa指向class对象；</strong></li>\n<li><strong>class对象的isa指向meta-class对象；</strong></li>\n<li><strong>meta-class对象的isa指向基类的meta-class对象</strong></li>\n</ul>\n<h4><span id=\"oc的类信息存放在哪里\">OC的类信息存放在哪里？</span></h4>\n<ul>\n<li>**对象方法、属性、成员变量、协议信息，存放在class对象中；</li>\n<li><strong>类方法，存放在meta-class对象中；</strong></li>\n<li><strong>成员变量的具体值，存放在instance对象；</strong></li>\n</ul>\n<h4><span id=\"窥探struct-objc_class结构体\">窥探struct objc_class结构体</span></h4>\n<p>从objc_runtime源码得到如下结构图：</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180801223018.png\" alt></p>\n<p>已经编译好一个从objc_runtime源码抽出来工程，可以清楚看到objc_class的内部结构：</p>\n<p>代码地址：<a href=\"https://github.com/nenhall/struct-objc_class\" target=\"_blank\" rel=\"noopener\">窥struct objc_class结构体</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>OC对象分类</p>\n<blockquote>\n<p>OC对象分类：instance对象(实例对象)、class对象(类对象)、meta-class对象(元类对象)；</p>\n</blockquote>\n<h3>instance对象</h3>\n<p>**定义：**通过类alloc出来的对象，就是instance对象，每次调用alloc都会产生新的instance对象；<br>\n<strong>instance对象在内存中存储的信息包括：</strong></p>\n<ol>\n<li>isa指针；</li>\n<li>其它成员变量；</li>\n</ol>\n<h3>class对象</h3>\n<p>注意：每个类对象在内存中都是唯一的(只有一份)，每个类只有一个元类</p>\n<p>获取类对象：[obj class]、object_getClass(obj);</p>\n<p><strong>class对象在内存中存储的信息包括：</strong></p>\n<blockquote>\n<p>meta-class对象和class对象的内存结构是一样的，但是用途不一样，在内存中包括的信息主要如下：</p>\n</blockquote>\n<ol>\n<li>ias指针；</li>\n<li>superclass指针；</li>\n<li>类的属性信息(@property)、类的对象方法信息(instance method)</li>\n<li>类的协议信息(protocol)、类的成员变量信息(ivar)。</li>\n<li>类方法也是放在元类里面的；</li>\n</ol>\n<h3>meta-class对象</h3>\n<p>获得元类对象：</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将类对象当做参数传入，获得元类对象：</span></span><br><span class=\"line\">Class metaClass = <span class=\"keyword\">object</span><span class=\"number\">_</span>getClass([NSObject <span class=\"keyword\">class</span>]);</span><br></pre></td></tr></table></figure>\n<p>判定一个对象是不是元类：</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class_isMetaClass(<span class=\"name\">obj</span>)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p><strong>获取类对象、元类对象的三个方法的区别：</strong></p>\n<ol>\n<li>\n<p>object_getClass([NSObject class]);</p>\n<ol>\n<li>传入字符串类名，返因对应的类对象；</li>\n</ol>\n</li>\n<li>\n<p>object_getClass(obj)</p>\n<ol>\n<li>传入的obj可能是instance对象，class对象、meta-class对象；</li>\n<li>返回：\n<ul>\n<li>如果传的是instance对象，返回class对象；</li>\n<li>如果传的是class对象，返回meta-class对象；</li>\n<li>如果传的是meta-class对象，返回的是NSObject(基类)的meta-class对象；</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>-(Class)class 、+(Class)class<br>\n返回的就是类对象</p>\n</li>\n</ol>\n<h3>isa指针：存放那些信息？</h3>\n<ol>\n<li>\n<p>实例对象(instance)：</p>\n<p>isa、其它成员变量；</p>\n</li>\n<li>\n<p>类对象(class)：</p>\n<p>isa、superclass、属性、对象方法、协议、成员变量；</p>\n</li>\n<li>\n<p>meta-class：</p>\n<p>isa、superclass、类方法</p>\n</li>\n</ol>\n<p>**instance的isa指向class(类对象)：**当调用对象方法时，通过instance的isa找到class，最后找到对象的方法实现进行调用；</p>\n<p>**class的isa指向meta-class：<strong>当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用；</strong></p>\n<p><strong>meta-class的isa指向基类有meta-class</strong></p>\n<p><strong>class的superclass指向父类的class，如果没有父类，superclass指针为nil；</strong></p>\n<p><strong>meta-class的superclass指向的是父类的meta-class</strong></p>\n<p>**注意：**由于NSObject没有superclass，但也不是为空，而是：基类的meta-class对象的superclass指向的是基类的class(类对象)(如下图三)，</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180731212009.png\" alt></p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180731212009.png\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/20180801204622.png\" alt></p>\n<p>按上面的流程，举个例分析说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student *stu = [[Student alloc] init];</span><br><span class=\"line\">[stu test];//调用对象方法</span><br><span class=\"line\">[stu classTest];//调用类方法</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>stu调用<code>test</code>的调用流程：首先test是对象方法，而对象方法是放在class里面，<br>\n流程：通过stu通过自己的isa找到他自己的class，在class对象中找test方法，如果有就展开调用,如果没有class通过isa去superclass的里面找(一层层的往上找，直到继承关系走完)，如果还没有，superclass通过自己的isa去meta-class里面找，最后走到NSObject，如果还是没有找到就会报错：&quot;unreconized selector sent to instance&quot;<br>\n注意：如果在调用类方法<code>classTest</code>，因找不到方法崩溃之前，其实还有最后一步流程，也是我们一般没注意的地方，在基类的meta-class对象找不到<code>classTest</code>方法时，它还会去基类的类对象里面找(即上图右上角转角那个箭头)，如果则调用，否则才报错。</p>\n<p>可能你觉得很奇怪，meta-class里面存放的是类方法，类里面存放的是对象方法，为什么meta-class类对象里面找不到方法时会找到类的对象方法里面去？具体这个根runtime机制有关，后面有时间我会写runtime相关的问题；</p>\n</blockquote>\n<p>可以进行如下测试：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation NSObject (Test)</span><br><span class=\"line\">+ (void)test &#123;</span><br><span class=\"line\">    NSLog(@&quot;+[NSObject test] - %p&quot;, self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)test &#123;</span><br><span class=\"line\">    NSLog(@&quot;-[NSObject test] - %p&quot;, self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">// Person</span><br><span class=\"line\">@interface Person : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)test;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\">- (void)test &#123;</span><br><span class=\"line\">    NSLog(@&quot;+[Person test] - %p&quot;, self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        NSLog(@&quot;[Person class] - %p&quot;, [Person class]);</span><br><span class=\"line\">        NSLog(@&quot;[NSObject class] - %p&quot;, [NSObject class]);</span><br><span class=\"line\">        [Person test];</span><br><span class=\"line\">        [NSObject test];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面我们在NSObject类扩展中申明和实现了一个实例方法，调用的时候调用的是类方法，但你会神奇的发现不会崩溃，而且调用者分别是Person、NSObject；其实就是我们上面所说到的<strong>在基类的meta-class对象找不到<code>test</code>方法时，它还会去基类的类对象里面找</strong>.</p>\n<h3>结论：</h3>\n<h4>对象的isa指针指向哪里？</h4>\n<ul>\n<li><strong>instance对象的isa指向class对象；</strong></li>\n<li><strong>class对象的isa指向meta-class对象；</strong></li>\n<li><strong>meta-class对象的isa指向基类的meta-class对象</strong></li>\n</ul>\n<h4>OC的类信息存放在哪里？</h4>\n<ul>\n<li>**对象方法、属性、成员变量、协议信息，存放在class对象中；</li>\n<li><strong>类方法，存放在meta-class对象中；</strong></li>\n<li><strong>成员变量的具体值，存放在instance对象；</strong></li>\n</ul>\n<h4>窥探struct objc_class结构体</h4>\n<p>从objc_runtime源码得到如下结构图：</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180801223018.png\" alt></p>\n<p>已经编译好一个从objc_runtime源码抽出来工程，可以清楚看到objc_class的内部结构：</p>\n<p>代码地址：<a href=\"https://github.com/nenhall/struct-objc_class\" target=\"_blank\" rel=\"noopener\">窥struct objc_class结构体</a></p>\n"},{"title":"iOS-Category","catalog":true,"date":"2019-02-22T14:45:41.000Z","subtitle":"iOS-Category","header-img":"note_head_img.jpg","catagories":["Objective-C"],"_content":"\n## Category\n\n### 扩展里面的方法存放\n\n- 对象方法：不管写了多少个分类，分类里面写了多少对象方法，最终(注意)都是存放在唯一的一个类对象里面，调用的时候都是通过instance的isa指针去(class)那里面找。\n- 类方法：不管写了多少个分类，分类里面写了多少类方法，最终都是存放在唯一的一个元类(meta-class)里面，调用的时候都是通过class的isa指针去(meta-class)那里面找。\n\n![](/Users/nenhall/Desktop/iOS-Category.png)\n\n- 最终通过runtime动态将分类的方法合并到类对象、元类对象中，并不是在编译的时候合并的；\n\n  > 分类在编译完后，其实是转成了如下结构体，把结构体的信息存放在这个结构体下，并申明了一个_category_t的成员变量，并进行赋值：\n\n通过代码进行证明：\n\n```objective-c\n#import \"Person+Test.h\"\n@implementation Person (Test)\n- (void)run { NSLog(@\"Person (Test) - run\"); }\n\n- (void)test { NSLog(@\"test\"); }\n\n+ (void)test2 {  }\n@end\n```\n\n通过clang将其转c++代码查看，如下图1，可以看到，有一个大的结构体：`_category_t `，大的结构体内又包含了好多结构体，每个结构体里面存放着不同的属性：类基本信息、实例方法、类方法、遵守的协议列表、属性列表。\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816221520.png)\n\n再看看结构体赋值，是一一对应赋值的：\n如果有多个分类，它生成的结构体名字都是`_category_t `，只不过后面的名字不一样：` _OBJC_$_CATEGORY_Person_$_Test`\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816222138.png)\n\n\n\n### Category的实现原理：\n\n1. Category编译之后的底层结构是struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息；\n2. 在程序运行的时候，runtime会将Category的数据，合并到类信息中(类对象、元类对象)；\n\n### Category和Class Extension的区别\n\n1. Class Extension在编译的时候，它的数据就已经包含在类信息中；\n2. Category是在运行时，才会将数据合并到类信息中；\n\n\n\n### Category的加载过程\n\n1. 通过Runtime加载某个类的所有Category数据\n2. 把所有Category的方法、属性、协议数据，合并到一个大数组中\n   - 后面参与编译的Category数据，会在数组的前面\n3. 将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面\n\n**源码解读顺序，按以下顺序阅读源码可能更容易懂：**\n\n- objc-os.mm\n  - _objc_init\n  - map_images\n  - map_images_nolock\n- objc-runtime-new.mm\n  - _read_images\n  - remethodizeClass\n  - attachCategories\n  - attachLists\n  - realloc、memmove、 memcpy\n\n### +(void)load为什么里不会覆盖？\n\n- 去runtime的源码里面看，有如下函数：\n- 系统会自动先加载类的`+(void)load`方法，然后再加载分类的`+(void)load`方法，而且都是直接通过内存地址直接加载的，与加载正常方法不一样，正常我们执行一个方法是：去类或者元类里面找，找到然后通过**消息机制**进行调用，这里则不是使用**消息机制**。\n- `+(void)load`方法是先编译的类，就会先调用，不管是在类还是分类中的`+(void)load`方法；但在分类中的对于我们自己定义的方法，加载顺序则相反：当类和分类都实现了同一个方法时，我们调用对应方法时，执行的是分类里面的方法；因为如前面所说分类的方法会在程序运行时合并到类信息内，越往后加载的分类，分类的信息存放在越前面，调用时依次查找，找到后就不再往后查找。\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181010213330.png)\n\n- 假如存在继承的时候，会优先调用父类的`+(void)load`方法，而且每个类的`+(void)load`只会调用一次，源码的实现如下：\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181010215509.png)\n\n\n\n### +(void)load方法什么时候调用(总结)：\n\n- runtime加载类、分类的时候调用，即使你还没有初始化那有类，也会调用；\n- 每个类、分类的+load方法，在程序运行过程中只调用一次\n\n**调用顺序：**\n\n- 先调用类的+load\n  - 按照编译先后顺序调用（先编译，先调用）\n  - 调用子类的+load之前会先调用父类的+load\n\n- 再调用分类的+load\n  - 按照编译先后顺序调用（先编译，先调用）\n- +(void)load方法可以继承，但一般不会这么做，因为这个方法都是由系统主动调用的，我们主动调用时其实就相当于使用了`objc_msgSend()`消息机制，发送了一个消息。\n\n#### objc4源码解读过程：objc-os.mm\n\n- _objc_init\n- load_images\n- prepare_load_methods\n  - schedule_class_load\n  - add_class_to_loadable_list\n  - add_category_to_loadable_list\n- call_load_methods\n  - call_class_loads\n  - call_category_loads\n  - (*load_method)(cls, SEL_load)\n- +load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用\n\n### +(void)initialize与+(void)load方法的区别：\n\n- `+(void)initialize`方法是通过objc_msgSend进行调用的，而`+(void)load`方法是直接对应的方法地址进行调用用的；\n- `+(void)initialize`方法会在类第一次接收到消息时调用(如下图一runtime源码)；\n- 调用顺序：对应的类存在继承时，会先调用父类`+(void)initialize`方法，再调用子类的`+(void)initialize`方法(如下图二runtime源码)；\n- 也正因为`+(void)initialize`方法是通过objc_msgSend进行调用，所以存在以两种情况：\n  - 所以如果分类实现了`+(void)initialize`，就会覆盖类本身的`+(void)initialize`方法；\n  - 如果子类没有实现`+(void)initialize`方法，会调用父类的`+(void)initialize`方法，所以父类的`+(void)initialize`有可能会被调用多次；\n\n![判定是否初始化](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181011214333.png)\n\n![递归调用initialize](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181011214956.png)\n\n#### objc4源码解读过程\n\n- objc-msg-arm64.s\n  - objc_msgSend\n- objc-runtime-new.mm\n  - class_getInstanceMethod\n  - lookUpImpOrNil\n  - lookUpImpOrForward\n  - _class_initialize\n  - callInitialize\n  - objc_msgSend(cls, SEL_initialize)\n\n\n\n### 关联对象：\n\nCategory无法添加成员变量，但可以通过关联对象的api来间接的实现给对象添加属性；\n\n**原理：**\n\n- 关联对象并不是存储在被关联对象本身内存中\n- 关联对象存储在全局的统一的一个AssociationsManager中\n- 设置关联对象为nil，就相当于是移除关联对象\n- 实现关联对象技术的核心对象有\n  - AssociationsManager\n  - AssociationsHashMap\n  - ObjectAssociationMap\n  - ObjcAssociation\n- objc4源码解读：objc-references.mm\n\n说明：通过一个`AssociationManager`的类来管理关联的对象，`AssociationManager`里面存放着一个`AssociationsHashMap`对象，里面以类似字典的形式来存放所关联的对象，及关联信息，所关联的对象作为key(disguised_ptr_t)，关联信息为值(ObjectAssociationMap)；`ObjectAssociationMap`又是以字典形式存放对应信息的：`const void *key`作为key，值即包装成了一个`ObjectAssociation`，里面存着：关联策略、关联的值。(如下图)\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016203113.png)","source":"_posts/iOS-Category.md","raw":"---\ntitle: iOS-Category\ncatalog: true\ndate: 2019-02-22 22:45:41\nsubtitle: iOS-Category\nheader-img: note_head_img.jpg\ncatagories:\n  - Objective-C\ntags:\n  - NSObject\n  - 底层原理\n---\n\n## Category\n\n### 扩展里面的方法存放\n\n- 对象方法：不管写了多少个分类，分类里面写了多少对象方法，最终(注意)都是存放在唯一的一个类对象里面，调用的时候都是通过instance的isa指针去(class)那里面找。\n- 类方法：不管写了多少个分类，分类里面写了多少类方法，最终都是存放在唯一的一个元类(meta-class)里面，调用的时候都是通过class的isa指针去(meta-class)那里面找。\n\n![](/Users/nenhall/Desktop/iOS-Category.png)\n\n- 最终通过runtime动态将分类的方法合并到类对象、元类对象中，并不是在编译的时候合并的；\n\n  > 分类在编译完后，其实是转成了如下结构体，把结构体的信息存放在这个结构体下，并申明了一个_category_t的成员变量，并进行赋值：\n\n通过代码进行证明：\n\n```objective-c\n#import \"Person+Test.h\"\n@implementation Person (Test)\n- (void)run { NSLog(@\"Person (Test) - run\"); }\n\n- (void)test { NSLog(@\"test\"); }\n\n+ (void)test2 {  }\n@end\n```\n\n通过clang将其转c++代码查看，如下图1，可以看到，有一个大的结构体：`_category_t `，大的结构体内又包含了好多结构体，每个结构体里面存放着不同的属性：类基本信息、实例方法、类方法、遵守的协议列表、属性列表。\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816221520.png)\n\n再看看结构体赋值，是一一对应赋值的：\n如果有多个分类，它生成的结构体名字都是`_category_t `，只不过后面的名字不一样：` _OBJC_$_CATEGORY_Person_$_Test`\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816222138.png)\n\n\n\n### Category的实现原理：\n\n1. Category编译之后的底层结构是struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息；\n2. 在程序运行的时候，runtime会将Category的数据，合并到类信息中(类对象、元类对象)；\n\n### Category和Class Extension的区别\n\n1. Class Extension在编译的时候，它的数据就已经包含在类信息中；\n2. Category是在运行时，才会将数据合并到类信息中；\n\n\n\n### Category的加载过程\n\n1. 通过Runtime加载某个类的所有Category数据\n2. 把所有Category的方法、属性、协议数据，合并到一个大数组中\n   - 后面参与编译的Category数据，会在数组的前面\n3. 将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面\n\n**源码解读顺序，按以下顺序阅读源码可能更容易懂：**\n\n- objc-os.mm\n  - _objc_init\n  - map_images\n  - map_images_nolock\n- objc-runtime-new.mm\n  - _read_images\n  - remethodizeClass\n  - attachCategories\n  - attachLists\n  - realloc、memmove、 memcpy\n\n### +(void)load为什么里不会覆盖？\n\n- 去runtime的源码里面看，有如下函数：\n- 系统会自动先加载类的`+(void)load`方法，然后再加载分类的`+(void)load`方法，而且都是直接通过内存地址直接加载的，与加载正常方法不一样，正常我们执行一个方法是：去类或者元类里面找，找到然后通过**消息机制**进行调用，这里则不是使用**消息机制**。\n- `+(void)load`方法是先编译的类，就会先调用，不管是在类还是分类中的`+(void)load`方法；但在分类中的对于我们自己定义的方法，加载顺序则相反：当类和分类都实现了同一个方法时，我们调用对应方法时，执行的是分类里面的方法；因为如前面所说分类的方法会在程序运行时合并到类信息内，越往后加载的分类，分类的信息存放在越前面，调用时依次查找，找到后就不再往后查找。\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181010213330.png)\n\n- 假如存在继承的时候，会优先调用父类的`+(void)load`方法，而且每个类的`+(void)load`只会调用一次，源码的实现如下：\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181010215509.png)\n\n\n\n### +(void)load方法什么时候调用(总结)：\n\n- runtime加载类、分类的时候调用，即使你还没有初始化那有类，也会调用；\n- 每个类、分类的+load方法，在程序运行过程中只调用一次\n\n**调用顺序：**\n\n- 先调用类的+load\n  - 按照编译先后顺序调用（先编译，先调用）\n  - 调用子类的+load之前会先调用父类的+load\n\n- 再调用分类的+load\n  - 按照编译先后顺序调用（先编译，先调用）\n- +(void)load方法可以继承，但一般不会这么做，因为这个方法都是由系统主动调用的，我们主动调用时其实就相当于使用了`objc_msgSend()`消息机制，发送了一个消息。\n\n#### objc4源码解读过程：objc-os.mm\n\n- _objc_init\n- load_images\n- prepare_load_methods\n  - schedule_class_load\n  - add_class_to_loadable_list\n  - add_category_to_loadable_list\n- call_load_methods\n  - call_class_loads\n  - call_category_loads\n  - (*load_method)(cls, SEL_load)\n- +load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用\n\n### +(void)initialize与+(void)load方法的区别：\n\n- `+(void)initialize`方法是通过objc_msgSend进行调用的，而`+(void)load`方法是直接对应的方法地址进行调用用的；\n- `+(void)initialize`方法会在类第一次接收到消息时调用(如下图一runtime源码)；\n- 调用顺序：对应的类存在继承时，会先调用父类`+(void)initialize`方法，再调用子类的`+(void)initialize`方法(如下图二runtime源码)；\n- 也正因为`+(void)initialize`方法是通过objc_msgSend进行调用，所以存在以两种情况：\n  - 所以如果分类实现了`+(void)initialize`，就会覆盖类本身的`+(void)initialize`方法；\n  - 如果子类没有实现`+(void)initialize`方法，会调用父类的`+(void)initialize`方法，所以父类的`+(void)initialize`有可能会被调用多次；\n\n![判定是否初始化](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181011214333.png)\n\n![递归调用initialize](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181011214956.png)\n\n#### objc4源码解读过程\n\n- objc-msg-arm64.s\n  - objc_msgSend\n- objc-runtime-new.mm\n  - class_getInstanceMethod\n  - lookUpImpOrNil\n  - lookUpImpOrForward\n  - _class_initialize\n  - callInitialize\n  - objc_msgSend(cls, SEL_initialize)\n\n\n\n### 关联对象：\n\nCategory无法添加成员变量，但可以通过关联对象的api来间接的实现给对象添加属性；\n\n**原理：**\n\n- 关联对象并不是存储在被关联对象本身内存中\n- 关联对象存储在全局的统一的一个AssociationsManager中\n- 设置关联对象为nil，就相当于是移除关联对象\n- 实现关联对象技术的核心对象有\n  - AssociationsManager\n  - AssociationsHashMap\n  - ObjectAssociationMap\n  - ObjcAssociation\n- objc4源码解读：objc-references.mm\n\n说明：通过一个`AssociationManager`的类来管理关联的对象，`AssociationManager`里面存放着一个`AssociationsHashMap`对象，里面以类似字典的形式来存放所关联的对象，及关联信息，所关联的对象作为key(disguised_ptr_t)，关联信息为值(ObjectAssociationMap)；`ObjectAssociationMap`又是以字典形式存放对应信息的：`const void *key`作为key，值即包装成了一个`ObjectAssociation`，里面存着：关联策略、关联的值。(如下图)\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016203113.png)","slug":"iOS-Category","published":1,"updated":"2019-02-23T05:38:46.601Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsh3gt4s0009ncezgyojielq","content":"<h2><span id=\"category\">Category</span></h2>\n<h3><span id=\"扩展里面的方法存放\">扩展里面的方法存放</span></h3>\n<ul>\n<li>对象方法：不管写了多少个分类，分类里面写了多少对象方法，最终(注意)都是存放在唯一的一个类对象里面，调用的时候都是通过instance的isa指针去(class)那里面找。</li>\n<li>类方法：不管写了多少个分类，分类里面写了多少类方法，最终都是存放在唯一的一个元类(meta-class)里面，调用的时候都是通过class的isa指针去(meta-class)那里面找。</li>\n</ul>\n<p><img src=\"/Users/nenhall/Desktop/iOS-Category.png\" alt></p>\n<ul>\n<li>\n<p>最终通过runtime动态将分类的方法合并到类对象、元类对象中，并不是在编译的时候合并的；</p>\n<blockquote>\n<p>分类在编译完后，其实是转成了如下结构体，把结构体的信息存放在这个结构体下，并申明了一个_category_t的成员变量，并进行赋值：</p>\n</blockquote>\n</li>\n</ul>\n<p>通过代码进行证明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;Person+Test.h&quot;</span><br><span class=\"line\">@implementation Person (Test)</span><br><span class=\"line\">- (void)run &#123; NSLog(@&quot;Person (Test) - run&quot;); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)test &#123; NSLog(@&quot;test&quot;); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)test2 &#123;  &#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>通过clang将其转c++代码查看，如下图1，可以看到，有一个大的结构体：<code>_category_t</code>，大的结构体内又包含了好多结构体，每个结构体里面存放着不同的属性：类基本信息、实例方法、类方法、遵守的协议列表、属性列表。</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816221520.png\" alt></p>\n<p>再看看结构体赋值，是一一对应赋值的：<br>\n如果有多个分类，它生成的结构体名字都是<code>_category_t</code>，只不过后面的名字不一样：<code>_OBJC_$_CATEGORY_Person_$_Test</code><br>\n<img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816222138.png\" alt></p>\n<h3><span id=\"category的实现原理\">Category的实现原理：</span></h3>\n<ol>\n<li>Category编译之后的底层结构是struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息；</li>\n<li>在程序运行的时候，runtime会将Category的数据，合并到类信息中(类对象、元类对象)；</li>\n</ol>\n<h3><span id=\"category和class-extension的区别\">Category和Class Extension的区别</span></h3>\n<ol>\n<li>Class Extension在编译的时候，它的数据就已经包含在类信息中；</li>\n<li>Category是在运行时，才会将数据合并到类信息中；</li>\n</ol>\n<h3><span id=\"category的加载过程\">Category的加载过程</span></h3>\n<ol>\n<li>通过Runtime加载某个类的所有Category数据</li>\n<li>把所有Category的方法、属性、协议数据，合并到一个大数组中\n<ul>\n<li>后面参与编译的Category数据，会在数组的前面</li>\n</ul>\n</li>\n<li>将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面</li>\n</ol>\n<p><strong>源码解读顺序，按以下顺序阅读源码可能更容易懂：</strong></p>\n<ul>\n<li><a href=\"http://objc-os.mm\" target=\"_blank\" rel=\"noopener\">objc-os.mm</a>\n<ul>\n<li>_objc_init</li>\n<li>map_images</li>\n<li>map_images_nolock</li>\n</ul>\n</li>\n<li><a href=\"http://objc-runtime-new.mm\" target=\"_blank\" rel=\"noopener\">objc-runtime-new.mm</a>\n<ul>\n<li>_read_images</li>\n<li>remethodizeClass</li>\n<li>attachCategories</li>\n<li>attachLists</li>\n<li>realloc、memmove、 memcpy</li>\n</ul>\n</li>\n</ul>\n<h3><span id=\"voidload为什么里不会覆盖\">+(void)load为什么里不会覆盖？</span></h3>\n<ul>\n<li>去runtime的源码里面看，有如下函数：</li>\n<li>系统会自动先加载类的<code>+(void)load</code>方法，然后再加载分类的<code>+(void)load</code>方法，而且都是直接通过内存地址直接加载的，与加载正常方法不一样，正常我们执行一个方法是：去类或者元类里面找，找到然后通过<strong>消息机制</strong>进行调用，这里则不是使用<strong>消息机制</strong>。</li>\n<li><code>+(void)load</code>方法是先编译的类，就会先调用，不管是在类还是分类中的<code>+(void)load</code>方法；但在分类中的对于我们自己定义的方法，加载顺序则相反：当类和分类都实现了同一个方法时，我们调用对应方法时，执行的是分类里面的方法；因为如前面所说分类的方法会在程序运行时合并到类信息内，越往后加载的分类，分类的信息存放在越前面，调用时依次查找，找到后就不再往后查找。</li>\n</ul>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181010213330.png\" alt></p>\n<ul>\n<li>假如存在继承的时候，会优先调用父类的<code>+(void)load</code>方法，而且每个类的<code>+(void)load</code>只会调用一次，源码的实现如下：</li>\n</ul>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181010215509.png\" alt></p>\n<h3><span id=\"voidload方法什么时候调用总结\">+(void)load方法什么时候调用(总结)：</span></h3>\n<ul>\n<li>runtime加载类、分类的时候调用，即使你还没有初始化那有类，也会调用；</li>\n<li>每个类、分类的+load方法，在程序运行过程中只调用一次</li>\n</ul>\n<p><strong>调用顺序：</strong></p>\n<ul>\n<li>\n<p>先调用类的+load</p>\n<ul>\n<li>按照编译先后顺序调用（先编译，先调用）</li>\n<li>调用子类的+load之前会先调用父类的+load</li>\n</ul>\n</li>\n<li>\n<p>再调用分类的+load</p>\n<ul>\n<li>按照编译先后顺序调用（先编译，先调用）</li>\n</ul>\n</li>\n<li>\n<p>+(void)load方法可以继承，但一般不会这么做，因为这个方法都是由系统主动调用的，我们主动调用时其实就相当于使用了<code>objc_msgSend()</code>消息机制，发送了一个消息。</p>\n</li>\n</ul>\n<h4><span id=\"objc4源码解读过程objc-osmm\">objc4源码解读过程：</span></h4>\n<ul>\n<li>_objc_init</li>\n<li>load_images</li>\n<li>prepare_load_methods\n<ul>\n<li>schedule_class_load</li>\n<li>add_class_to_loadable_list</li>\n<li>add_category_to_loadable_list</li>\n</ul>\n</li>\n<li>call_load_methods\n<ul>\n<li>call_class_loads</li>\n<li>call_category_loads</li>\n<li>(*load_method)(cls, SEL_load)</li>\n</ul>\n</li>\n<li>+load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用</li>\n</ul>\n<h3><span id=\"voidinitialize与voidload方法的区别\">+(void)initialize与+(void)load方法的区别：</span></h3>\n<ul>\n<li><code>+(void)initialize</code>方法是通过objc_msgSend进行调用的，而<code>+(void)load</code>方法是直接对应的方法地址进行调用用的；</li>\n<li><code>+(void)initialize</code>方法会在类第一次接收到消息时调用(如下图一runtime源码)；</li>\n<li>调用顺序：对应的类存在继承时，会先调用父类<code>+(void)initialize</code>方法，再调用子类的<code>+(void)initialize</code>方法(如下图二runtime源码)；</li>\n<li>也正因为<code>+(void)initialize</code>方法是通过objc_msgSend进行调用，所以存在以两种情况：\n<ul>\n<li>所以如果分类实现了<code>+(void)initialize</code>，就会覆盖类本身的<code>+(void)initialize</code>方法；</li>\n<li>如果子类没有实现<code>+(void)initialize</code>方法，会调用父类的<code>+(void)initialize</code>方法，所以父类的<code>+(void)initialize</code>有可能会被调用多次；</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181011214333.png\" alt=\"判定是否初始化\"></p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181011214956.png\" alt=\"递归调用initialize\"></p>\n<h4><span id=\"objc4源码解读过程\">objc4源码解读过程</span></h4>\n<ul>\n<li>objc-msg-arm64.s\n<ul>\n<li>objc_msgSend</li>\n</ul>\n</li>\n<li><a href=\"http://objc-runtime-new.mm\" target=\"_blank\" rel=\"noopener\">objc-runtime-new.mm</a>\n<ul>\n<li>class_getInstanceMethod</li>\n<li>lookUpImpOrNil</li>\n<li>lookUpImpOrForward</li>\n<li>_class_initialize</li>\n<li>callInitialize</li>\n<li>objc_msgSend(cls, SEL_initialize)</li>\n</ul>\n</li>\n</ul>\n<h3><span id=\"关联对象\">关联对象：</span></h3>\n<p>Category无法添加成员变量，但可以通过关联对象的api来间接的实现给对象添加属性；</p>\n<p><strong>原理：</strong></p>\n<ul>\n<li>关联对象并不是存储在被关联对象本身内存中</li>\n<li>关联对象存储在全局的统一的一个AssociationsManager中</li>\n<li>设置关联对象为nil，就相当于是移除关联对象</li>\n<li>实现关联对象技术的核心对象有\n<ul>\n<li>AssociationsManager</li>\n<li>AssociationsHashMap</li>\n<li>ObjectAssociationMap</li>\n<li>ObjcAssociation</li>\n</ul>\n</li>\n<li>objc4源码解读：<a href=\"http://objc-references.mm\" target=\"_blank\" rel=\"noopener\">objc-references.mm</a></li>\n</ul>\n<p>说明：通过一个<code>AssociationManager</code>的类来管理关联的对象，<code>AssociationManager</code>里面存放着一个<code>AssociationsHashMap</code>对象，里面以类似字典的形式来存放所关联的对象，及关联信息，所关联的对象作为key(disguised_ptr_t)，关联信息为值(ObjectAssociationMap)；<code>ObjectAssociationMap</code>又是以字典形式存放对应信息的：<code>const void *key</code>作为key，值即包装成了一个<code>ObjectAssociation</code>，里面存着：关联策略、关联的值。(如下图)</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016203113.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h2>Category</h2>\n<h3>扩展里面的方法存放</h3>\n<ul>\n<li>对象方法：不管写了多少个分类，分类里面写了多少对象方法，最终(注意)都是存放在唯一的一个类对象里面，调用的时候都是通过instance的isa指针去(class)那里面找。</li>\n<li>类方法：不管写了多少个分类，分类里面写了多少类方法，最终都是存放在唯一的一个元类(meta-class)里面，调用的时候都是通过class的isa指针去(meta-class)那里面找。</li>\n</ul>\n<p><img src=\"/Users/nenhall/Desktop/iOS-Category.png\" alt></p>\n<ul>\n<li>\n<p>最终通过runtime动态将分类的方法合并到类对象、元类对象中，并不是在编译的时候合并的；</p>\n<blockquote>\n<p>分类在编译完后，其实是转成了如下结构体，把结构体的信息存放在这个结构体下，并申明了一个_category_t的成员变量，并进行赋值：</p>\n</blockquote>\n</li>\n</ul>\n<p>通过代码进行证明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;Person+Test.h&quot;</span><br><span class=\"line\">@implementation Person (Test)</span><br><span class=\"line\">- (void)run &#123; NSLog(@&quot;Person (Test) - run&quot;); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)test &#123; NSLog(@&quot;test&quot;); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)test2 &#123;  &#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>通过clang将其转c++代码查看，如下图1，可以看到，有一个大的结构体：<code>_category_t</code>，大的结构体内又包含了好多结构体，每个结构体里面存放着不同的属性：类基本信息、实例方法、类方法、遵守的协议列表、属性列表。</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816221520.png\" alt></p>\n<p>再看看结构体赋值，是一一对应赋值的：<br>\n如果有多个分类，它生成的结构体名字都是<code>_category_t</code>，只不过后面的名字不一样：<code>_OBJC_$_CATEGORY_Person_$_Test</code><br>\n<img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180816222138.png\" alt></p>\n<h3>Category的实现原理：</h3>\n<ol>\n<li>Category编译之后的底层结构是struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息；</li>\n<li>在程序运行的时候，runtime会将Category的数据，合并到类信息中(类对象、元类对象)；</li>\n</ol>\n<h3>Category和Class Extension的区别</h3>\n<ol>\n<li>Class Extension在编译的时候，它的数据就已经包含在类信息中；</li>\n<li>Category是在运行时，才会将数据合并到类信息中；</li>\n</ol>\n<h3>Category的加载过程</h3>\n<ol>\n<li>通过Runtime加载某个类的所有Category数据</li>\n<li>把所有Category的方法、属性、协议数据，合并到一个大数组中\n<ul>\n<li>后面参与编译的Category数据，会在数组的前面</li>\n</ul>\n</li>\n<li>将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面</li>\n</ol>\n<p><strong>源码解读顺序，按以下顺序阅读源码可能更容易懂：</strong></p>\n<ul>\n<li><a href=\"http://objc-os.mm\" target=\"_blank\" rel=\"noopener\">objc-os.mm</a>\n<ul>\n<li>_objc_init</li>\n<li>map_images</li>\n<li>map_images_nolock</li>\n</ul>\n</li>\n<li><a href=\"http://objc-runtime-new.mm\" target=\"_blank\" rel=\"noopener\">objc-runtime-new.mm</a>\n<ul>\n<li>_read_images</li>\n<li>remethodizeClass</li>\n<li>attachCategories</li>\n<li>attachLists</li>\n<li>realloc、memmove、 memcpy</li>\n</ul>\n</li>\n</ul>\n<h3>+(void)load为什么里不会覆盖？</h3>\n<ul>\n<li>去runtime的源码里面看，有如下函数：</li>\n<li>系统会自动先加载类的<code>+(void)load</code>方法，然后再加载分类的<code>+(void)load</code>方法，而且都是直接通过内存地址直接加载的，与加载正常方法不一样，正常我们执行一个方法是：去类或者元类里面找，找到然后通过<strong>消息机制</strong>进行调用，这里则不是使用<strong>消息机制</strong>。</li>\n<li><code>+(void)load</code>方法是先编译的类，就会先调用，不管是在类还是分类中的<code>+(void)load</code>方法；但在分类中的对于我们自己定义的方法，加载顺序则相反：当类和分类都实现了同一个方法时，我们调用对应方法时，执行的是分类里面的方法；因为如前面所说分类的方法会在程序运行时合并到类信息内，越往后加载的分类，分类的信息存放在越前面，调用时依次查找，找到后就不再往后查找。</li>\n</ul>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181010213330.png\" alt></p>\n<ul>\n<li>假如存在继承的时候，会优先调用父类的<code>+(void)load</code>方法，而且每个类的<code>+(void)load</code>只会调用一次，源码的实现如下：</li>\n</ul>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181010215509.png\" alt></p>\n<h3>+(void)load方法什么时候调用(总结)：</h3>\n<ul>\n<li>runtime加载类、分类的时候调用，即使你还没有初始化那有类，也会调用；</li>\n<li>每个类、分类的+load方法，在程序运行过程中只调用一次</li>\n</ul>\n<p><strong>调用顺序：</strong></p>\n<ul>\n<li>\n<p>先调用类的+load</p>\n<ul>\n<li>按照编译先后顺序调用（先编译，先调用）</li>\n<li>调用子类的+load之前会先调用父类的+load</li>\n</ul>\n</li>\n<li>\n<p>再调用分类的+load</p>\n<ul>\n<li>按照编译先后顺序调用（先编译，先调用）</li>\n</ul>\n</li>\n<li>\n<p>+(void)load方法可以继承，但一般不会这么做，因为这个方法都是由系统主动调用的，我们主动调用时其实就相当于使用了<code>objc_msgSend()</code>消息机制，发送了一个消息。</p>\n</li>\n</ul>\n<h4>objc4源码解读过程：<a href=\"http://objc-os.mm\" target=\"_blank\" rel=\"noopener\">objc-os.mm</a></h4>\n<ul>\n<li>_objc_init</li>\n<li>load_images</li>\n<li>prepare_load_methods\n<ul>\n<li>schedule_class_load</li>\n<li>add_class_to_loadable_list</li>\n<li>add_category_to_loadable_list</li>\n</ul>\n</li>\n<li>call_load_methods\n<ul>\n<li>call_class_loads</li>\n<li>call_category_loads</li>\n<li>(*load_method)(cls, SEL_load)</li>\n</ul>\n</li>\n<li>+load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用</li>\n</ul>\n<h3>+(void)initialize与+(void)load方法的区别：</h3>\n<ul>\n<li><code>+(void)initialize</code>方法是通过objc_msgSend进行调用的，而<code>+(void)load</code>方法是直接对应的方法地址进行调用用的；</li>\n<li><code>+(void)initialize</code>方法会在类第一次接收到消息时调用(如下图一runtime源码)；</li>\n<li>调用顺序：对应的类存在继承时，会先调用父类<code>+(void)initialize</code>方法，再调用子类的<code>+(void)initialize</code>方法(如下图二runtime源码)；</li>\n<li>也正因为<code>+(void)initialize</code>方法是通过objc_msgSend进行调用，所以存在以两种情况：\n<ul>\n<li>所以如果分类实现了<code>+(void)initialize</code>，就会覆盖类本身的<code>+(void)initialize</code>方法；</li>\n<li>如果子类没有实现<code>+(void)initialize</code>方法，会调用父类的<code>+(void)initialize</code>方法，所以父类的<code>+(void)initialize</code>有可能会被调用多次；</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181011214333.png\" alt=\"判定是否初始化\"></p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181011214956.png\" alt=\"递归调用initialize\"></p>\n<h4>objc4源码解读过程</h4>\n<ul>\n<li>objc-msg-arm64.s\n<ul>\n<li>objc_msgSend</li>\n</ul>\n</li>\n<li><a href=\"http://objc-runtime-new.mm\" target=\"_blank\" rel=\"noopener\">objc-runtime-new.mm</a>\n<ul>\n<li>class_getInstanceMethod</li>\n<li>lookUpImpOrNil</li>\n<li>lookUpImpOrForward</li>\n<li>_class_initialize</li>\n<li>callInitialize</li>\n<li>objc_msgSend(cls, SEL_initialize)</li>\n</ul>\n</li>\n</ul>\n<h3>关联对象：</h3>\n<p>Category无法添加成员变量，但可以通过关联对象的api来间接的实现给对象添加属性；</p>\n<p><strong>原理：</strong></p>\n<ul>\n<li>关联对象并不是存储在被关联对象本身内存中</li>\n<li>关联对象存储在全局的统一的一个AssociationsManager中</li>\n<li>设置关联对象为nil，就相当于是移除关联对象</li>\n<li>实现关联对象技术的核心对象有\n<ul>\n<li>AssociationsManager</li>\n<li>AssociationsHashMap</li>\n<li>ObjectAssociationMap</li>\n<li>ObjcAssociation</li>\n</ul>\n</li>\n<li>objc4源码解读：<a href=\"http://objc-references.mm\" target=\"_blank\" rel=\"noopener\">objc-references.mm</a></li>\n</ul>\n<p>说明：通过一个<code>AssociationManager</code>的类来管理关联的对象，<code>AssociationManager</code>里面存放着一个<code>AssociationsHashMap</code>对象，里面以类似字典的形式来存放所关联的对象，及关联信息，所关联的对象作为key(disguised_ptr_t)，关联信息为值(ObjectAssociationMap)；<code>ObjectAssociationMap</code>又是以字典形式存放对应信息的：<code>const void *key</code>作为key，值即包装成了一个<code>ObjectAssociation</code>，里面存着：关联策略、关联的值。(如下图)</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016203113.png\" alt></p>\n"},{"title":"幽暗的岁月 自由的囚徒","catalog":true,"date":"2018-08-29T09:17:43.000Z","subtitle":null,"header-img":null,"_content":"# 幽暗的岁月  自由的囚徒\n岁月...，无处安放蒙尘的心。\n尘世烟花，太过绚丽，我本是尘埃，不愿刹那凋零。\n也许，岁月的尽头，阳光明媚，温暖永远；而世间，人情太冷，又何必苦苦寻觅一心一意的真！\n我故作潇洒，可最后却挣脱不了岁月的束缚。\n我开始相信，我是自由的囚徒，只是我不懂岁月给我的那些幽暗的日夜罢了。\n\n时常心情郁结：总是走不出岁月的故事设定，那些脱离不了世俗的情节，总是在七情六欲中-翻来覆去。于是，我想刻意绕过人生的某些路程，走到自己想要的地老天荒；看着别人的幸福与成长，偶尔也禁不住人生失败的忧伤。\n\n这些年，一味的逃避，想踏破世人的寻常人生，活出不一样的真我，但无奈....。\n一夜夜的沉思、一次次的人情，似乎明白，我所走过的岁月，不过是别人眼中的徘徊不前。\n\n有时，身处人海，迷失的感觉油然而生。我不喜欢人生的重叠和与覆盖，更不喜欢为。尽管我是一滴咸涩的海水，但我也生机盎然。那无尽的深邃天空，必将是我抛头洒血的疆场。我要策怀冲锋，用血肉之躯去填埋生命的疑惑。\n\n遥望岁月，清明若水；既看不清，也道不明，只是一去不复返的向东而流。我携手尘世悲欢，用虚假的笑容，演绎真情世界。所有的鲜花与掌声，都如岁月的灰屑，纷悄发间。\n\n我的梦，或许早被岁月镂空。\n\n","source":"_posts/幽暗的岁月-自由的囚徒.md","raw":"---\ntitle: 幽暗的岁月 自由的囚徒\ncatalog: true\ndate: 2018-08-29 17:17:43\nsubtitle:\nheader-img:\ntags:\n    - 生活随笔\n---\n# 幽暗的岁月  自由的囚徒\n岁月...，无处安放蒙尘的心。\n尘世烟花，太过绚丽，我本是尘埃，不愿刹那凋零。\n也许，岁月的尽头，阳光明媚，温暖永远；而世间，人情太冷，又何必苦苦寻觅一心一意的真！\n我故作潇洒，可最后却挣脱不了岁月的束缚。\n我开始相信，我是自由的囚徒，只是我不懂岁月给我的那些幽暗的日夜罢了。\n\n时常心情郁结：总是走不出岁月的故事设定，那些脱离不了世俗的情节，总是在七情六欲中-翻来覆去。于是，我想刻意绕过人生的某些路程，走到自己想要的地老天荒；看着别人的幸福与成长，偶尔也禁不住人生失败的忧伤。\n\n这些年，一味的逃避，想踏破世人的寻常人生，活出不一样的真我，但无奈....。\n一夜夜的沉思、一次次的人情，似乎明白，我所走过的岁月，不过是别人眼中的徘徊不前。\n\n有时，身处人海，迷失的感觉油然而生。我不喜欢人生的重叠和与覆盖，更不喜欢为。尽管我是一滴咸涩的海水，但我也生机盎然。那无尽的深邃天空，必将是我抛头洒血的疆场。我要策怀冲锋，用血肉之躯去填埋生命的疑惑。\n\n遥望岁月，清明若水；既看不清，也道不明，只是一去不复返的向东而流。我携手尘世悲欢，用虚假的笑容，演绎真情世界。所有的鲜花与掌声，都如岁月的灰屑，纷悄发间。\n\n我的梦，或许早被岁月镂空。\n\n","slug":"幽暗的岁月-自由的囚徒","published":1,"updated":"2018-08-29T09:34:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsh3gt4w000bncez85zgryaz","content":"<h1><span id=\"幽暗的岁月-自由的囚徒\">幽暗的岁月  自由的囚徒</span></h1>\n<p>岁月…，无处安放蒙尘的心。<br>\n尘世烟花，太过绚丽，我本是尘埃，不愿刹那凋零。<br>\n也许，岁月的尽头，阳光明媚，温暖永远；而世间，人情太冷，又何必苦苦寻觅一心一意的真！<br>\n我故作潇洒，可最后却挣脱不了岁月的束缚。<br>\n我开始相信，我是自由的囚徒，只是我不懂岁月给我的那些幽暗的日夜罢了。</p>\n<p>时常心情郁结：总是走不出岁月的故事设定，那些脱离不了世俗的情节，总是在七情六欲中-翻来覆去。于是，我想刻意绕过人生的某些路程，走到自己想要的地老天荒；看着别人的幸福与成长，偶尔也禁不住人生失败的忧伤。</p>\n<p>这些年，一味的逃避，想踏破世人的寻常人生，活出不一样的真我，但无奈…。<br>\n一夜夜的沉思、一次次的人情，似乎明白，我所走过的岁月，不过是别人眼中的徘徊不前。</p>\n<p>有时，身处人海，迷失的感觉油然而生。我不喜欢人生的重叠和与覆盖，更不喜欢为。尽管我是一滴咸涩的海水，但我也生机盎然。那无尽的深邃天空，必将是我抛头洒血的疆场。我要策怀冲锋，用血肉之躯去填埋生命的疑惑。</p>\n<p>遥望岁月，清明若水；既看不清，也道不明，只是一去不复返的向东而流。我携手尘世悲欢，用虚假的笑容，演绎真情世界。所有的鲜花与掌声，都如岁月的灰屑，纷悄发间。</p>\n<p>我的梦，或许早被岁月镂空。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>幽暗的岁月  自由的囚徒</h1>\n<p>岁月…，无处安放蒙尘的心。<br>\n尘世烟花，太过绚丽，我本是尘埃，不愿刹那凋零。<br>\n也许，岁月的尽头，阳光明媚，温暖永远；而世间，人情太冷，又何必苦苦寻觅一心一意的真！<br>\n我故作潇洒，可最后却挣脱不了岁月的束缚。<br>\n我开始相信，我是自由的囚徒，只是我不懂岁月给我的那些幽暗的日夜罢了。</p>\n<p>时常心情郁结：总是走不出岁月的故事设定，那些脱离不了世俗的情节，总是在七情六欲中-翻来覆去。于是，我想刻意绕过人生的某些路程，走到自己想要的地老天荒；看着别人的幸福与成长，偶尔也禁不住人生失败的忧伤。</p>\n<p>这些年，一味的逃避，想踏破世人的寻常人生，活出不一样的真我，但无奈…。<br>\n一夜夜的沉思、一次次的人情，似乎明白，我所走过的岁月，不过是别人眼中的徘徊不前。</p>\n<p>有时，身处人海，迷失的感觉油然而生。我不喜欢人生的重叠和与覆盖，更不喜欢为。尽管我是一滴咸涩的海水，但我也生机盎然。那无尽的深邃天空，必将是我抛头洒血的疆场。我要策怀冲锋，用血肉之躯去填埋生命的疑惑。</p>\n<p>遥望岁月，清明若水；既看不清，也道不明，只是一去不复返的向东而流。我携手尘世悲欢，用虚假的笑容，演绎真情世界。所有的鲜花与掌声，都如岁月的灰屑，纷悄发间。</p>\n<p>我的梦，或许早被岁月镂空。</p>\n"},{"title":"《这一年》滔滔逝水，急急流年","catalog":true,"date":"2018-08-29T09:26:16.000Z","subtitle":null,"header-img":null,"_content":"\n滔滔逝水，急急流年，几几个这一年弹指飞过，回首前尘，恍如一梦。\n这一年我们很小，我们有很多的差不多年龄的人一起无忧无虑的玩耍，再是一起在乡村上小学一直到上初中都可以不分开，\n \n这一年我们初中毕业，也是我们的一过分离点或许此时的我们还会考入同一学校，这一年的年尾我们都会回家，相隔半年的我们可以相聚，一起诉说自己第一次走出自己家乡的感觉、更有说不玩的趣事，待过年后正月初，又各奔西东.\n \n这一年手机或在这时便成了我们唯一的通信工具，这时我们有很多的时间聊天，说在久也不会觉没话题，每登陆QQ都会有许多的未读信息，还有我们有趣的视频聊天。这一年又将至年末，我们也会回家，回到家中我们都见面了，更多人说的第一句话是“你变了”，到底那时所说的你变了是什么变，其实就是变高了或变胖瘦或变黑变白变帅变美变开朗而已，这一句你变了就这么简单！\n \n这一年王子跟公主的故事开始在我们身上流传____我们恋爱了，我们很天真、很单纯，单纯的孤单变成了单纯的爱情。其实这一刻也是了解寂寞的开始。\n \n一年一年，我们都越来越少回家，也都有手机了，而我们通电话的次数、时间也随之变，而QQ上所发的信息远比手机上的信息要多。以前总想着自己毕业后要怎么努力的工作，要怎么风风光光的回家乡，或许轻轻松松的许下句诺言“要是不能怎么样我就不回家，直到怎样了再回家”到后面才知道自己许下的诺言是多么的沉重，它需要多大的决心，但自己知道当初能有这处想法，就定有这个坚强的毅力.\n \n这一年毕业了。\n \n这一年失恋了，懵懂的来，懵懂走！\n我们可以狠心的对自己，但我们无法摆脱家人的思念，每次电话中传的亲切、熟悉的声音，年末将到，家人知道你会有不想回家的想法，但他们会说“没事，我们希望你们在外能平平安安，刚出到外面，赚多少钱都不重要”这时听这句话感觉很自然。但这一年还是没回家。\n \n这一年对社会了解更多了，看到别人即便是一个小小的舞台，TA都能活得如此疯狂，而我像只沉默的羔羊。于是我也向往着另一种生活，后面才发现是那么的不知天高地厚。而这一年在电话里头的家人会说“重要的是能平平安安，钱呢！记得不要乱花就是了，能省就省点，但是吃的地方就要省了，今年要回家吧！都两年没回家了，家人也想你啊！”听了总是那么的心酸！所以回家了。每个人自己向往的生活，自己的梦想，联系也变得更少了，手机上都是你有时间我没时间，你没时间我有时间；而QQ上是：你我都知道我在隐身，你在暗处。其实这个时候我们已经变得惆怅，而这个时间的理由很简单，就是不想说话。\n这一年听到《遇见》，认定瞬间捕着了眼眸的你，从遇见、认识、了解、爱、相依偎、痴，over...再想不再想，谁是谁非，或许爱情里没有谁错谁对，只是还没来得及做好准备...所以注定它会被作废。又一次青春的过滤、淘汰纯真的旅行，那些路过的风景，有多少我们难以割舍的真情？看着一片片飘零的落叶，我来不及说些什么，想起身边的朋友，我们来不及说声“问候”，才发现如今的我丢了纯真的笑脸，我们就这样默默的成长着，都在为自己的目标奋斗、忙碌，联系也变少...慢慢的，慢慢的，我在想会不会到我们都忘记的那一天，生活也变得简单上班下下班睡觉；在这个时候更多的是音乐陪伴着我们，同时感伤也慢慢的侵蚀着我的生活，在语言中，变得更加安静，有许多话我们都知道不必多说，都懂的，该掩埋的掩埋了，该收藏的收藏了；留下更多的时间去深思。也不知道过了多久，我怎么会在这里，仿佛是昨天我还在想明天会怎样，然后那个昨天的明天却没有怎么样，只是丢失以往有的某份信任，我难以去相信出现在身边一切事物，以前相信嘴上说的都可以当真的；以前的以后不相嘴里所说的相信自己所看到的；以后的现在变得都不愿去相信，变得喜欢去揣测别人的心思，只相信自己；简单的也因此变得复杂,有的朋友说是你太悲观了，我也在思索这个问题，为什么我会变得悲观，是什么东西改变了我,更多的事情我们都不愿去承认，也不去否认，明明是别人说对的事情，只是一笑了之；甚至不愿去承认自己的感觉。\n没有勇气再去说些什么，有些话可能就这辈子都不会再那样的说出来，有些事也就不会那样轻易就去做。\n这一年，原来这一年我在这里\n其实我一直在这里，只是我也现在才知道我一直在这里。\n你知道世间最长的是什么东西吗?最短暂又是什么？其实都是时间，只是两种意义上不同的时间!\n滔滔逝水，急急流年，几几个这一年弹指飞过，回首前尘，恍如一梦。\n如何又如何！谁翻乐府凄凉曲？风也萧萧，雨也萧萧，瘦尽灯花又一宵.不知何事萦怀抱，醒也无聊，醉也无聊，梦也何曾到谢桥。 不是不知何事萦怀抱，而是知道也无能为力。解得开的就不叫心结，放得下的又怎会今生今世意难平？\n \n不久、不久后一阵阵寒流会让窝在被窉里不愿出来，原来又是一个冬季的到来，朋友时间过得很，有什么要做的就得抓紧了，一年又要过去了有些东西错过了可能就真的错过了；\n人生，有多少事多少情绪是说不清道不明的呢？而等你想去说明的时候，已经没有机会了？在珍惜和忽略得到与失去之间，人不断地辗转。","source":"_posts/《这一年》滔滔逝水，急急流年.md","raw":"---\ntitle: 《这一年》滔滔逝水，急急流年\ncatalog: true\ndate: 2018-08-29 17:26:16\nsubtitle:\nheader-img:\ntags:\n    - 生活随笔\n---\n\n滔滔逝水，急急流年，几几个这一年弹指飞过，回首前尘，恍如一梦。\n这一年我们很小，我们有很多的差不多年龄的人一起无忧无虑的玩耍，再是一起在乡村上小学一直到上初中都可以不分开，\n \n这一年我们初中毕业，也是我们的一过分离点或许此时的我们还会考入同一学校，这一年的年尾我们都会回家，相隔半年的我们可以相聚，一起诉说自己第一次走出自己家乡的感觉、更有说不玩的趣事，待过年后正月初，又各奔西东.\n \n这一年手机或在这时便成了我们唯一的通信工具，这时我们有很多的时间聊天，说在久也不会觉没话题，每登陆QQ都会有许多的未读信息，还有我们有趣的视频聊天。这一年又将至年末，我们也会回家，回到家中我们都见面了，更多人说的第一句话是“你变了”，到底那时所说的你变了是什么变，其实就是变高了或变胖瘦或变黑变白变帅变美变开朗而已，这一句你变了就这么简单！\n \n这一年王子跟公主的故事开始在我们身上流传____我们恋爱了，我们很天真、很单纯，单纯的孤单变成了单纯的爱情。其实这一刻也是了解寂寞的开始。\n \n一年一年，我们都越来越少回家，也都有手机了，而我们通电话的次数、时间也随之变，而QQ上所发的信息远比手机上的信息要多。以前总想着自己毕业后要怎么努力的工作，要怎么风风光光的回家乡，或许轻轻松松的许下句诺言“要是不能怎么样我就不回家，直到怎样了再回家”到后面才知道自己许下的诺言是多么的沉重，它需要多大的决心，但自己知道当初能有这处想法，就定有这个坚强的毅力.\n \n这一年毕业了。\n \n这一年失恋了，懵懂的来，懵懂走！\n我们可以狠心的对自己，但我们无法摆脱家人的思念，每次电话中传的亲切、熟悉的声音，年末将到，家人知道你会有不想回家的想法，但他们会说“没事，我们希望你们在外能平平安安，刚出到外面，赚多少钱都不重要”这时听这句话感觉很自然。但这一年还是没回家。\n \n这一年对社会了解更多了，看到别人即便是一个小小的舞台，TA都能活得如此疯狂，而我像只沉默的羔羊。于是我也向往着另一种生活，后面才发现是那么的不知天高地厚。而这一年在电话里头的家人会说“重要的是能平平安安，钱呢！记得不要乱花就是了，能省就省点，但是吃的地方就要省了，今年要回家吧！都两年没回家了，家人也想你啊！”听了总是那么的心酸！所以回家了。每个人自己向往的生活，自己的梦想，联系也变得更少了，手机上都是你有时间我没时间，你没时间我有时间；而QQ上是：你我都知道我在隐身，你在暗处。其实这个时候我们已经变得惆怅，而这个时间的理由很简单，就是不想说话。\n这一年听到《遇见》，认定瞬间捕着了眼眸的你，从遇见、认识、了解、爱、相依偎、痴，over...再想不再想，谁是谁非，或许爱情里没有谁错谁对，只是还没来得及做好准备...所以注定它会被作废。又一次青春的过滤、淘汰纯真的旅行，那些路过的风景，有多少我们难以割舍的真情？看着一片片飘零的落叶，我来不及说些什么，想起身边的朋友，我们来不及说声“问候”，才发现如今的我丢了纯真的笑脸，我们就这样默默的成长着，都在为自己的目标奋斗、忙碌，联系也变少...慢慢的，慢慢的，我在想会不会到我们都忘记的那一天，生活也变得简单上班下下班睡觉；在这个时候更多的是音乐陪伴着我们，同时感伤也慢慢的侵蚀着我的生活，在语言中，变得更加安静，有许多话我们都知道不必多说，都懂的，该掩埋的掩埋了，该收藏的收藏了；留下更多的时间去深思。也不知道过了多久，我怎么会在这里，仿佛是昨天我还在想明天会怎样，然后那个昨天的明天却没有怎么样，只是丢失以往有的某份信任，我难以去相信出现在身边一切事物，以前相信嘴上说的都可以当真的；以前的以后不相嘴里所说的相信自己所看到的；以后的现在变得都不愿去相信，变得喜欢去揣测别人的心思，只相信自己；简单的也因此变得复杂,有的朋友说是你太悲观了，我也在思索这个问题，为什么我会变得悲观，是什么东西改变了我,更多的事情我们都不愿去承认，也不去否认，明明是别人说对的事情，只是一笑了之；甚至不愿去承认自己的感觉。\n没有勇气再去说些什么，有些话可能就这辈子都不会再那样的说出来，有些事也就不会那样轻易就去做。\n这一年，原来这一年我在这里\n其实我一直在这里，只是我也现在才知道我一直在这里。\n你知道世间最长的是什么东西吗?最短暂又是什么？其实都是时间，只是两种意义上不同的时间!\n滔滔逝水，急急流年，几几个这一年弹指飞过，回首前尘，恍如一梦。\n如何又如何！谁翻乐府凄凉曲？风也萧萧，雨也萧萧，瘦尽灯花又一宵.不知何事萦怀抱，醒也无聊，醉也无聊，梦也何曾到谢桥。 不是不知何事萦怀抱，而是知道也无能为力。解得开的就不叫心结，放得下的又怎会今生今世意难平？\n \n不久、不久后一阵阵寒流会让窝在被窉里不愿出来，原来又是一个冬季的到来，朋友时间过得很，有什么要做的就得抓紧了，一年又要过去了有些东西错过了可能就真的错过了；\n人生，有多少事多少情绪是说不清道不明的呢？而等你想去说明的时候，已经没有机会了？在珍惜和忽略得到与失去之间，人不断地辗转。","slug":"《这一年》滔滔逝水，急急流年","published":1,"updated":"2018-08-29T09:34:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsh3gt4y000cnceza60kqreb","content":"<p>滔滔逝水，急急流年，几几个这一年弹指飞过，回首前尘，恍如一梦。<br>\n这一年我们很小，我们有很多的差不多年龄的人一起无忧无虑的玩耍，再是一起在乡村上小学一直到上初中都可以不分开，</p>\n<p>这一年我们初中毕业，也是我们的一过分离点或许此时的我们还会考入同一学校，这一年的年尾我们都会回家，相隔半年的我们可以相聚，一起诉说自己第一次走出自己家乡的感觉、更有说不玩的趣事，待过年后正月初，又各奔西东.</p>\n<p>这一年手机或在这时便成了我们唯一的通信工具，这时我们有很多的时间聊天，说在久也不会觉没话题，每登陆QQ都会有许多的未读信息，还有我们有趣的视频聊天。这一年又将至年末，我们也会回家，回到家中我们都见面了，更多人说的第一句话是“你变了”，到底那时所说的你变了是什么变，其实就是变高了或变胖瘦或变黑变白变帅变美变开朗而已，这一句你变了就这么简单！</p>\n<p>这一年王子跟公主的故事开始在我们身上流传____我们恋爱了，我们很天真、很单纯，单纯的孤单变成了单纯的爱情。其实这一刻也是了解寂寞的开始。</p>\n<p>一年一年，我们都越来越少回家，也都有手机了，而我们通电话的次数、时间也随之变，而QQ上所发的信息远比手机上的信息要多。以前总想着自己毕业后要怎么努力的工作，要怎么风风光光的回家乡，或许轻轻松松的许下句诺言“要是不能怎么样我就不回家，直到怎样了再回家”到后面才知道自己许下的诺言是多么的沉重，它需要多大的决心，但自己知道当初能有这处想法，就定有这个坚强的毅力.</p>\n<p>这一年毕业了。</p>\n<p>这一年失恋了，懵懂的来，懵懂走！<br>\n我们可以狠心的对自己，但我们无法摆脱家人的思念，每次电话中传的亲切、熟悉的声音，年末将到，家人知道你会有不想回家的想法，但他们会说“没事，我们希望你们在外能平平安安，刚出到外面，赚多少钱都不重要”这时听这句话感觉很自然。但这一年还是没回家。</p>\n<p>这一年对社会了解更多了，看到别人即便是一个小小的舞台，TA都能活得如此疯狂，而我像只沉默的羔羊。于是我也向往着另一种生活，后面才发现是那么的不知天高地厚。而这一年在电话里头的家人会说“重要的是能平平安安，钱呢！记得不要乱花就是了，能省就省点，但是吃的地方就要省了，今年要回家吧！都两年没回家了，家人也想你啊！”听了总是那么的心酸！所以回家了。每个人自己向往的生活，自己的梦想，联系也变得更少了，手机上都是你有时间我没时间，你没时间我有时间；而QQ上是：你我都知道我在隐身，你在暗处。其实这个时候我们已经变得惆怅，而这个时间的理由很简单，就是不想说话。<br>\n这一年听到《遇见》，认定瞬间捕着了眼眸的你，从遇见、认识、了解、爱、相依偎、痴，over…再想不再想，谁是谁非，或许爱情里没有谁错谁对，只是还没来得及做好准备…所以注定它会被作废。又一次青春的过滤、淘汰纯真的旅行，那些路过的风景，有多少我们难以割舍的真情？看着一片片飘零的落叶，我来不及说些什么，想起身边的朋友，我们来不及说声“问候”，才发现如今的我丢了纯真的笑脸，我们就这样默默的成长着，都在为自己的目标奋斗、忙碌，联系也变少…慢慢的，慢慢的，我在想会不会到我们都忘记的那一天，生活也变得简单上班下下班睡觉；在这个时候更多的是音乐陪伴着我们，同时感伤也慢慢的侵蚀着我的生活，在语言中，变得更加安静，有许多话我们都知道不必多说，都懂的，该掩埋的掩埋了，该收藏的收藏了；留下更多的时间去深思。也不知道过了多久，我怎么会在这里，仿佛是昨天我还在想明天会怎样，然后那个昨天的明天却没有怎么样，只是丢失以往有的某份信任，我难以去相信出现在身边一切事物，以前相信嘴上说的都可以当真的；以前的以后不相嘴里所说的相信自己所看到的；以后的现在变得都不愿去相信，变得喜欢去揣测别人的心思，只相信自己；简单的也因此变得复杂,有的朋友说是你太悲观了，我也在思索这个问题，为什么我会变得悲观，是什么东西改变了我,更多的事情我们都不愿去承认，也不去否认，明明是别人说对的事情，只是一笑了之；甚至不愿去承认自己的感觉。<br>\n没有勇气再去说些什么，有些话可能就这辈子都不会再那样的说出来，有些事也就不会那样轻易就去做。<br>\n这一年，原来这一年我在这里<br>\n其实我一直在这里，只是我也现在才知道我一直在这里。<br>\n你知道世间最长的是什么东西吗?最短暂又是什么？其实都是时间，只是两种意义上不同的时间!<br>\n滔滔逝水，急急流年，几几个这一年弹指飞过，回首前尘，恍如一梦。<br>\n如何又如何！谁翻乐府凄凉曲？风也萧萧，雨也萧萧，瘦尽灯花又一宵.不知何事萦怀抱，醒也无聊，醉也无聊，梦也何曾到谢桥。 不是不知何事萦怀抱，而是知道也无能为力。解得开的就不叫心结，放得下的又怎会今生今世意难平？</p>\n<p>不久、不久后一阵阵寒流会让窝在被窉里不愿出来，原来又是一个冬季的到来，朋友时间过得很，有什么要做的就得抓紧了，一年又要过去了有些东西错过了可能就真的错过了；<br>\n人生，有多少事多少情绪是说不清道不明的呢？而等你想去说明的时候，已经没有机会了？在珍惜和忽略得到与失去之间，人不断地辗转。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>滔滔逝水，急急流年，几几个这一年弹指飞过，回首前尘，恍如一梦。<br>\n这一年我们很小，我们有很多的差不多年龄的人一起无忧无虑的玩耍，再是一起在乡村上小学一直到上初中都可以不分开，</p>\n<p>这一年我们初中毕业，也是我们的一过分离点或许此时的我们还会考入同一学校，这一年的年尾我们都会回家，相隔半年的我们可以相聚，一起诉说自己第一次走出自己家乡的感觉、更有说不玩的趣事，待过年后正月初，又各奔西东.</p>\n<p>这一年手机或在这时便成了我们唯一的通信工具，这时我们有很多的时间聊天，说在久也不会觉没话题，每登陆QQ都会有许多的未读信息，还有我们有趣的视频聊天。这一年又将至年末，我们也会回家，回到家中我们都见面了，更多人说的第一句话是“你变了”，到底那时所说的你变了是什么变，其实就是变高了或变胖瘦或变黑变白变帅变美变开朗而已，这一句你变了就这么简单！</p>\n<p>这一年王子跟公主的故事开始在我们身上流传____我们恋爱了，我们很天真、很单纯，单纯的孤单变成了单纯的爱情。其实这一刻也是了解寂寞的开始。</p>\n<p>一年一年，我们都越来越少回家，也都有手机了，而我们通电话的次数、时间也随之变，而QQ上所发的信息远比手机上的信息要多。以前总想着自己毕业后要怎么努力的工作，要怎么风风光光的回家乡，或许轻轻松松的许下句诺言“要是不能怎么样我就不回家，直到怎样了再回家”到后面才知道自己许下的诺言是多么的沉重，它需要多大的决心，但自己知道当初能有这处想法，就定有这个坚强的毅力.</p>\n<p>这一年毕业了。</p>\n<p>这一年失恋了，懵懂的来，懵懂走！<br>\n我们可以狠心的对自己，但我们无法摆脱家人的思念，每次电话中传的亲切、熟悉的声音，年末将到，家人知道你会有不想回家的想法，但他们会说“没事，我们希望你们在外能平平安安，刚出到外面，赚多少钱都不重要”这时听这句话感觉很自然。但这一年还是没回家。</p>\n<p>这一年对社会了解更多了，看到别人即便是一个小小的舞台，TA都能活得如此疯狂，而我像只沉默的羔羊。于是我也向往着另一种生活，后面才发现是那么的不知天高地厚。而这一年在电话里头的家人会说“重要的是能平平安安，钱呢！记得不要乱花就是了，能省就省点，但是吃的地方就要省了，今年要回家吧！都两年没回家了，家人也想你啊！”听了总是那么的心酸！所以回家了。每个人自己向往的生活，自己的梦想，联系也变得更少了，手机上都是你有时间我没时间，你没时间我有时间；而QQ上是：你我都知道我在隐身，你在暗处。其实这个时候我们已经变得惆怅，而这个时间的理由很简单，就是不想说话。<br>\n这一年听到《遇见》，认定瞬间捕着了眼眸的你，从遇见、认识、了解、爱、相依偎、痴，over…再想不再想，谁是谁非，或许爱情里没有谁错谁对，只是还没来得及做好准备…所以注定它会被作废。又一次青春的过滤、淘汰纯真的旅行，那些路过的风景，有多少我们难以割舍的真情？看着一片片飘零的落叶，我来不及说些什么，想起身边的朋友，我们来不及说声“问候”，才发现如今的我丢了纯真的笑脸，我们就这样默默的成长着，都在为自己的目标奋斗、忙碌，联系也变少…慢慢的，慢慢的，我在想会不会到我们都忘记的那一天，生活也变得简单上班下下班睡觉；在这个时候更多的是音乐陪伴着我们，同时感伤也慢慢的侵蚀着我的生活，在语言中，变得更加安静，有许多话我们都知道不必多说，都懂的，该掩埋的掩埋了，该收藏的收藏了；留下更多的时间去深思。也不知道过了多久，我怎么会在这里，仿佛是昨天我还在想明天会怎样，然后那个昨天的明天却没有怎么样，只是丢失以往有的某份信任，我难以去相信出现在身边一切事物，以前相信嘴上说的都可以当真的；以前的以后不相嘴里所说的相信自己所看到的；以后的现在变得都不愿去相信，变得喜欢去揣测别人的心思，只相信自己；简单的也因此变得复杂,有的朋友说是你太悲观了，我也在思索这个问题，为什么我会变得悲观，是什么东西改变了我,更多的事情我们都不愿去承认，也不去否认，明明是别人说对的事情，只是一笑了之；甚至不愿去承认自己的感觉。<br>\n没有勇气再去说些什么，有些话可能就这辈子都不会再那样的说出来，有些事也就不会那样轻易就去做。<br>\n这一年，原来这一年我在这里<br>\n其实我一直在这里，只是我也现在才知道我一直在这里。<br>\n你知道世间最长的是什么东西吗?最短暂又是什么？其实都是时间，只是两种意义上不同的时间!<br>\n滔滔逝水，急急流年，几几个这一年弹指飞过，回首前尘，恍如一梦。<br>\n如何又如何！谁翻乐府凄凉曲？风也萧萧，雨也萧萧，瘦尽灯花又一宵.不知何事萦怀抱，醒也无聊，醉也无聊，梦也何曾到谢桥。 不是不知何事萦怀抱，而是知道也无能为力。解得开的就不叫心结，放得下的又怎会今生今世意难平？</p>\n<p>不久、不久后一阵阵寒流会让窝在被窉里不愿出来，原来又是一个冬季的到来，朋友时间过得很，有什么要做的就得抓紧了，一年又要过去了有些东西错过了可能就真的错过了；<br>\n人生，有多少事多少情绪是说不清道不明的呢？而等你想去说明的时候，已经没有机会了？在珍惜和忽略得到与失去之间，人不断地辗转。</p>\n"},{"title":"最后一支烟","catalog":true,"date":"2018-08-29T09:28:22.000Z","subtitle":null,"header-img":"psb.jpeg","_content":"再美的文字也及不过,你的一句的安慰；\n再漂亮的花朵,也不及你甜蜜的笑容；\n再寒冷的冬天,但却怎么也冻结不了你温暖的拥抱；\n今生最大的收获,不是我得到多少名或利,而是让我遇见了你；\n都希望时光倒流,我却不希望,因为我害怕时光倒流了我们就不能相遇；\n最大的幸福不是我永恒的拥有多少,而是能与你厮守终生；\n\n最伤心的事莫过于,看着自己心爱的人受委屈却给不了半点安慰；\n最遥远的距离莫过于,天涯海角而是我爱你,却只能默默的看着你；\n最大的失望不是你的一句对不起,而是我给的你都不要,那怕是我为了让你开心给的个牵强的笑容；\n最孤单时不是电影散了场,而是当你从我身协定经过,留下你的余味；\n最痛苦的是谈谈的余味也瞬间的随风飘逝,种下了我的愚昧；\n最美的画面不是我怎么遇见你,而是在我失落、伤心时，有你在我身过对我说“不管怎么样，还有我陪着你”；\n最寂寞的地方不是天堂、不是地狱，而是没有你的世界；\n最真诚的一句话不是在自我介绍时告诉大家我的名字而是我简单的一句“我一直都会在你身边”；\n 可再火热的夏天也溶化不了你的冷落；\n \n你动或不动，我都在这里一动不动；你看或都不看，我都在这里一心期盼；\n玫瑰固然艳丽迷人，但它却很容易凋谢，而我说像那寒冬的梅花，不管季节是风是雨还是霜雪夹杂，是多么的寒冷，我也死死为你站岗，只望用我有限的生命来为你绽放出最美的花朵，去摆托你的孤单，用我的生命来鼓舞你的脆弱；你若对我视而不见，我将陪随着寒冬一起消逝、枯萎；希望你能靠近一点，走进你温暖的怀抱来驱赶我的寒伤，我将为此点缀我们的激情，绽放更感人的花儿，直到满山遍野，任你走到天涯海角都不再觉得孤单、寂寞，也会是我无悔的人生。\n \n 懂与不懂，其实自己都懂，只是有更多时候在装不懂，因为我知道不先学会骗自己那有经验去骗别人。\n如果，如果我因此失去了最初的勇气，我又该怎么前行；\n \n窗外弥红的灯火，\n来来往往的人影，\n独自走在彷徨的街头，\n哀莫过于心死。","source":"_posts/最后一支烟.md","raw":"---\ntitle: 最后一支烟\ncatalog: true\ndate: 2018-08-29 17:28:22\nsubtitle:\nheader-img: psb.jpeg\ntags:\n    - 生活随笔\n---\n再美的文字也及不过,你的一句的安慰；\n再漂亮的花朵,也不及你甜蜜的笑容；\n再寒冷的冬天,但却怎么也冻结不了你温暖的拥抱；\n今生最大的收获,不是我得到多少名或利,而是让我遇见了你；\n都希望时光倒流,我却不希望,因为我害怕时光倒流了我们就不能相遇；\n最大的幸福不是我永恒的拥有多少,而是能与你厮守终生；\n\n最伤心的事莫过于,看着自己心爱的人受委屈却给不了半点安慰；\n最遥远的距离莫过于,天涯海角而是我爱你,却只能默默的看着你；\n最大的失望不是你的一句对不起,而是我给的你都不要,那怕是我为了让你开心给的个牵强的笑容；\n最孤单时不是电影散了场,而是当你从我身协定经过,留下你的余味；\n最痛苦的是谈谈的余味也瞬间的随风飘逝,种下了我的愚昧；\n最美的画面不是我怎么遇见你,而是在我失落、伤心时，有你在我身过对我说“不管怎么样，还有我陪着你”；\n最寂寞的地方不是天堂、不是地狱，而是没有你的世界；\n最真诚的一句话不是在自我介绍时告诉大家我的名字而是我简单的一句“我一直都会在你身边”；\n 可再火热的夏天也溶化不了你的冷落；\n \n你动或不动，我都在这里一动不动；你看或都不看，我都在这里一心期盼；\n玫瑰固然艳丽迷人，但它却很容易凋谢，而我说像那寒冬的梅花，不管季节是风是雨还是霜雪夹杂，是多么的寒冷，我也死死为你站岗，只望用我有限的生命来为你绽放出最美的花朵，去摆托你的孤单，用我的生命来鼓舞你的脆弱；你若对我视而不见，我将陪随着寒冬一起消逝、枯萎；希望你能靠近一点，走进你温暖的怀抱来驱赶我的寒伤，我将为此点缀我们的激情，绽放更感人的花儿，直到满山遍野，任你走到天涯海角都不再觉得孤单、寂寞，也会是我无悔的人生。\n \n 懂与不懂，其实自己都懂，只是有更多时候在装不懂，因为我知道不先学会骗自己那有经验去骗别人。\n如果，如果我因此失去了最初的勇气，我又该怎么前行；\n \n窗外弥红的灯火，\n来来往往的人影，\n独自走在彷徨的街头，\n哀莫过于心死。","slug":"最后一支烟","published":1,"updated":"2018-08-29T09:34:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsh3gt54000encezmmi1qhgx","content":"<p>再美的文字也及不过,你的一句的安慰；<br>\n再漂亮的花朵,也不及你甜蜜的笑容；<br>\n再寒冷的冬天,但却怎么也冻结不了你温暖的拥抱；<br>\n今生最大的收获,不是我得到多少名或利,而是让我遇见了你；<br>\n都希望时光倒流,我却不希望,因为我害怕时光倒流了我们就不能相遇；<br>\n最大的幸福不是我永恒的拥有多少,而是能与你厮守终生；</p>\n<p>最伤心的事莫过于,看着自己心爱的人受委屈却给不了半点安慰；<br>\n最遥远的距离莫过于,天涯海角而是我爱你,却只能默默的看着你；<br>\n最大的失望不是你的一句对不起,而是我给的你都不要,那怕是我为了让你开心给的个牵强的笑容；<br>\n最孤单时不是电影散了场,而是当你从我身协定经过,留下你的余味；<br>\n最痛苦的是谈谈的余味也瞬间的随风飘逝,种下了我的愚昧；<br>\n最美的画面不是我怎么遇见你,而是在我失落、伤心时，有你在我身过对我说“不管怎么样，还有我陪着你”；<br>\n最寂寞的地方不是天堂、不是地狱，而是没有你的世界；<br>\n最真诚的一句话不是在自我介绍时告诉大家我的名字而是我简单的一句“我一直都会在你身边”；<br>\n可再火热的夏天也溶化不了你的冷落；</p>\n<p>你动或不动，我都在这里一动不动；你看或都不看，我都在这里一心期盼；<br>\n玫瑰固然艳丽迷人，但它却很容易凋谢，而我说像那寒冬的梅花，不管季节是风是雨还是霜雪夹杂，是多么的寒冷，我也死死为你站岗，只望用我有限的生命来为你绽放出最美的花朵，去摆托你的孤单，用我的生命来鼓舞你的脆弱；你若对我视而不见，我将陪随着寒冬一起消逝、枯萎；希望你能靠近一点，走进你温暖的怀抱来驱赶我的寒伤，我将为此点缀我们的激情，绽放更感人的花儿，直到满山遍野，任你走到天涯海角都不再觉得孤单、寂寞，也会是我无悔的人生。</p>\n<p>懂与不懂，其实自己都懂，只是有更多时候在装不懂，因为我知道不先学会骗自己那有经验去骗别人。<br>\n如果，如果我因此失去了最初的勇气，我又该怎么前行；</p>\n<p>窗外弥红的灯火，<br>\n来来往往的人影，<br>\n独自走在彷徨的街头，<br>\n哀莫过于心死。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>再美的文字也及不过,你的一句的安慰；<br>\n再漂亮的花朵,也不及你甜蜜的笑容；<br>\n再寒冷的冬天,但却怎么也冻结不了你温暖的拥抱；<br>\n今生最大的收获,不是我得到多少名或利,而是让我遇见了你；<br>\n都希望时光倒流,我却不希望,因为我害怕时光倒流了我们就不能相遇；<br>\n最大的幸福不是我永恒的拥有多少,而是能与你厮守终生；</p>\n<p>最伤心的事莫过于,看着自己心爱的人受委屈却给不了半点安慰；<br>\n最遥远的距离莫过于,天涯海角而是我爱你,却只能默默的看着你；<br>\n最大的失望不是你的一句对不起,而是我给的你都不要,那怕是我为了让你开心给的个牵强的笑容；<br>\n最孤单时不是电影散了场,而是当你从我身协定经过,留下你的余味；<br>\n最痛苦的是谈谈的余味也瞬间的随风飘逝,种下了我的愚昧；<br>\n最美的画面不是我怎么遇见你,而是在我失落、伤心时，有你在我身过对我说“不管怎么样，还有我陪着你”；<br>\n最寂寞的地方不是天堂、不是地狱，而是没有你的世界；<br>\n最真诚的一句话不是在自我介绍时告诉大家我的名字而是我简单的一句“我一直都会在你身边”；<br>\n可再火热的夏天也溶化不了你的冷落；</p>\n<p>你动或不动，我都在这里一动不动；你看或都不看，我都在这里一心期盼；<br>\n玫瑰固然艳丽迷人，但它却很容易凋谢，而我说像那寒冬的梅花，不管季节是风是雨还是霜雪夹杂，是多么的寒冷，我也死死为你站岗，只望用我有限的生命来为你绽放出最美的花朵，去摆托你的孤单，用我的生命来鼓舞你的脆弱；你若对我视而不见，我将陪随着寒冬一起消逝、枯萎；希望你能靠近一点，走进你温暖的怀抱来驱赶我的寒伤，我将为此点缀我们的激情，绽放更感人的花儿，直到满山遍野，任你走到天涯海角都不再觉得孤单、寂寞，也会是我无悔的人生。</p>\n<p>懂与不懂，其实自己都懂，只是有更多时候在装不懂，因为我知道不先学会骗自己那有经验去骗别人。<br>\n如果，如果我因此失去了最初的勇气，我又该怎么前行；</p>\n<p>窗外弥红的灯火，<br>\n来来往往的人影，<br>\n独自走在彷徨的街头，<br>\n哀莫过于心死。</p>\n"},{"title":"王者人生 人生王者","catalog":true,"date":"2018-08-29T09:16:03.000Z","subtitle":null,"header-img":null,"_content":"王者人生，人生王者：\n\n人生就像是王者榮耀，起跑線一樣，初期沒有發育好，又剛好連串的聽到：an ally has been slain，心裡就覺得起不來了，要輸了，士氣變得低落⋯⋯\n又或者在你覺得起不來要輸了的時候，又剛好隊友連串的帶來此類音訊：double kill, triple kill, quadra kill, penta kill ，於是你士氣高昂 > shut down","source":"_posts/王者人生-人生王者.md","raw":"---\ntitle: 王者人生 人生王者\ncatalog: true\ndate: 2018-08-29 17:16:03\nsubtitle:\nheader-img:\ntags:\n    - 生活随笔\n---\n王者人生，人生王者：\n\n人生就像是王者榮耀，起跑線一樣，初期沒有發育好，又剛好連串的聽到：an ally has been slain，心裡就覺得起不來了，要輸了，士氣變得低落⋯⋯\n又或者在你覺得起不來要輸了的時候，又剛好隊友連串的帶來此類音訊：double kill, triple kill, quadra kill, penta kill ，於是你士氣高昂 > shut down","slug":"王者人生-人生王者","published":1,"updated":"2018-08-29T09:34:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsh3gt57000gnceza0maoszw","content":"<p>王者人生，人生王者：</p>\n<p>人生就像是王者榮耀，起跑線一樣，初期沒有發育好，又剛好連串的聽到：an ally has been slain，心裡就覺得起不來了，要輸了，士氣變得低落⋯⋯<br>\n又或者在你覺得起不來要輸了的時候，又剛好隊友連串的帶來此類音訊：double kill, triple kill, quadra kill, penta kill ，於是你士氣高昂 &gt; shut down</p>\n","site":{"data":{}},"excerpt":"","more":"<p>王者人生，人生王者：</p>\n<p>人生就像是王者榮耀，起跑線一樣，初期沒有發育好，又剛好連串的聽到：an ally has been slain，心裡就覺得起不來了，要輸了，士氣變得低落⋯⋯<br>\n又或者在你覺得起不來要輸了的時候，又剛好隊友連串的帶來此類音訊：double kill, triple kill, quadra kill, penta kill ，於是你士氣高昂 &gt; shut down</p>\n"},{"title":"第十九支烟","catalog":true,"date":"2018-08-29T09:27:53.000Z","subtitle":null,"header-img":null,"_content":"坐在电脑前发呆,却怎么也写不清对生活的对白\n蓦然回首才发现时间过得很快\n不知不觉就在这混了一年多了\n不知不觉中发现认识你、认识你们已经很久了；\n其中有我想过的不想过的生活，它都还是过去了\n甚至没有留下任何证据给我,让我记得曾经做过什么,唯一的是让岁月留给下感伤,\n或许是失败时的落寞,\n或许是成功时站在高处的寒冷,\n或许是寂寞时的失落\n或是某一个缺少勇气的遗憾\n每一件事情，你认为TA是怎么样的，TA就是怎么样的\n每一个新的一天，可能是晴天、雨天、阴天还是烦闷的，它就好比人的心情\n虽然它会影响到我的心情，但最终我还得带着不一样的表情去生活\n或许影响你生活的并不是那个善变的天，只不过是取物拟人罢了\n并告诉自己要努力生活，这将是一个新的开始定下新的愿望\n有实现的，有没实现，有无动于衷的，还有一个就是那一直不变的心愿也不知它属于那种\n就那样悬挂着没个着落，原来已超负和，跌跌撞撞才明白了许多\n仅仅只是明白而已，心地下还是不停和它拉扯；\n\n好几年前的一首的歌，会唱的的不会唱的都跟着哼“我爱你，爱得死心蹋地，奋不顾身为你献出自己...心甘情愿跳进了你爱的陷阱,哪怕为此而丢了性命.....”也少不了一份执著“请不要离开我，在这下雨的时候，请不要离开我，当我独自喝醉在街头，请不要离开我，绝不放开你的手，哭的时候让泪往心里流”在时光中走失才发现“一眼万年”到现在唯一留下的却那两者遗留下来的《痴心绝对》：\n当我把它送给你时——痴的是情\n当我把它送自己时——痴的是梦\n当我把它送大家时——痴的是我对自己绝对想法的信念\n它们密切相连，相互支撑着，缺一不可，我也找不着中心点\n你曾说过二年，我说等!\n有时想想自己也挺厉害的，这么多年什么脸没丢过？竟然还有这勇气平稳的立在这世界上，还有影子呢!\n有时疯巅的笑，自己都不知道自己在笑什么，或许是笑他人的狼狈，还是笑自己的落魄，也许是洒脱的一个脸部动作；\n有时真觉得自己真有点傻，反应都迟钝，迟钝到不知该对你说些什么，迟钝到只剩句有关爱你的话语。\n写了这么多，或许你也不知道我想说什么，其实这里的每一句它都可以是独立的不相关联的，也可以是句句相连的.....\n当我写完这文章时，才发现二十支烟已点完十九支，剩一最后那一只我给它取名为遗留下的中“对”，因为我缺少一份答案是对还是错!\n","source":"_posts/第十九支烟.md","raw":"---\ntitle: 第十九支烟\ncatalog: true\ndate: 2018-08-29 17:27:53\nsubtitle:\nheader-img:\ntags:\n    - 生活随笔\n---\n坐在电脑前发呆,却怎么也写不清对生活的对白\n蓦然回首才发现时间过得很快\n不知不觉就在这混了一年多了\n不知不觉中发现认识你、认识你们已经很久了；\n其中有我想过的不想过的生活，它都还是过去了\n甚至没有留下任何证据给我,让我记得曾经做过什么,唯一的是让岁月留给下感伤,\n或许是失败时的落寞,\n或许是成功时站在高处的寒冷,\n或许是寂寞时的失落\n或是某一个缺少勇气的遗憾\n每一件事情，你认为TA是怎么样的，TA就是怎么样的\n每一个新的一天，可能是晴天、雨天、阴天还是烦闷的，它就好比人的心情\n虽然它会影响到我的心情，但最终我还得带着不一样的表情去生活\n或许影响你生活的并不是那个善变的天，只不过是取物拟人罢了\n并告诉自己要努力生活，这将是一个新的开始定下新的愿望\n有实现的，有没实现，有无动于衷的，还有一个就是那一直不变的心愿也不知它属于那种\n就那样悬挂着没个着落，原来已超负和，跌跌撞撞才明白了许多\n仅仅只是明白而已，心地下还是不停和它拉扯；\n\n好几年前的一首的歌，会唱的的不会唱的都跟着哼“我爱你，爱得死心蹋地，奋不顾身为你献出自己...心甘情愿跳进了你爱的陷阱,哪怕为此而丢了性命.....”也少不了一份执著“请不要离开我，在这下雨的时候，请不要离开我，当我独自喝醉在街头，请不要离开我，绝不放开你的手，哭的时候让泪往心里流”在时光中走失才发现“一眼万年”到现在唯一留下的却那两者遗留下来的《痴心绝对》：\n当我把它送给你时——痴的是情\n当我把它送自己时——痴的是梦\n当我把它送大家时——痴的是我对自己绝对想法的信念\n它们密切相连，相互支撑着，缺一不可，我也找不着中心点\n你曾说过二年，我说等!\n有时想想自己也挺厉害的，这么多年什么脸没丢过？竟然还有这勇气平稳的立在这世界上，还有影子呢!\n有时疯巅的笑，自己都不知道自己在笑什么，或许是笑他人的狼狈，还是笑自己的落魄，也许是洒脱的一个脸部动作；\n有时真觉得自己真有点傻，反应都迟钝，迟钝到不知该对你说些什么，迟钝到只剩句有关爱你的话语。\n写了这么多，或许你也不知道我想说什么，其实这里的每一句它都可以是独立的不相关联的，也可以是句句相连的.....\n当我写完这文章时，才发现二十支烟已点完十九支，剩一最后那一只我给它取名为遗留下的中“对”，因为我缺少一份答案是对还是错!\n","slug":"第十九支烟","published":1,"updated":"2018-10-08T13:49:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsh3gt5f000jncezaz2hb2ta","content":"<p>坐在电脑前发呆,却怎么也写不清对生活的对白<br>\n蓦然回首才发现时间过得很快<br>\n不知不觉就在这混了一年多了<br>\n不知不觉中发现认识你、认识你们已经很久了；<br>\n其中有我想过的不想过的生活，它都还是过去了<br>\n甚至没有留下任何证据给我,让我记得曾经做过什么,唯一的是让岁月留给下感伤,<br>\n或许是失败时的落寞,<br>\n或许是成功时站在高处的寒冷,<br>\n或许是寂寞时的失落<br>\n或是某一个缺少勇气的遗憾<br>\n每一件事情，你认为TA是怎么样的，TA就是怎么样的<br>\n每一个新的一天，可能是晴天、雨天、阴天还是烦闷的，它就好比人的心情<br>\n虽然它会影响到我的心情，但最终我还得带着不一样的表情去生活<br>\n或许影响你生活的并不是那个善变的天，只不过是取物拟人罢了<br>\n并告诉自己要努力生活，这将是一个新的开始定下新的愿望<br>\n有实现的，有没实现，有无动于衷的，还有一个就是那一直不变的心愿也不知它属于那种<br>\n就那样悬挂着没个着落，原来已超负和，跌跌撞撞才明白了许多<br>\n仅仅只是明白而已，心地下还是不停和它拉扯；</p>\n<p>好几年前的一首的歌，会唱的的不会唱的都跟着哼“我爱你，爱得死心蹋地，奋不顾身为你献出自己…心甘情愿跳进了你爱的陷阱,哪怕为此而丢了性命…”也少不了一份执著“请不要离开我，在这下雨的时候，请不要离开我，当我独自喝醉在街头，请不要离开我，绝不放开你的手，哭的时候让泪往心里流”在时光中走失才发现“一眼万年”到现在唯一留下的却那两者遗留下来的《痴心绝对》：<br>\n当我把它送给你时——痴的是情<br>\n当我把它送自己时——痴的是梦<br>\n当我把它送大家时——痴的是我对自己绝对想法的信念<br>\n它们密切相连，相互支撑着，缺一不可，我也找不着中心点<br>\n你曾说过二年，我说等!<br>\n有时想想自己也挺厉害的，这么多年什么脸没丢过？竟然还有这勇气平稳的立在这世界上，还有影子呢!<br>\n有时疯巅的笑，自己都不知道自己在笑什么，或许是笑他人的狼狈，还是笑自己的落魄，也许是洒脱的一个脸部动作；<br>\n有时真觉得自己真有点傻，反应都迟钝，迟钝到不知该对你说些什么，迟钝到只剩句有关爱你的话语。<br>\n写了这么多，或许你也不知道我想说什么，其实这里的每一句它都可以是独立的不相关联的，也可以是句句相连的…<br>\n当我写完这文章时，才发现二十支烟已点完十九支，剩一最后那一只我给它取名为遗留下的中“对”，因为我缺少一份答案是对还是错!</p>\n","site":{"data":{}},"excerpt":"","more":"<p>坐在电脑前发呆,却怎么也写不清对生活的对白<br>\n蓦然回首才发现时间过得很快<br>\n不知不觉就在这混了一年多了<br>\n不知不觉中发现认识你、认识你们已经很久了；<br>\n其中有我想过的不想过的生活，它都还是过去了<br>\n甚至没有留下任何证据给我,让我记得曾经做过什么,唯一的是让岁月留给下感伤,<br>\n或许是失败时的落寞,<br>\n或许是成功时站在高处的寒冷,<br>\n或许是寂寞时的失落<br>\n或是某一个缺少勇气的遗憾<br>\n每一件事情，你认为TA是怎么样的，TA就是怎么样的<br>\n每一个新的一天，可能是晴天、雨天、阴天还是烦闷的，它就好比人的心情<br>\n虽然它会影响到我的心情，但最终我还得带着不一样的表情去生活<br>\n或许影响你生活的并不是那个善变的天，只不过是取物拟人罢了<br>\n并告诉自己要努力生活，这将是一个新的开始定下新的愿望<br>\n有实现的，有没实现，有无动于衷的，还有一个就是那一直不变的心愿也不知它属于那种<br>\n就那样悬挂着没个着落，原来已超负和，跌跌撞撞才明白了许多<br>\n仅仅只是明白而已，心地下还是不停和它拉扯；</p>\n<p>好几年前的一首的歌，会唱的的不会唱的都跟着哼“我爱你，爱得死心蹋地，奋不顾身为你献出自己…心甘情愿跳进了你爱的陷阱,哪怕为此而丢了性命…”也少不了一份执著“请不要离开我，在这下雨的时候，请不要离开我，当我独自喝醉在街头，请不要离开我，绝不放开你的手，哭的时候让泪往心里流”在时光中走失才发现“一眼万年”到现在唯一留下的却那两者遗留下来的《痴心绝对》：<br>\n当我把它送给你时——痴的是情<br>\n当我把它送自己时——痴的是梦<br>\n当我把它送大家时——痴的是我对自己绝对想法的信念<br>\n它们密切相连，相互支撑着，缺一不可，我也找不着中心点<br>\n你曾说过二年，我说等!<br>\n有时想想自己也挺厉害的，这么多年什么脸没丢过？竟然还有这勇气平稳的立在这世界上，还有影子呢!<br>\n有时疯巅的笑，自己都不知道自己在笑什么，或许是笑他人的狼狈，还是笑自己的落魄，也许是洒脱的一个脸部动作；<br>\n有时真觉得自己真有点傻，反应都迟钝，迟钝到不知该对你说些什么，迟钝到只剩句有关爱你的话语。<br>\n写了这么多，或许你也不知道我想说什么，其实这里的每一句它都可以是独立的不相关联的，也可以是句句相连的…<br>\n当我写完这文章时，才发现二十支烟已点完十九支，剩一最后那一只我给它取名为遗留下的中“对”，因为我缺少一份答案是对还是错!</p>\n"},{"title":"穿越318线川藏游记","catalog":true,"date":"2018-09-22T12:40:28.000Z","subtitle":"一路向西","header-img":"1677ziyouxing.png","catagories":["Stuio"],"_content":"​        那天一个小心，从朋友那听说将要进行川藏之旅，之前因为时间的关系一直没去成，这一次不顾一切；西藏是我一直向往的地方，在我的心中是一块神圣土地，是不可替代的，那里有蔚蓝、安静的天空、纯朴的人民；我曾想第一次去西藏一定要带我所爱之人一起去，但所爱之人( )，有些事还得去做，就类似那首歌里面唱的一样：“一个人完成两个人的梦想”；好了，言归正传吧！\n\n\n\n​        我们是从成都出发的，今年的第一次远行，从深圳出发至成都，早上4点起来赶飞机，在行程的前一天到达成都，主要是为了翻越下成都的美食。\n\n\n\n​        今天9月03号，我们出发了，天空飘着雨，不大不小，刚好够洗刷一座城、一颗心，应该是老天想把西藏在我见到之前再洗漱一次，让我见到更美丽、纯洁的它。\n\n\n\n   *人生一定得去一次西藏*\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0043.JPG)\n\n​        **第一站：海螺沟**\n\n   诗说：那一刻 我升起风马，不为乞福只为守候你的到来；那一世 转山转水转佛塔，不为修来世只为途中与你相见——我们相约海螺沟；柏油路，一路很胜利，天气也很好。\n\n   海螺沟位于四川省泸定县磨西镇，贡嘎山东坡，是青藏高原东缘的极高山地。位于贡嘎雪峰脚下，以低海拔现代冰川著称于世，海拔2850米。\n\n![](http://pbflin9sq.bkt.clouddn.com/20180922134303.png)\n\n![](http://pbflin9sq.bkt.clouddn.com/timg-2.jpeg)\n\n海螺沟磨西镇：他是一个有着历史韵味的小镇，一个个酒吧，一条条石板路，都像是在诉说着属于他自己的故事。\n\n![](http://pbflin9sq.bkt.clouddn.com/20180612105916.jpg)\n\n\n\n**色达**\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0280.JPG)\n\n牛群\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0116.JPG)\n\n在色达的美女\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0129.JPG)\n\n牛气冲天\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0134.JPG)\n\n夜晚的色达\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0225.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0224.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0242.JPG)\n\n\n\n最可爱土拨鼠\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0111.JPG)\n\n格桑花\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0273.JPG)\n\n秃鹫\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0100.JPG)\n\n天葬台\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0094-2.JPG)\n\n\n\n\n   **第二站：稻城亚丁**\n\n   亚丁，藏语意为“向阳之地”；被誉为“水蓝色星球上的最后一片净土”，这里有雪山、冰川、峡谷、森林、草甸、湖泊、金矿及纯净的空气。\n\n   位于四川省[甘孜藏族自治州]稻城县[香格里拉镇]亚丁村境内；保护区内的三座雪山：仙乃日、央迈勇、夏诺多吉，呈品字形排列，统称“念青贡嘎日松贡布”，意为：终年积雪不化的三座护法神山圣地。藏传佛教中称其为“三怙主雪山”，是藏民心中的神圣之地。\n\n   7:30到了景点门票区(香格里拉镇)，很好有自助买票的机器，去得比较早基本不用排队，建议还是早点(8点之前到达)去，买票后先是坐1个小时左右的景车到达景点1(扎灌崩)，再坐车或者徒步到烙绒牛场(6.7km)，去景点的路都是围绕着山跑，从海拔2900升到4700，至于高原反应，你不要太紧张，不要去想它，我们一车的人都没感觉，一路穿梭在云里雾里的感觉，心旷神怡！到达山脚下后，开始徒步上山，全程6公里左右，最高海拔4700；\n\n   我们一路拍照一路前行，为了爬上去看《牛奶海》、《五色海》及为了体验下海拔四千七的感觉，不巧的是这一天在我们爬了5公里左右的时候下大雨了，持续了有半小时左右，没有带伞，带的是雨衣，鞋子、裤脚全湿了；女同胞怕冻感冒，山路加上下雨比较滑，安全送达到山下后，到达景区的返程乘车点大概是14:30；\n\n   心不死，爱还在，我要爬到终点看《牛奶海》、《五色海》，预估下时间：最晚的一趟返程车是18点，体力没有问题，不管怎样必须爬上去，心意已决，睡在山上也要上；黄天不有心人，出太阳了，看到了雨后和阳光中的《牛奶海》、《五色海》。不过结果是17：30到达了返程的乘车点。\n\n离顶峰只有“一步”之逍了，给自己多点动力，其实还挺远的，上去再绕下去就是《五色海》，左边前行1公里左右就是《牛奶海》\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1139.JPG)\n\n牛奶海\n\n![牛奶海](http://pbflin9sq.bkt.clouddn.com/DSC_1080.JPG)\n\n五色海\n\n![五色海](http://pbflin9sq.bkt.clouddn.com/DSC_1100.JPG)\n\n都说：*爱Ta，恨Ta，一定在带Ta上亚丁*\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0397.JPG)\n\n\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1249.JPG)\n\n小溪\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1044.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1151.JPG)\n\n冰川\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1230.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1068.JPG)\n\n嗨\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0928.JPG)\n\n\n\n**稻城至拉萨的沿途**\n\n天路十八弯\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0719.JPG)\n\n藏文石经\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0686.JPG)\n\n舒畅与放肆\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0652.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0279.JPG)\n\n西藏界：金沙江\n\n![](http://pbflin9sq.bkt.clouddn.com/19B17524966F860AF9642C5404EBCF35.jpg)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0424.JPG)\n\n野炊之泡面大杂烩\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0441.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0442.JPG)\n\n**第三站：拉萨**\n中国西藏自治区的首府，具有高原和民族特色的国际旅游城市  ，是西藏的政治、经济、文化和科教中心，也是藏传佛教圣地；以风光秀丽、历史悠久、风俗民情独特、宗教色彩浓厚而闻名于世，海拔3650米。\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0830.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0888.JPG)\n拉萨，我来了\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0582.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0586.JPG)\n\n邂逅最美彩虹\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0560.JPG)\n\n金马演义圈，不错有联欢晚会的感觉\n\n![](http://pbflin9sq.bkt.clouddn.com/AA292FAB86964F674893464F40553FF7.jpg)\n\n**一路美食相伴**\n\n青棵牛肉面\n\n![](http://pbflin9sq.bkt.clouddn.com/20180922185705.png)\n\n酸奶\n\n![](http://pbflin9sq.bkt.clouddn.com/20180922201006.png)\n\n情意绵绵之做你最美新娘\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0661.JPG)\n\n**拉萨至羊湖的沿途**\n雪山\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0702.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0519.JPG)\n\n**第四站：羊卓雍措(羊湖)**\n\n藏语意为“碧玉湖”，是西藏三大圣湖之一(与纳木错、玛旁雍错并称西藏三大圣湖)，湖面海拔4,441米，湖面平静，一片翠蓝，仿佛如山南高原上的蓝宝石；位于西藏山南市浪卡子县。\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0501.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/E73B7CE167B7DAA306B9B823030B6C37.jpg)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0778.JPG)\n\n我们一起看最蓝的天\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0704.png)\n\n呼吸着最新鲜空气\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_092422.png)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0522.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0804.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1353.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0439.JPG)\n\n**第五站：纳木错**\n\n“纳木错”为藏语，蒙古语名称为“腾格里海”，都是“天湖”之意，是古象雄佛法雍仲本教的第一神湖，为著名的佛教圣地之一。位于西藏自治区中部，是西藏第二大湖泊，也是中国第三大的咸水湖。湖面海拔4718米\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0752.png)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0710.png)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0730.png)\n\n纳木错的日出，你没来\n\n![纳木错的日出，你没来](http://pbflin9sq.bkt.clouddn.com/IMG_0629.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0838.JPG)\n\n纳木错的海鸥\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0872.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1313.JPG)\n\n傍晚的纳木错\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0785.JPG)\n\n**唐古拉山的日出**\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1200.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0675.JPG)\n\n人生啊，人生！西藏啊，西藏！\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0579.JPG)\n\n西藏北大门，西藏再见！\n\n![](http://pbflin9sq.bkt.clouddn.com/D0840CD92BF2A199EF41A8D32DBE36FC.jpg)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1282.JPG)\n\n**第六站：可可西里**\n\n国家级自然保护区位于青海省玉树藏族自治州西部，是中国建成的面积最大，海拔最高，野生动物资源最为丰富的自然保护区之一；主要是保护藏羚羊、野牦牛、藏野驴、藏原羚等珍稀野生动物、植物及其栖息环境\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1215.png)\n\n藏羚羊，行驶中拍的，距离有点远，所以不是很清楚\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0942.JPG)\n\n\n\n**可可西里沿途风景**\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0967.png)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1000.png)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0982.png)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0954.JPG)\n\n\n\n**第七站：昆仑山脉**\n\n昆仑山脉（昆仑山），又称昆仑虚、中国第一神山、万祖之山、昆仑丘或玉山；\n\n古代神话认为昆仑山中居住着一位神仙“西王母”，人头豹身，由两只青鸟侍奉，是道教正神，与东王公分掌男女修仙登引之事。位于中国新疆与青海、西藏交界处。\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0712.PNG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0727.JPG)\n\n昆仑山泉水\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0751.JPG)\n\n饮水思源\n\n![](http://pbflin9sq.bkt.clouddn.com/E8B9EB607C9A780CDD6CC6A56EBFA3C1.jpg)\n\n\n\n**第八站：茶卡盐湖**\n\n茶卡盐湖，别称茶卡或达布逊淖尔，是位于青海省海西蒙古族藏族自治州乌兰县茶卡镇的天然结晶盐湖，是柴达木盆地四大盐湖之一。“茶卡”是藏语，意即盐池；是“青海四大景”之一，被旅行者们称为中国“天空之镜”，被国家旅游地理杂志评为“人一生必去的55个地方”之一。\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1019.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_104444.JPG)\n\n这里风很大、很冷、冰淇淋很冰、雪糕咬不动、但我们的心里很暖\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0779.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_10688888.JPG)\n\n我已成魔，为了渡化你\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1178.png)\n\n即已成魔，执念何必那么深\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1127.JPG)\n\n前世五百次的回眸，换来今生的相遇，这就是“盐”，不清不楚\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1190.JPG)\n\n\n\n**第九站：青海湖**\n\n青海湖，藏语名为“措温布”（意为“青色的海”）。位于青藏高原东北部、青海省境内，中国最大的内陆湖、咸水湖。\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1210.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1214.JPG)\n\n**一路美食相伴**\n\n青棵牛肉面\n\n![](http://pbflin9sq.bkt.clouddn.com/20180922185705.png)\n\n西藏酸奶\n\n![](http://pbflin9sq.bkt.clouddn.com/20180922201006.png)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0045.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0369.JPG)\n\n青海羊肉火锅\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0762.JPG)\n\n藏式牛肉炒饭\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0847.JPG)\n\n藏面\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0853.JPG)\n\n\n\n感谢《1677一路向西》自由行一路相伴的团友，很荣幸认识你们，带给了我一次难忘有意义的旅行，旅途中的我们不畏艰辛，每迈一步走向更高的海拔，只为看到更美的风景，就像人生一样；不断前行，只为见到更美、更优秀的自己；海拔没有巅峰，人生也一样，愿我们的人生步步高升，就像我们这次旅途一样顺畅、风雨无阻。\n\n\n\n[照片共享地址:https://pan.baidu.com/s/1G6Ay9dyShivBhYXhL62dyg](https://pan.baidu.com/s/1G6Ay9dyShivBhYXhL62dyg)\n\n\n\n​                                                                                                     \t\t\t起伏哥 亲笔","source":"_posts/1677ziyouxing.md","raw":"---\ntitle: 穿越318线川藏游记\ncatalog: true\ndate: 2018-09-22 20:40:28\nsubtitle: 一路向西\nheader-img: 1677ziyouxing.png\ncatagories:\n  - Stuio\ntags:\n  - 游记\n---\n​        那天一个小心，从朋友那听说将要进行川藏之旅，之前因为时间的关系一直没去成，这一次不顾一切；西藏是我一直向往的地方，在我的心中是一块神圣土地，是不可替代的，那里有蔚蓝、安静的天空、纯朴的人民；我曾想第一次去西藏一定要带我所爱之人一起去，但所爱之人( )，有些事还得去做，就类似那首歌里面唱的一样：“一个人完成两个人的梦想”；好了，言归正传吧！\n\n\n\n​        我们是从成都出发的，今年的第一次远行，从深圳出发至成都，早上4点起来赶飞机，在行程的前一天到达成都，主要是为了翻越下成都的美食。\n\n\n\n​        今天9月03号，我们出发了，天空飘着雨，不大不小，刚好够洗刷一座城、一颗心，应该是老天想把西藏在我见到之前再洗漱一次，让我见到更美丽、纯洁的它。\n\n\n\n   *人生一定得去一次西藏*\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0043.JPG)\n\n​        **第一站：海螺沟**\n\n   诗说：那一刻 我升起风马，不为乞福只为守候你的到来；那一世 转山转水转佛塔，不为修来世只为途中与你相见——我们相约海螺沟；柏油路，一路很胜利，天气也很好。\n\n   海螺沟位于四川省泸定县磨西镇，贡嘎山东坡，是青藏高原东缘的极高山地。位于贡嘎雪峰脚下，以低海拔现代冰川著称于世，海拔2850米。\n\n![](http://pbflin9sq.bkt.clouddn.com/20180922134303.png)\n\n![](http://pbflin9sq.bkt.clouddn.com/timg-2.jpeg)\n\n海螺沟磨西镇：他是一个有着历史韵味的小镇，一个个酒吧，一条条石板路，都像是在诉说着属于他自己的故事。\n\n![](http://pbflin9sq.bkt.clouddn.com/20180612105916.jpg)\n\n\n\n**色达**\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0280.JPG)\n\n牛群\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0116.JPG)\n\n在色达的美女\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0129.JPG)\n\n牛气冲天\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0134.JPG)\n\n夜晚的色达\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0225.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0224.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0242.JPG)\n\n\n\n最可爱土拨鼠\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0111.JPG)\n\n格桑花\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0273.JPG)\n\n秃鹫\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0100.JPG)\n\n天葬台\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0094-2.JPG)\n\n\n\n\n   **第二站：稻城亚丁**\n\n   亚丁，藏语意为“向阳之地”；被誉为“水蓝色星球上的最后一片净土”，这里有雪山、冰川、峡谷、森林、草甸、湖泊、金矿及纯净的空气。\n\n   位于四川省[甘孜藏族自治州]稻城县[香格里拉镇]亚丁村境内；保护区内的三座雪山：仙乃日、央迈勇、夏诺多吉，呈品字形排列，统称“念青贡嘎日松贡布”，意为：终年积雪不化的三座护法神山圣地。藏传佛教中称其为“三怙主雪山”，是藏民心中的神圣之地。\n\n   7:30到了景点门票区(香格里拉镇)，很好有自助买票的机器，去得比较早基本不用排队，建议还是早点(8点之前到达)去，买票后先是坐1个小时左右的景车到达景点1(扎灌崩)，再坐车或者徒步到烙绒牛场(6.7km)，去景点的路都是围绕着山跑，从海拔2900升到4700，至于高原反应，你不要太紧张，不要去想它，我们一车的人都没感觉，一路穿梭在云里雾里的感觉，心旷神怡！到达山脚下后，开始徒步上山，全程6公里左右，最高海拔4700；\n\n   我们一路拍照一路前行，为了爬上去看《牛奶海》、《五色海》及为了体验下海拔四千七的感觉，不巧的是这一天在我们爬了5公里左右的时候下大雨了，持续了有半小时左右，没有带伞，带的是雨衣，鞋子、裤脚全湿了；女同胞怕冻感冒，山路加上下雨比较滑，安全送达到山下后，到达景区的返程乘车点大概是14:30；\n\n   心不死，爱还在，我要爬到终点看《牛奶海》、《五色海》，预估下时间：最晚的一趟返程车是18点，体力没有问题，不管怎样必须爬上去，心意已决，睡在山上也要上；黄天不有心人，出太阳了，看到了雨后和阳光中的《牛奶海》、《五色海》。不过结果是17：30到达了返程的乘车点。\n\n离顶峰只有“一步”之逍了，给自己多点动力，其实还挺远的，上去再绕下去就是《五色海》，左边前行1公里左右就是《牛奶海》\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1139.JPG)\n\n牛奶海\n\n![牛奶海](http://pbflin9sq.bkt.clouddn.com/DSC_1080.JPG)\n\n五色海\n\n![五色海](http://pbflin9sq.bkt.clouddn.com/DSC_1100.JPG)\n\n都说：*爱Ta，恨Ta，一定在带Ta上亚丁*\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0397.JPG)\n\n\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1249.JPG)\n\n小溪\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1044.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1151.JPG)\n\n冰川\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1230.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1068.JPG)\n\n嗨\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0928.JPG)\n\n\n\n**稻城至拉萨的沿途**\n\n天路十八弯\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0719.JPG)\n\n藏文石经\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0686.JPG)\n\n舒畅与放肆\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0652.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0279.JPG)\n\n西藏界：金沙江\n\n![](http://pbflin9sq.bkt.clouddn.com/19B17524966F860AF9642C5404EBCF35.jpg)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0424.JPG)\n\n野炊之泡面大杂烩\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0441.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0442.JPG)\n\n**第三站：拉萨**\n中国西藏自治区的首府，具有高原和民族特色的国际旅游城市  ，是西藏的政治、经济、文化和科教中心，也是藏传佛教圣地；以风光秀丽、历史悠久、风俗民情独特、宗教色彩浓厚而闻名于世，海拔3650米。\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0830.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0888.JPG)\n拉萨，我来了\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0582.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0586.JPG)\n\n邂逅最美彩虹\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0560.JPG)\n\n金马演义圈，不错有联欢晚会的感觉\n\n![](http://pbflin9sq.bkt.clouddn.com/AA292FAB86964F674893464F40553FF7.jpg)\n\n**一路美食相伴**\n\n青棵牛肉面\n\n![](http://pbflin9sq.bkt.clouddn.com/20180922185705.png)\n\n酸奶\n\n![](http://pbflin9sq.bkt.clouddn.com/20180922201006.png)\n\n情意绵绵之做你最美新娘\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0661.JPG)\n\n**拉萨至羊湖的沿途**\n雪山\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0702.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0519.JPG)\n\n**第四站：羊卓雍措(羊湖)**\n\n藏语意为“碧玉湖”，是西藏三大圣湖之一(与纳木错、玛旁雍错并称西藏三大圣湖)，湖面海拔4,441米，湖面平静，一片翠蓝，仿佛如山南高原上的蓝宝石；位于西藏山南市浪卡子县。\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0501.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/E73B7CE167B7DAA306B9B823030B6C37.jpg)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0778.JPG)\n\n我们一起看最蓝的天\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0704.png)\n\n呼吸着最新鲜空气\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_092422.png)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0522.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0804.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1353.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0439.JPG)\n\n**第五站：纳木错**\n\n“纳木错”为藏语，蒙古语名称为“腾格里海”，都是“天湖”之意，是古象雄佛法雍仲本教的第一神湖，为著名的佛教圣地之一。位于西藏自治区中部，是西藏第二大湖泊，也是中国第三大的咸水湖。湖面海拔4718米\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0752.png)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0710.png)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0730.png)\n\n纳木错的日出，你没来\n\n![纳木错的日出，你没来](http://pbflin9sq.bkt.clouddn.com/IMG_0629.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0838.JPG)\n\n纳木错的海鸥\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0872.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1313.JPG)\n\n傍晚的纳木错\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0785.JPG)\n\n**唐古拉山的日出**\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1200.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0675.JPG)\n\n人生啊，人生！西藏啊，西藏！\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0579.JPG)\n\n西藏北大门，西藏再见！\n\n![](http://pbflin9sq.bkt.clouddn.com/D0840CD92BF2A199EF41A8D32DBE36FC.jpg)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1282.JPG)\n\n**第六站：可可西里**\n\n国家级自然保护区位于青海省玉树藏族自治州西部，是中国建成的面积最大，海拔最高，野生动物资源最为丰富的自然保护区之一；主要是保护藏羚羊、野牦牛、藏野驴、藏原羚等珍稀野生动物、植物及其栖息环境\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1215.png)\n\n藏羚羊，行驶中拍的，距离有点远，所以不是很清楚\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0942.JPG)\n\n\n\n**可可西里沿途风景**\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0967.png)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1000.png)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0982.png)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0954.JPG)\n\n\n\n**第七站：昆仑山脉**\n\n昆仑山脉（昆仑山），又称昆仑虚、中国第一神山、万祖之山、昆仑丘或玉山；\n\n古代神话认为昆仑山中居住着一位神仙“西王母”，人头豹身，由两只青鸟侍奉，是道教正神，与东王公分掌男女修仙登引之事。位于中国新疆与青海、西藏交界处。\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0712.PNG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0727.JPG)\n\n昆仑山泉水\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0751.JPG)\n\n饮水思源\n\n![](http://pbflin9sq.bkt.clouddn.com/E8B9EB607C9A780CDD6CC6A56EBFA3C1.jpg)\n\n\n\n**第八站：茶卡盐湖**\n\n茶卡盐湖，别称茶卡或达布逊淖尔，是位于青海省海西蒙古族藏族自治州乌兰县茶卡镇的天然结晶盐湖，是柴达木盆地四大盐湖之一。“茶卡”是藏语，意即盐池；是“青海四大景”之一，被旅行者们称为中国“天空之镜”，被国家旅游地理杂志评为“人一生必去的55个地方”之一。\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1019.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_104444.JPG)\n\n这里风很大、很冷、冰淇淋很冰、雪糕咬不动、但我们的心里很暖\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0779.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_10688888.JPG)\n\n我已成魔，为了渡化你\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1178.png)\n\n即已成魔，执念何必那么深\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1127.JPG)\n\n前世五百次的回眸，换来今生的相遇，这就是“盐”，不清不楚\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1190.JPG)\n\n\n\n**第九站：青海湖**\n\n青海湖，藏语名为“措温布”（意为“青色的海”）。位于青藏高原东北部、青海省境内，中国最大的内陆湖、咸水湖。\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1210.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_1214.JPG)\n\n**一路美食相伴**\n\n青棵牛肉面\n\n![](http://pbflin9sq.bkt.clouddn.com/20180922185705.png)\n\n西藏酸奶\n\n![](http://pbflin9sq.bkt.clouddn.com/20180922201006.png)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0045.JPG)\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0369.JPG)\n\n青海羊肉火锅\n\n![](http://pbflin9sq.bkt.clouddn.com/IMG_0762.JPG)\n\n藏式牛肉炒饭\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0847.JPG)\n\n藏面\n\n![](http://pbflin9sq.bkt.clouddn.com/DSC_0853.JPG)\n\n\n\n感谢《1677一路向西》自由行一路相伴的团友，很荣幸认识你们，带给了我一次难忘有意义的旅行，旅途中的我们不畏艰辛，每迈一步走向更高的海拔，只为看到更美的风景，就像人生一样；不断前行，只为见到更美、更优秀的自己；海拔没有巅峰，人生也一样，愿我们的人生步步高升，就像我们这次旅途一样顺畅、风雨无阻。\n\n\n\n[照片共享地址:https://pan.baidu.com/s/1G6Ay9dyShivBhYXhL62dyg](https://pan.baidu.com/s/1G6Ay9dyShivBhYXhL62dyg)\n\n\n\n​                                                                                                     \t\t\t起伏哥 亲笔","slug":"1677ziyouxing","published":1,"updated":"2019-02-23T05:43:37.219Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsh3gt6b0014ncezhsldbqn9","content":"<p>​        那天一个小心，从朋友那听说将要进行川藏之旅，之前因为时间的关系一直没去成，这一次不顾一切；西藏是我一直向往的地方，在我的心中是一块神圣土地，是不可替代的，那里有蔚蓝、安静的天空、纯朴的人民；我曾想第一次去西藏一定要带我所爱之人一起去，但所爱之人( )，有些事还得去做，就类似那首歌里面唱的一样：“一个人完成两个人的梦想”；好了，言归正传吧！</p>\n<p>​        我们是从成都出发的，今年的第一次远行，从深圳出发至成都，早上4点起来赶飞机，在行程的前一天到达成都，主要是为了翻越下成都的美食。</p>\n<p>​        今天9月03号，我们出发了，天空飘着雨，不大不小，刚好够洗刷一座城、一颗心，应该是老天想把西藏在我见到之前再洗漱一次，让我见到更美丽、纯洁的它。</p>\n<p><em>人生一定得去一次西藏</em></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0043.JPG\" alt></p>\n<p>​        <strong>第一站：海螺沟</strong></p>\n<p>诗说：那一刻 我升起风马，不为乞福只为守候你的到来；那一世 转山转水转佛塔，不为修来世只为途中与你相见——我们相约海螺沟；柏油路，一路很胜利，天气也很好。</p>\n<p>海螺沟位于四川省泸定县磨西镇，贡嘎山东坡，是青藏高原东缘的极高山地。位于贡嘎雪峰脚下，以低海拔现代冰川著称于世，海拔2850米。</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/20180922134303.png\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/timg-2.jpeg\" alt></p>\n<p>海螺沟磨西镇：他是一个有着历史韵味的小镇，一个个酒吧，一条条石板路，都像是在诉说着属于他自己的故事。</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/20180612105916.jpg\" alt></p>\n<p><strong>色达</strong></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0280.JPG\" alt></p>\n<p>牛群</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0116.JPG\" alt></p>\n<p>在色达的美女</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0129.JPG\" alt></p>\n<p>牛气冲天</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0134.JPG\" alt></p>\n<p>夜晚的色达</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0225.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0224.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0242.JPG\" alt></p>\n<p>最可爱土拨鼠</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0111.JPG\" alt></p>\n<p>格桑花</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0273.JPG\" alt></p>\n<p>秃鹫</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0100.JPG\" alt></p>\n<p>天葬台</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0094-2.JPG\" alt></p>\n<p><strong>第二站：稻城亚丁</strong></p>\n<p>亚丁，藏语意为“向阳之地”；被誉为“水蓝色星球上的最后一片净土”，这里有雪山、冰川、峡谷、森林、草甸、湖泊、金矿及纯净的空气。</p>\n<p>位于四川省[甘孜藏族自治州]稻城县[香格里拉镇]亚丁村境内；保护区内的三座雪山：仙乃日、央迈勇、夏诺多吉，呈品字形排列，统称“念青贡嘎日松贡布”，意为：终年积雪不化的三座护法神山圣地。藏传佛教中称其为“三怙主雪山”，是藏民心中的神圣之地。</p>\n<p>7:30到了景点门票区(香格里拉镇)，很好有自助买票的机器，去得比较早基本不用排队，建议还是早点(8点之前到达)去，买票后先是坐1个小时左右的景车到达景点1(扎灌崩)，再坐车或者徒步到烙绒牛场(6.7km)，去景点的路都是围绕着山跑，从海拔2900升到4700，至于高原反应，你不要太紧张，不要去想它，我们一车的人都没感觉，一路穿梭在云里雾里的感觉，心旷神怡！到达山脚下后，开始徒步上山，全程6公里左右，最高海拔4700；</p>\n<p>我们一路拍照一路前行，为了爬上去看《牛奶海》、《五色海》及为了体验下海拔四千七的感觉，不巧的是这一天在我们爬了5公里左右的时候下大雨了，持续了有半小时左右，没有带伞，带的是雨衣，鞋子、裤脚全湿了；女同胞怕冻感冒，山路加上下雨比较滑，安全送达到山下后，到达景区的返程乘车点大概是14:30；</p>\n<p>心不死，爱还在，我要爬到终点看《牛奶海》、《五色海》，预估下时间：最晚的一趟返程车是18点，体力没有问题，不管怎样必须爬上去，心意已决，睡在山上也要上；黄天不有心人，出太阳了，看到了雨后和阳光中的《牛奶海》、《五色海》。不过结果是17：30到达了返程的乘车点。</p>\n<p>离顶峰只有“一步”之逍了，给自己多点动力，其实还挺远的，上去再绕下去就是《五色海》，左边前行1公里左右就是《牛奶海》</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1139.JPG\" alt></p>\n<p>牛奶海</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1080.JPG\" alt=\"牛奶海\"></p>\n<p>五色海</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1100.JPG\" alt=\"五色海\"></p>\n<p>都说：<em>爱Ta，恨Ta，一定在带Ta上亚丁</em></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0397.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1249.JPG\" alt></p>\n<p>小溪</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1044.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1151.JPG\" alt></p>\n<p>冰川</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1230.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1068.JPG\" alt></p>\n<p>嗨</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0928.JPG\" alt></p>\n<p><strong>稻城至拉萨的沿途</strong></p>\n<p>天路十八弯</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0719.JPG\" alt></p>\n<p>藏文石经</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0686.JPG\" alt></p>\n<p>舒畅与放肆<br>\n<img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0652.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0279.JPG\" alt></p>\n<p>西藏界：金沙江</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/19B17524966F860AF9642C5404EBCF35.jpg\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0424.JPG\" alt></p>\n<p>野炊之泡面大杂烩<br>\n<img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0441.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0442.JPG\" alt></p>\n<p><strong>第三站：拉萨</strong><br>\n中国西藏自治区的首府，具有高原和民族特色的国际旅游城市  ，是西藏的政治、经济、文化和科教中心，也是藏传佛教圣地；以风光秀丽、历史悠久、风俗民情独特、宗教色彩浓厚而闻名于世，海拔3650米。<br>\n<img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0830.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0888.JPG\" alt><br>\n拉萨，我来了<br>\n<img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0582.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0586.JPG\" alt></p>\n<p>邂逅最美彩虹<br>\n<img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0560.JPG\" alt></p>\n<p>金马演义圈，不错有联欢晚会的感觉</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/AA292FAB86964F674893464F40553FF7.jpg\" alt></p>\n<p><strong>一路美食相伴</strong></p>\n<p>青棵牛肉面</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/20180922185705.png\" alt></p>\n<p>酸奶</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/20180922201006.png\" alt></p>\n<p>情意绵绵之做你最美新娘<br>\n<img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0661.JPG\" alt></p>\n<p><strong>拉萨至羊湖的沿途</strong><br>\n雪山</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0702.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0519.JPG\" alt></p>\n<p><strong>第四站：羊卓雍措(羊湖)</strong></p>\n<p>藏语意为“碧玉湖”，是西藏三大圣湖之一(与纳木错、玛旁雍错并称西藏三大圣湖)，湖面海拔4,441米，湖面平静，一片翠蓝，仿佛如山南高原上的蓝宝石；位于西藏山南市浪卡子县。</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0501.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/E73B7CE167B7DAA306B9B823030B6C37.jpg\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0778.JPG\" alt></p>\n<p>我们一起看最蓝的天</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0704.png\" alt></p>\n<p>呼吸着最新鲜空气</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_092422.png\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0522.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0804.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1353.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0439.JPG\" alt></p>\n<p><strong>第五站：纳木错</strong></p>\n<p>“纳木错”为藏语，蒙古语名称为“腾格里海”，都是“天湖”之意，是古象雄佛法雍仲本教的第一神湖，为著名的佛教圣地之一。位于西藏自治区中部，是西藏第二大湖泊，也是中国第三大的咸水湖。湖面海拔4718米</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0752.png\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0710.png\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0730.png\" alt></p>\n<p>纳木错的日出，你没来</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0629.JPG\" alt=\"纳木错的日出，你没来\"></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0838.JPG\" alt></p>\n<p>纳木错的海鸥</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0872.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1313.JPG\" alt></p>\n<p>傍晚的纳木错</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0785.JPG\" alt></p>\n<p><strong>唐古拉山的日出</strong></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1200.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0675.JPG\" alt></p>\n<p>人生啊，人生！西藏啊，西藏！</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0579.JPG\" alt></p>\n<p>西藏北大门，西藏再见！</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/D0840CD92BF2A199EF41A8D32DBE36FC.jpg\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1282.JPG\" alt></p>\n<p><strong>第六站：可可西里</strong></p>\n<p>国家级自然保护区位于青海省玉树藏族自治州西部，是中国建成的面积最大，海拔最高，野生动物资源最为丰富的自然保护区之一；主要是保护藏羚羊、野牦牛、藏野驴、藏原羚等珍稀野生动物、植物及其栖息环境</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1215.png\" alt></p>\n<p>藏羚羊，行驶中拍的，距离有点远，所以不是很清楚</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0942.JPG\" alt></p>\n<p><strong>可可西里沿途风景</strong></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0967.png\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1000.png\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0982.png\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0954.JPG\" alt></p>\n<p><strong>第七站：昆仑山脉</strong></p>\n<p>昆仑山脉（昆仑山），又称昆仑虚、中国第一神山、万祖之山、昆仑丘或玉山；</p>\n<p>古代神话认为昆仑山中居住着一位神仙“西王母”，人头豹身，由两只青鸟侍奉，是道教正神，与东王公分掌男女修仙登引之事。位于中国新疆与青海、西藏交界处。</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0712.PNG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0727.JPG\" alt></p>\n<p>昆仑山泉水</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0751.JPG\" alt></p>\n<p>饮水思源</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/E8B9EB607C9A780CDD6CC6A56EBFA3C1.jpg\" alt></p>\n<p><strong>第八站：茶卡盐湖</strong></p>\n<p>茶卡盐湖，别称茶卡或达布逊淖尔，是位于青海省海西蒙古族藏族自治州乌兰县茶卡镇的天然结晶盐湖，是柴达木盆地四大盐湖之一。“茶卡”是藏语，意即盐池；是“青海四大景”之一，被旅行者们称为中国“天空之镜”，被国家旅游地理杂志评为“人一生必去的55个地方”之一。</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1019.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_104444.JPG\" alt></p>\n<p>这里风很大、很冷、冰淇淋很冰、雪糕咬不动、但我们的心里很暖</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0779.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_10688888.JPG\" alt></p>\n<p>我已成魔，为了渡化你</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1178.png\" alt></p>\n<p>即已成魔，执念何必那么深</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1127.JPG\" alt></p>\n<p>前世五百次的回眸，换来今生的相遇，这就是“盐”，不清不楚</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1190.JPG\" alt></p>\n<p><strong>第九站：青海湖</strong></p>\n<p>青海湖，藏语名为“措温布”（意为“青色的海”）。位于青藏高原东北部、青海省境内，中国最大的内陆湖、咸水湖。</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1210.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1214.JPG\" alt></p>\n<p><strong>一路美食相伴</strong></p>\n<p>青棵牛肉面</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/20180922185705.png\" alt></p>\n<p>西藏酸奶</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/20180922201006.png\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0045.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0369.JPG\" alt></p>\n<p>青海羊肉火锅</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0762.JPG\" alt></p>\n<p>藏式牛肉炒饭</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0847.JPG\" alt></p>\n<p>藏面</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0853.JPG\" alt></p>\n<p>感谢《1677一路向西》自由行一路相伴的团友，很荣幸认识你们，带给了我一次难忘有意义的旅行，旅途中的我们不畏艰辛，每迈一步走向更高的海拔，只为看到更美的风景，就像人生一样；不断前行，只为见到更美、更优秀的自己；海拔没有巅峰，人生也一样，愿我们的人生步步高升，就像我们这次旅途一样顺畅、风雨无阻。</p>\n<p><a href=\"https://pan.baidu.com/s/1G6Ay9dyShivBhYXhL62dyg\" target=\"_blank\" rel=\"noopener\">照片共享地址:https://pan.baidu.com/s/1G6Ay9dyShivBhYXhL62dyg</a></p>\n<p>​                                                                                                     \t\t\t起伏哥 亲笔</p>\n","site":{"data":{}},"excerpt":"","more":"<p>​        那天一个小心，从朋友那听说将要进行川藏之旅，之前因为时间的关系一直没去成，这一次不顾一切；西藏是我一直向往的地方，在我的心中是一块神圣土地，是不可替代的，那里有蔚蓝、安静的天空、纯朴的人民；我曾想第一次去西藏一定要带我所爱之人一起去，但所爱之人( )，有些事还得去做，就类似那首歌里面唱的一样：“一个人完成两个人的梦想”；好了，言归正传吧！</p>\n<p>​        我们是从成都出发的，今年的第一次远行，从深圳出发至成都，早上4点起来赶飞机，在行程的前一天到达成都，主要是为了翻越下成都的美食。</p>\n<p>​        今天9月03号，我们出发了，天空飘着雨，不大不小，刚好够洗刷一座城、一颗心，应该是老天想把西藏在我见到之前再洗漱一次，让我见到更美丽、纯洁的它。</p>\n<p><em>人生一定得去一次西藏</em></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0043.JPG\" alt></p>\n<p>​        <strong>第一站：海螺沟</strong></p>\n<p>诗说：那一刻 我升起风马，不为乞福只为守候你的到来；那一世 转山转水转佛塔，不为修来世只为途中与你相见——我们相约海螺沟；柏油路，一路很胜利，天气也很好。</p>\n<p>海螺沟位于四川省泸定县磨西镇，贡嘎山东坡，是青藏高原东缘的极高山地。位于贡嘎雪峰脚下，以低海拔现代冰川著称于世，海拔2850米。</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/20180922134303.png\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/timg-2.jpeg\" alt></p>\n<p>海螺沟磨西镇：他是一个有着历史韵味的小镇，一个个酒吧，一条条石板路，都像是在诉说着属于他自己的故事。</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/20180612105916.jpg\" alt></p>\n<p><strong>色达</strong></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0280.JPG\" alt></p>\n<p>牛群</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0116.JPG\" alt></p>\n<p>在色达的美女</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0129.JPG\" alt></p>\n<p>牛气冲天</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0134.JPG\" alt></p>\n<p>夜晚的色达</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0225.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0224.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0242.JPG\" alt></p>\n<p>最可爱土拨鼠</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0111.JPG\" alt></p>\n<p>格桑花</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0273.JPG\" alt></p>\n<p>秃鹫</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0100.JPG\" alt></p>\n<p>天葬台</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0094-2.JPG\" alt></p>\n<p><strong>第二站：稻城亚丁</strong></p>\n<p>亚丁，藏语意为“向阳之地”；被誉为“水蓝色星球上的最后一片净土”，这里有雪山、冰川、峡谷、森林、草甸、湖泊、金矿及纯净的空气。</p>\n<p>位于四川省[甘孜藏族自治州]稻城县[香格里拉镇]亚丁村境内；保护区内的三座雪山：仙乃日、央迈勇、夏诺多吉，呈品字形排列，统称“念青贡嘎日松贡布”，意为：终年积雪不化的三座护法神山圣地。藏传佛教中称其为“三怙主雪山”，是藏民心中的神圣之地。</p>\n<p>7:30到了景点门票区(香格里拉镇)，很好有自助买票的机器，去得比较早基本不用排队，建议还是早点(8点之前到达)去，买票后先是坐1个小时左右的景车到达景点1(扎灌崩)，再坐车或者徒步到烙绒牛场(6.7km)，去景点的路都是围绕着山跑，从海拔2900升到4700，至于高原反应，你不要太紧张，不要去想它，我们一车的人都没感觉，一路穿梭在云里雾里的感觉，心旷神怡！到达山脚下后，开始徒步上山，全程6公里左右，最高海拔4700；</p>\n<p>我们一路拍照一路前行，为了爬上去看《牛奶海》、《五色海》及为了体验下海拔四千七的感觉，不巧的是这一天在我们爬了5公里左右的时候下大雨了，持续了有半小时左右，没有带伞，带的是雨衣，鞋子、裤脚全湿了；女同胞怕冻感冒，山路加上下雨比较滑，安全送达到山下后，到达景区的返程乘车点大概是14:30；</p>\n<p>心不死，爱还在，我要爬到终点看《牛奶海》、《五色海》，预估下时间：最晚的一趟返程车是18点，体力没有问题，不管怎样必须爬上去，心意已决，睡在山上也要上；黄天不有心人，出太阳了，看到了雨后和阳光中的《牛奶海》、《五色海》。不过结果是17：30到达了返程的乘车点。</p>\n<p>离顶峰只有“一步”之逍了，给自己多点动力，其实还挺远的，上去再绕下去就是《五色海》，左边前行1公里左右就是《牛奶海》</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1139.JPG\" alt></p>\n<p>牛奶海</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1080.JPG\" alt=\"牛奶海\"></p>\n<p>五色海</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1100.JPG\" alt=\"五色海\"></p>\n<p>都说：<em>爱Ta，恨Ta，一定在带Ta上亚丁</em></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0397.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1249.JPG\" alt></p>\n<p>小溪</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1044.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1151.JPG\" alt></p>\n<p>冰川</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1230.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1068.JPG\" alt></p>\n<p>嗨</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0928.JPG\" alt></p>\n<p><strong>稻城至拉萨的沿途</strong></p>\n<p>天路十八弯</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0719.JPG\" alt></p>\n<p>藏文石经</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0686.JPG\" alt></p>\n<p>舒畅与放肆<br>\n<img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0652.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0279.JPG\" alt></p>\n<p>西藏界：金沙江</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/19B17524966F860AF9642C5404EBCF35.jpg\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0424.JPG\" alt></p>\n<p>野炊之泡面大杂烩<br>\n<img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0441.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0442.JPG\" alt></p>\n<p><strong>第三站：拉萨</strong><br>\n中国西藏自治区的首府，具有高原和民族特色的国际旅游城市  ，是西藏的政治、经济、文化和科教中心，也是藏传佛教圣地；以风光秀丽、历史悠久、风俗民情独特、宗教色彩浓厚而闻名于世，海拔3650米。<br>\n<img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0830.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0888.JPG\" alt><br>\n拉萨，我来了<br>\n<img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0582.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0586.JPG\" alt></p>\n<p>邂逅最美彩虹<br>\n<img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0560.JPG\" alt></p>\n<p>金马演义圈，不错有联欢晚会的感觉</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/AA292FAB86964F674893464F40553FF7.jpg\" alt></p>\n<p><strong>一路美食相伴</strong></p>\n<p>青棵牛肉面</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/20180922185705.png\" alt></p>\n<p>酸奶</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/20180922201006.png\" alt></p>\n<p>情意绵绵之做你最美新娘<br>\n<img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0661.JPG\" alt></p>\n<p><strong>拉萨至羊湖的沿途</strong><br>\n雪山</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0702.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0519.JPG\" alt></p>\n<p><strong>第四站：羊卓雍措(羊湖)</strong></p>\n<p>藏语意为“碧玉湖”，是西藏三大圣湖之一(与纳木错、玛旁雍错并称西藏三大圣湖)，湖面海拔4,441米，湖面平静，一片翠蓝，仿佛如山南高原上的蓝宝石；位于西藏山南市浪卡子县。</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0501.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/E73B7CE167B7DAA306B9B823030B6C37.jpg\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0778.JPG\" alt></p>\n<p>我们一起看最蓝的天</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0704.png\" alt></p>\n<p>呼吸着最新鲜空气</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_092422.png\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0522.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0804.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1353.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0439.JPG\" alt></p>\n<p><strong>第五站：纳木错</strong></p>\n<p>“纳木错”为藏语，蒙古语名称为“腾格里海”，都是“天湖”之意，是古象雄佛法雍仲本教的第一神湖，为著名的佛教圣地之一。位于西藏自治区中部，是西藏第二大湖泊，也是中国第三大的咸水湖。湖面海拔4718米</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0752.png\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0710.png\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0730.png\" alt></p>\n<p>纳木错的日出，你没来</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0629.JPG\" alt=\"纳木错的日出，你没来\"></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0838.JPG\" alt></p>\n<p>纳木错的海鸥</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0872.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1313.JPG\" alt></p>\n<p>傍晚的纳木错</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0785.JPG\" alt></p>\n<p><strong>唐古拉山的日出</strong></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1200.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0675.JPG\" alt></p>\n<p>人生啊，人生！西藏啊，西藏！</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0579.JPG\" alt></p>\n<p>西藏北大门，西藏再见！</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/D0840CD92BF2A199EF41A8D32DBE36FC.jpg\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1282.JPG\" alt></p>\n<p><strong>第六站：可可西里</strong></p>\n<p>国家级自然保护区位于青海省玉树藏族自治州西部，是中国建成的面积最大，海拔最高，野生动物资源最为丰富的自然保护区之一；主要是保护藏羚羊、野牦牛、藏野驴、藏原羚等珍稀野生动物、植物及其栖息环境</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1215.png\" alt></p>\n<p>藏羚羊，行驶中拍的，距离有点远，所以不是很清楚</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0942.JPG\" alt></p>\n<p><strong>可可西里沿途风景</strong></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0967.png\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1000.png\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0982.png\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0954.JPG\" alt></p>\n<p><strong>第七站：昆仑山脉</strong></p>\n<p>昆仑山脉（昆仑山），又称昆仑虚、中国第一神山、万祖之山、昆仑丘或玉山；</p>\n<p>古代神话认为昆仑山中居住着一位神仙“西王母”，人头豹身，由两只青鸟侍奉，是道教正神，与东王公分掌男女修仙登引之事。位于中国新疆与青海、西藏交界处。</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0712.PNG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0727.JPG\" alt></p>\n<p>昆仑山泉水</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0751.JPG\" alt></p>\n<p>饮水思源</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/E8B9EB607C9A780CDD6CC6A56EBFA3C1.jpg\" alt></p>\n<p><strong>第八站：茶卡盐湖</strong></p>\n<p>茶卡盐湖，别称茶卡或达布逊淖尔，是位于青海省海西蒙古族藏族自治州乌兰县茶卡镇的天然结晶盐湖，是柴达木盆地四大盐湖之一。“茶卡”是藏语，意即盐池；是“青海四大景”之一，被旅行者们称为中国“天空之镜”，被国家旅游地理杂志评为“人一生必去的55个地方”之一。</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1019.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_104444.JPG\" alt></p>\n<p>这里风很大、很冷、冰淇淋很冰、雪糕咬不动、但我们的心里很暖</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0779.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_10688888.JPG\" alt></p>\n<p>我已成魔，为了渡化你</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1178.png\" alt></p>\n<p>即已成魔，执念何必那么深</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1127.JPG\" alt></p>\n<p>前世五百次的回眸，换来今生的相遇，这就是“盐”，不清不楚</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1190.JPG\" alt></p>\n<p><strong>第九站：青海湖</strong></p>\n<p>青海湖，藏语名为“措温布”（意为“青色的海”）。位于青藏高原东北部、青海省境内，中国最大的内陆湖、咸水湖。</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1210.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_1214.JPG\" alt></p>\n<p><strong>一路美食相伴</strong></p>\n<p>青棵牛肉面</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/20180922185705.png\" alt></p>\n<p>西藏酸奶</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/20180922201006.png\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0045.JPG\" alt></p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0369.JPG\" alt></p>\n<p>青海羊肉火锅</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/IMG_0762.JPG\" alt></p>\n<p>藏式牛肉炒饭</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0847.JPG\" alt></p>\n<p>藏面</p>\n<p><img src=\"http://pbflin9sq.bkt.clouddn.com/DSC_0853.JPG\" alt></p>\n<p>感谢《1677一路向西》自由行一路相伴的团友，很荣幸认识你们，带给了我一次难忘有意义的旅行，旅途中的我们不畏艰辛，每迈一步走向更高的海拔，只为看到更美的风景，就像人生一样；不断前行，只为见到更美、更优秀的自己；海拔没有巅峰，人生也一样，愿我们的人生步步高升，就像我们这次旅途一样顺畅、风雨无阻。</p>\n<p><a href=\"https://pan.baidu.com/s/1G6Ay9dyShivBhYXhL62dyg\" target=\"_blank\" rel=\"noopener\">照片共享地址:https://pan.baidu.com/s/1G6Ay9dyShivBhYXhL62dyg</a></p>\n<p>​                                                                                                     \t\t\t起伏哥 亲笔</p>\n"},{"title":"KVO的实现原理","date":"2018-08-17T01:47:59.000Z","catagories":["Objective-C"],"_content":"Key Value Observe\n\n### 基本使用：\n\n```objective-c\n@implementation ViewController\n- (void)viewDidLoad {\n[super viewDidLoad];\n\nself.person1 = [[Person alloc] init];\nself.person2 = [[Person alloc] init];\n\n// 给person1对象添加KVO监听\nNSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;\n[self.person1 addObserver:self forKeyPath:@\"age\" options:options context:@\"123\"];\n}\n\n// 当监听对象的属性值发生改变时，就会调用\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context\n{\nNSLog(@\"监听到%@的%@属性值改变了 - %@ - %@\", object, keyPath, change, context);\n}\n```\n\n### 验证其实现\n\n首先我们使用点语言给对象的属性赋值，其实是调用了对象-set...方法；\n\n> 为了验证其实现过程，我们可以现时创建两个类，并监听其中一个类的值改变，然后同时给两对象属性赋亲值，并在set方法和赋值的地址同时打断点，你会发现当第一个obj赋值完后，第二个对象还没有赋值，但监听回调方法就已经执行，说明系统是在-set方法内部做了一些特殊处理；\n\n进一步验证其实现：\n\n> 这一方面没有源码给我们研究，我们只有通过一些调试来猜测他的实现。\n\n1. 先来从对象的内存地址开始，你想进一步的查看它的相关属性都需要它的内存地址、 isa 指针：分别在监听前和后打印下对象的内存地址：\n\n```objective-c\n.......\n//对象的申明和初始化部份的代码我省略了，没有什么特别的，就是正常的申明和初始化实例\n//分别初始化了两上实例对象：person1 和 person2\n.......\n\nNSLog(@\"person1添加KVO监听之前 - %@ - %@\",\nobject_getClass(self.person1),\nobject_getClass(self.person2));\n\n[self.person1 addObserver:self forKeyPath:@\"age\" options:options context:@\"123\"];\n\nNSLog(@\"person1添加KVO监听之后 - %@ - %@\",\nobject_getClass(self.person1),\nobject_getClass(self.person2));\n\n//打印结果：\nperson1添加KVO监听之前 - Person  -  Person\nperson1添加KVO监听之后 - NSKVONotifying_Person  -  Person\n```\n你会发现person1添加监听的，监听后类发生了变化，但这个类并不是我们创建的，可能是系统通过runtime动态创建的.\n\n2. 进一步确认下它的meta-class是谁？\n\n```objective-c\n// 给person1对象添加KVO监听\n[self.person1 addObserver:self forKeyPath:@\"age\" options:options context:@\"123\"];\n\nNSLog(@\"元类对象 - %@ - %@\",\nobject_getClass(object_getClass(self.person1)), // self.person1.isa.isa\nobject_getClass(object_getClass(self.person2))); // self.person2.isa.isa\n\n//打印结果：\n元类对象 - NSKVONotifying_Person  -  Person\n```\n\n我之前的《NSObject本质》文中讲过class的isa指向meta-class，`NSKVONotifying_Person`的元类还是它自己创建的。\n\n3. 通过runtime的函数及lldb打印方法的实现：\n\n```objective-c\nNSLog(@\"person1添加KVO监听之前 - %p %p\",\n[self.person1 methodForSelector:@selector(setAge:)],\n[self.person2 methodForSelector:@selector(setAge:)]);\n\n// 给person1对象添加KVO监听\n[self.person1 addObserver:self forKeyPath:@\"age\" options:options context:@\"123\"];\n\nNSLog(@\"person1添加KVO监听之后 - %p %p\",\n[self.person1 methodForSelector:@selector(setAge:)],\n[self.person2 methodForSelector:@selector(setAge:)]);\n\n//这里打个断点\n\n//打印结果：\nperson1添加KVO监听之前 - 0x10c6535f0 0x10c6535f0\nperson1添加KVO监听之后 - 0x10c9f8f8e 0x10c6535f0\n//通过lldb指使：`p (IMP)对象的IMP的内存地址` 可以打印出其set方法，\n(lldb) p (IMP)0x10c6535f0\n(IMP) $0 = 0x000000010c6535f0 (Interview01`-[MJPerson setAge:] at MJPerson.m:13)\n(lldb) p (IMP)0x10c9f8f8e\n(IMP) $1 = 0x000000010c9f8f8e (Foundation`_NSSetIntValueAndNotify)\n(lldb) \n```\n\n如上分别打印监听前后的IMP的实现，你会发现监听前的set方法还是原来的set方法，但监听后发生了改变，成了`_NSSetIntValueAndNotify`，但我们在第一点的时候确认过，不管监听还是不监听set方法都是一样调了的，但肯定还是在set方法的赋值前后做了什么，现在依然没有确确的结论\n\n4. 我们自己申明一个`NSKVONotifying_Person`类，重写下set方法看会怎么样：\n\n```objective-c\n//ViewController中的代码不变，还是我们第一步所展示的代码，\n//只是在工程新创建了一个NSKVONotifying_Person类，\n//这个类什么都不干，创建好参与编译就可以了\n\n@implementation NSKVONotifying_Person\n- (void)setAge:(int)age {\n}\n@end\n//运行后终端直接报错，如下：\n[general] KVO failed to allocate class pair for name NSKVONotifying_Person, automatic key-value observing will not work for this class\n```\n\n我们自己创建这样一个类后，直接监听失败，因为系统在创建这个类的时候，发现已经创建过了，所以无法创建；到目前为此还是无法抓到更重要的信息\n\n5. 试试能不能通过逆向的一些工具来查看`Foundation.frame`框架的基本实现：\n\n* 我这里通过`Hopper Disassembler v4`工具查看，你也可以通过其实的逆向工具，具体的使用请自行百度，或者查看我的逆向相关文章；\n* 从越狱手机上的目录(如下图1)：`device/System/Library/Caches/com.apple.dyld`上复制出`dyld_shared_cache_arm64`库，然后使用电脑的终端通过指令：`./dsc_extractor dyld_shared_cache_arm64 test`(指令说明：./dsc_extractor固定指令 跟上文件名 然后输出目录)，从中抽取出`Foundation.frame`框架出来。\n* 最后将其抽出的`Foundation.frame`可执行文件拖入`Hopper Disassembler v4`工具上，查找`_NSSetIntValueAndNotify()`这个函数，你会发现有很多类似的函数(如下图2)，而且逆向后的可执行文件也可看到有调用一个`_changedValurForKey:key:key:usingBlock`这样的方法，说明它在这个方法里面确实是有调用值改变时的方法；\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180802224529.png)\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180802225509.png)\n\n* 也可以通过终端命令指令导出符号表，从符号表里面也可能看到：\n\n```objective-c\n//Foundation库下所有的跟ValueAndNotif下相关的函数。\n$nm Foundation | grep ValueAndNotify \n```\n\n6. 通过遍历其类的所有方法列表，把方法打印出来，也可以判定：\n\n```objective-c\n//通过runtime遍历其方法列表\n- (void)printMethodNamesOfClass:(Class)cls {\nunsigned int count;\n// 获得方法数组\nMethod *methodList = class_copyMethodList(cls, &count);\n\n// 存储方法名\nNSMutableString *methodNames = [NSMutableString string];\n\n// 遍历所有的方法\nfor (int i = 0; i < count; i++) {\n// 获得方法\nMethod method = methodList[i];\n// 获得方法名\nNSString *methodName = NSStringFromSelector(method_getName(method));\n// 拼接方法名\n[methodNames appendString:methodName];\n[methodNames appendString:@\", \"];\n}\n\n// 释放\nfree(methodList);\n\n// 打印方法名\nNSLog(@\"%@ %@\", cls, methodNames);\n}\n\n- (void)viewDidLoad {\n[super viewDidLoad];\n\n// self.person1 是初始后添加了kvo监听的\n// self.person2 是初始后没有添加监听的\n\n[self printMethodNamesOfClass:object_getClass(self.person1)];\n[self printMethodNamesOfClass:object_getClass(self.person2)];\n}\n\n//打印结果：\n2018-08-08 22:17:51.417379+0800 Interview01[1001:40651] NSKVONotifying_Person setAge:, class, dealloc, _isKVOA,\n2018-08-08 22:17:51.417532+0800 Interview01[1001:40651] Person setAge:, age,\n```\n\n7. 实现结论，及通过上面测试推出的伪代码，如下：\n\n```objective-c\n#import \"NSKVONotifying_Person.h\"\n//继承自我们创建的 `Person`\n@interface NSKVONotifying_Person : Person\n@end\n\n@implementation NSKVONotifying_Person\n\n/// 伪代码\n- (void)setAge:(int)age {\n_NSSetIntValueAndNotify();\n}\n\nvoid _NSSetIntValueAndNotify() {\n[self willChangeValueForKey:@\"age\"];\n[super setAge:age];//这个方法内部会触发kvo的代理方法\n[self didChangeValueForKey:@\"age\"];\n}\n\n- (void)didChangeValueForKey:(NSString *)key {\n// 通知监听器，某某属性值发生了改变\n[oberser observeValueForKeyPath:key ofObject:self change:nil context:nil];\n}\n\n@end\n```\n\n\n\n相关面试题：\n\n1. iOS用什么方式实现对一个对象的KVO（KVO的本质）：\n\n* 利用runtime API动态生成一个子类，并且让instance对象的isa指向这个全新的子类；\n\n* 当修改instance对象的属性的时候，会调用Foundation的_NSSetxxxValueAndNotify函数；\n```objective-c\nwillChangeValueForKey:\n父类原来的setter\ndidChangeVlaueForKey:\ndidChangeVlaueForKey:的内部会触发Oberser的监听方法；\n```\n\n2. 如何手动触发kvo：\n\n```objective-c\n//直接手动调用如下方法：\n[obj willChangeValueForKey:@\"key\"];\n...\n[obj didChangeVlaueForKey:@\"key\"];\n```\n\n3. 直接修改成员变量会触发KVO吗？\n\n不会，必须调用对应的set方法，才会触发KVO；\n\n\n","source":"_posts/KVO实现原理.md","raw":"---\ntitle: KVO的实现原理\ndate: 2018-08-17 09:47:59\ncatagories:\n  - Objective-C\ntags:\n  - NSObject\n  - 底层原理\n---\nKey Value Observe\n\n### 基本使用：\n\n```objective-c\n@implementation ViewController\n- (void)viewDidLoad {\n[super viewDidLoad];\n\nself.person1 = [[Person alloc] init];\nself.person2 = [[Person alloc] init];\n\n// 给person1对象添加KVO监听\nNSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;\n[self.person1 addObserver:self forKeyPath:@\"age\" options:options context:@\"123\"];\n}\n\n// 当监听对象的属性值发生改变时，就会调用\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context\n{\nNSLog(@\"监听到%@的%@属性值改变了 - %@ - %@\", object, keyPath, change, context);\n}\n```\n\n### 验证其实现\n\n首先我们使用点语言给对象的属性赋值，其实是调用了对象-set...方法；\n\n> 为了验证其实现过程，我们可以现时创建两个类，并监听其中一个类的值改变，然后同时给两对象属性赋亲值，并在set方法和赋值的地址同时打断点，你会发现当第一个obj赋值完后，第二个对象还没有赋值，但监听回调方法就已经执行，说明系统是在-set方法内部做了一些特殊处理；\n\n进一步验证其实现：\n\n> 这一方面没有源码给我们研究，我们只有通过一些调试来猜测他的实现。\n\n1. 先来从对象的内存地址开始，你想进一步的查看它的相关属性都需要它的内存地址、 isa 指针：分别在监听前和后打印下对象的内存地址：\n\n```objective-c\n.......\n//对象的申明和初始化部份的代码我省略了，没有什么特别的，就是正常的申明和初始化实例\n//分别初始化了两上实例对象：person1 和 person2\n.......\n\nNSLog(@\"person1添加KVO监听之前 - %@ - %@\",\nobject_getClass(self.person1),\nobject_getClass(self.person2));\n\n[self.person1 addObserver:self forKeyPath:@\"age\" options:options context:@\"123\"];\n\nNSLog(@\"person1添加KVO监听之后 - %@ - %@\",\nobject_getClass(self.person1),\nobject_getClass(self.person2));\n\n//打印结果：\nperson1添加KVO监听之前 - Person  -  Person\nperson1添加KVO监听之后 - NSKVONotifying_Person  -  Person\n```\n你会发现person1添加监听的，监听后类发生了变化，但这个类并不是我们创建的，可能是系统通过runtime动态创建的.\n\n2. 进一步确认下它的meta-class是谁？\n\n```objective-c\n// 给person1对象添加KVO监听\n[self.person1 addObserver:self forKeyPath:@\"age\" options:options context:@\"123\"];\n\nNSLog(@\"元类对象 - %@ - %@\",\nobject_getClass(object_getClass(self.person1)), // self.person1.isa.isa\nobject_getClass(object_getClass(self.person2))); // self.person2.isa.isa\n\n//打印结果：\n元类对象 - NSKVONotifying_Person  -  Person\n```\n\n我之前的《NSObject本质》文中讲过class的isa指向meta-class，`NSKVONotifying_Person`的元类还是它自己创建的。\n\n3. 通过runtime的函数及lldb打印方法的实现：\n\n```objective-c\nNSLog(@\"person1添加KVO监听之前 - %p %p\",\n[self.person1 methodForSelector:@selector(setAge:)],\n[self.person2 methodForSelector:@selector(setAge:)]);\n\n// 给person1对象添加KVO监听\n[self.person1 addObserver:self forKeyPath:@\"age\" options:options context:@\"123\"];\n\nNSLog(@\"person1添加KVO监听之后 - %p %p\",\n[self.person1 methodForSelector:@selector(setAge:)],\n[self.person2 methodForSelector:@selector(setAge:)]);\n\n//这里打个断点\n\n//打印结果：\nperson1添加KVO监听之前 - 0x10c6535f0 0x10c6535f0\nperson1添加KVO监听之后 - 0x10c9f8f8e 0x10c6535f0\n//通过lldb指使：`p (IMP)对象的IMP的内存地址` 可以打印出其set方法，\n(lldb) p (IMP)0x10c6535f0\n(IMP) $0 = 0x000000010c6535f0 (Interview01`-[MJPerson setAge:] at MJPerson.m:13)\n(lldb) p (IMP)0x10c9f8f8e\n(IMP) $1 = 0x000000010c9f8f8e (Foundation`_NSSetIntValueAndNotify)\n(lldb) \n```\n\n如上分别打印监听前后的IMP的实现，你会发现监听前的set方法还是原来的set方法，但监听后发生了改变，成了`_NSSetIntValueAndNotify`，但我们在第一点的时候确认过，不管监听还是不监听set方法都是一样调了的，但肯定还是在set方法的赋值前后做了什么，现在依然没有确确的结论\n\n4. 我们自己申明一个`NSKVONotifying_Person`类，重写下set方法看会怎么样：\n\n```objective-c\n//ViewController中的代码不变，还是我们第一步所展示的代码，\n//只是在工程新创建了一个NSKVONotifying_Person类，\n//这个类什么都不干，创建好参与编译就可以了\n\n@implementation NSKVONotifying_Person\n- (void)setAge:(int)age {\n}\n@end\n//运行后终端直接报错，如下：\n[general] KVO failed to allocate class pair for name NSKVONotifying_Person, automatic key-value observing will not work for this class\n```\n\n我们自己创建这样一个类后，直接监听失败，因为系统在创建这个类的时候，发现已经创建过了，所以无法创建；到目前为此还是无法抓到更重要的信息\n\n5. 试试能不能通过逆向的一些工具来查看`Foundation.frame`框架的基本实现：\n\n* 我这里通过`Hopper Disassembler v4`工具查看，你也可以通过其实的逆向工具，具体的使用请自行百度，或者查看我的逆向相关文章；\n* 从越狱手机上的目录(如下图1)：`device/System/Library/Caches/com.apple.dyld`上复制出`dyld_shared_cache_arm64`库，然后使用电脑的终端通过指令：`./dsc_extractor dyld_shared_cache_arm64 test`(指令说明：./dsc_extractor固定指令 跟上文件名 然后输出目录)，从中抽取出`Foundation.frame`框架出来。\n* 最后将其抽出的`Foundation.frame`可执行文件拖入`Hopper Disassembler v4`工具上，查找`_NSSetIntValueAndNotify()`这个函数，你会发现有很多类似的函数(如下图2)，而且逆向后的可执行文件也可看到有调用一个`_changedValurForKey:key:key:usingBlock`这样的方法，说明它在这个方法里面确实是有调用值改变时的方法；\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180802224529.png)\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180802225509.png)\n\n* 也可以通过终端命令指令导出符号表，从符号表里面也可能看到：\n\n```objective-c\n//Foundation库下所有的跟ValueAndNotif下相关的函数。\n$nm Foundation | grep ValueAndNotify \n```\n\n6. 通过遍历其类的所有方法列表，把方法打印出来，也可以判定：\n\n```objective-c\n//通过runtime遍历其方法列表\n- (void)printMethodNamesOfClass:(Class)cls {\nunsigned int count;\n// 获得方法数组\nMethod *methodList = class_copyMethodList(cls, &count);\n\n// 存储方法名\nNSMutableString *methodNames = [NSMutableString string];\n\n// 遍历所有的方法\nfor (int i = 0; i < count; i++) {\n// 获得方法\nMethod method = methodList[i];\n// 获得方法名\nNSString *methodName = NSStringFromSelector(method_getName(method));\n// 拼接方法名\n[methodNames appendString:methodName];\n[methodNames appendString:@\", \"];\n}\n\n// 释放\nfree(methodList);\n\n// 打印方法名\nNSLog(@\"%@ %@\", cls, methodNames);\n}\n\n- (void)viewDidLoad {\n[super viewDidLoad];\n\n// self.person1 是初始后添加了kvo监听的\n// self.person2 是初始后没有添加监听的\n\n[self printMethodNamesOfClass:object_getClass(self.person1)];\n[self printMethodNamesOfClass:object_getClass(self.person2)];\n}\n\n//打印结果：\n2018-08-08 22:17:51.417379+0800 Interview01[1001:40651] NSKVONotifying_Person setAge:, class, dealloc, _isKVOA,\n2018-08-08 22:17:51.417532+0800 Interview01[1001:40651] Person setAge:, age,\n```\n\n7. 实现结论，及通过上面测试推出的伪代码，如下：\n\n```objective-c\n#import \"NSKVONotifying_Person.h\"\n//继承自我们创建的 `Person`\n@interface NSKVONotifying_Person : Person\n@end\n\n@implementation NSKVONotifying_Person\n\n/// 伪代码\n- (void)setAge:(int)age {\n_NSSetIntValueAndNotify();\n}\n\nvoid _NSSetIntValueAndNotify() {\n[self willChangeValueForKey:@\"age\"];\n[super setAge:age];//这个方法内部会触发kvo的代理方法\n[self didChangeValueForKey:@\"age\"];\n}\n\n- (void)didChangeValueForKey:(NSString *)key {\n// 通知监听器，某某属性值发生了改变\n[oberser observeValueForKeyPath:key ofObject:self change:nil context:nil];\n}\n\n@end\n```\n\n\n\n相关面试题：\n\n1. iOS用什么方式实现对一个对象的KVO（KVO的本质）：\n\n* 利用runtime API动态生成一个子类，并且让instance对象的isa指向这个全新的子类；\n\n* 当修改instance对象的属性的时候，会调用Foundation的_NSSetxxxValueAndNotify函数；\n```objective-c\nwillChangeValueForKey:\n父类原来的setter\ndidChangeVlaueForKey:\ndidChangeVlaueForKey:的内部会触发Oberser的监听方法；\n```\n\n2. 如何手动触发kvo：\n\n```objective-c\n//直接手动调用如下方法：\n[obj willChangeValueForKey:@\"key\"];\n...\n[obj didChangeVlaueForKey:@\"key\"];\n```\n\n3. 直接修改成员变量会触发KVO吗？\n\n不会，必须调用对应的set方法，才会触发KVO；\n\n\n","slug":"KVO实现原理","published":1,"updated":"2019-02-23T05:39:00.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsh3gt6c0015ncezai2002ny","content":"<p>Key Value Observe</p>\n<h3><span id=\"基本使用\">基本使用：</span></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation ViewController</span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">[super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">self.person1 = [[Person alloc] init];</span><br><span class=\"line\">self.person2 = [[Person alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">// 给person1对象添加KVO监听</span><br><span class=\"line\">NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class=\"line\">[self.person1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 当监听对象的属性值发生改变时，就会调用</span><br><span class=\"line\">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">NSLog(@&quot;监听到%@的%@属性值改变了 - %@ - %@&quot;, object, keyPath, change, context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"验证其实现\">验证其实现</span></h3>\n<p>首先我们使用点语言给对象的属性赋值，其实是调用了对象-set…方法；</p>\n<blockquote>\n<p>为了验证其实现过程，我们可以现时创建两个类，并监听其中一个类的值改变，然后同时给两对象属性赋亲值，并在set方法和赋值的地址同时打断点，你会发现当第一个obj赋值完后，第二个对象还没有赋值，但监听回调方法就已经执行，说明系统是在-set方法内部做了一些特殊处理；</p>\n</blockquote>\n<p>进一步验证其实现：</p>\n<blockquote>\n<p>这一方面没有源码给我们研究，我们只有通过一些调试来猜测他的实现。</p>\n</blockquote>\n<ol>\n<li>先来从对象的内存地址开始，你想进一步的查看它的相关属性都需要它的内存地址、 isa 指针：分别在监听前和后打印下对象的内存地址：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.......</span><br><span class=\"line\">//对象的申明和初始化部份的代码我省略了，没有什么特别的，就是正常的申明和初始化实例</span><br><span class=\"line\">//分别初始化了两上实例对象：person1 和 person2</span><br><span class=\"line\">.......</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;person1添加KVO监听之前 - %@ - %@&quot;,</span><br><span class=\"line\">object_getClass(self.person1),</span><br><span class=\"line\">object_getClass(self.person2));</span><br><span class=\"line\"></span><br><span class=\"line\">[self.person1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;person1添加KVO监听之后 - %@ - %@&quot;,</span><br><span class=\"line\">object_getClass(self.person1),</span><br><span class=\"line\">object_getClass(self.person2));</span><br><span class=\"line\"></span><br><span class=\"line\">//打印结果：</span><br><span class=\"line\">person1添加KVO监听之前 - Person  -  Person</span><br><span class=\"line\">person1添加KVO监听之后 - NSKVONotifying_Person  -  Person</span><br></pre></td></tr></table></figure>\n<p>你会发现person1添加监听的，监听后类发生了变化，但这个类并不是我们创建的，可能是系统通过runtime动态创建的.</p>\n<ol start=\"2\">\n<li>进一步确认下它的meta-class是谁？</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 给person1对象添加KVO监听</span><br><span class=\"line\">[self.person1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;元类对象 - %@ - %@&quot;,</span><br><span class=\"line\">object_getClass(object_getClass(self.person1)), // self.person1.isa.isa</span><br><span class=\"line\">object_getClass(object_getClass(self.person2))); // self.person2.isa.isa</span><br><span class=\"line\"></span><br><span class=\"line\">//打印结果：</span><br><span class=\"line\">元类对象 - NSKVONotifying_Person  -  Person</span><br></pre></td></tr></table></figure>\n<p>我之前的《NSObject本质》文中讲过class的isa指向meta-class，<code>NSKVONotifying_Person</code>的元类还是它自己创建的。</p>\n<ol start=\"3\">\n<li>通过runtime的函数及lldb打印方法的实现：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSLog(@&quot;person1添加KVO监听之前 - %p %p&quot;,</span><br><span class=\"line\">[self.person1 methodForSelector:@selector(setAge:)],</span><br><span class=\"line\">[self.person2 methodForSelector:@selector(setAge:)]);</span><br><span class=\"line\"></span><br><span class=\"line\">// 给person1对象添加KVO监听</span><br><span class=\"line\">[self.person1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;person1添加KVO监听之后 - %p %p&quot;,</span><br><span class=\"line\">[self.person1 methodForSelector:@selector(setAge:)],</span><br><span class=\"line\">[self.person2 methodForSelector:@selector(setAge:)]);</span><br><span class=\"line\"></span><br><span class=\"line\">//这里打个断点</span><br><span class=\"line\"></span><br><span class=\"line\">//打印结果：</span><br><span class=\"line\">person1添加KVO监听之前 - 0x10c6535f0 0x10c6535f0</span><br><span class=\"line\">person1添加KVO监听之后 - 0x10c9f8f8e 0x10c6535f0</span><br><span class=\"line\">//通过lldb指使：`p (IMP)对象的IMP的内存地址` 可以打印出其set方法，</span><br><span class=\"line\">(lldb) p (IMP)0x10c6535f0</span><br><span class=\"line\">(IMP) $0 = 0x000000010c6535f0 (Interview01`-[MJPerson setAge:] at MJPerson.m:13)</span><br><span class=\"line\">(lldb) p (IMP)0x10c9f8f8e</span><br><span class=\"line\">(IMP) $1 = 0x000000010c9f8f8e (Foundation`_NSSetIntValueAndNotify)</span><br><span class=\"line\">(lldb)</span><br></pre></td></tr></table></figure>\n<p>如上分别打印监听前后的IMP的实现，你会发现监听前的set方法还是原来的set方法，但监听后发生了改变，成了<code>_NSSetIntValueAndNotify</code>，但我们在第一点的时候确认过，不管监听还是不监听set方法都是一样调了的，但肯定还是在set方法的赋值前后做了什么，现在依然没有确确的结论</p>\n<ol start=\"4\">\n<li>我们自己申明一个<code>NSKVONotifying_Person</code>类，重写下set方法看会怎么样：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ViewController中的代码不变，还是我们第一步所展示的代码，</span><br><span class=\"line\">//只是在工程新创建了一个NSKVONotifying_Person类，</span><br><span class=\"line\">//这个类什么都不干，创建好参与编译就可以了</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation NSKVONotifying_Person</span><br><span class=\"line\">- (void)setAge:(int)age &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\">//运行后终端直接报错，如下：</span><br><span class=\"line\">[general] KVO failed to allocate class pair for name NSKVONotifying_Person, automatic key-value observing will not work for this class</span><br></pre></td></tr></table></figure>\n<p>我们自己创建这样一个类后，直接监听失败，因为系统在创建这个类的时候，发现已经创建过了，所以无法创建；到目前为此还是无法抓到更重要的信息</p>\n<ol start=\"5\">\n<li>试试能不能通过逆向的一些工具来查看<code>Foundation.frame</code>框架的基本实现：</li>\n</ol>\n<ul>\n<li>我这里通过<code>Hopper Disassembler v4</code>工具查看，你也可以通过其实的逆向工具，具体的使用请自行百度，或者查看我的逆向相关文章；</li>\n<li>从越狱手机上的目录(如下图1)：<code>device/System/Library/Caches/com.apple.dyld</code>上复制出<code>dyld_shared_cache_arm64</code>库，然后使用电脑的终端通过指令：<code>./dsc_extractor dyld_shared_cache_arm64 test</code>(指令说明：./dsc_extractor固定指令 跟上文件名 然后输出目录)，从中抽取出<code>Foundation.frame</code>框架出来。</li>\n<li>最后将其抽出的<code>Foundation.frame</code>可执行文件拖入<code>Hopper Disassembler v4</code>工具上，查找<code>_NSSetIntValueAndNotify()</code>这个函数，你会发现有很多类似的函数(如下图2)，而且逆向后的可执行文件也可看到有调用一个<code>_changedValurForKey:key:key:usingBlock</code>这样的方法，说明它在这个方法里面确实是有调用值改变时的方法；</li>\n</ul>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180802224529.png\" alt></p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180802225509.png\" alt></p>\n<ul>\n<li>也可以通过终端命令指令导出符号表，从符号表里面也可能看到：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Foundation库下所有的跟ValueAndNotif下相关的函数。</span><br><span class=\"line\">$nm Foundation | grep ValueAndNotify</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>通过遍历其类的所有方法列表，把方法打印出来，也可以判定：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//通过runtime遍历其方法列表</span><br><span class=\"line\">- (void)printMethodNamesOfClass:(Class)cls &#123;</span><br><span class=\"line\">unsigned int count;</span><br><span class=\"line\">// 获得方法数组</span><br><span class=\"line\">Method *methodList = class_copyMethodList(cls, &amp;count);</span><br><span class=\"line\"></span><br><span class=\"line\">// 存储方法名</span><br><span class=\"line\">NSMutableString *methodNames = [NSMutableString string];</span><br><span class=\"line\"></span><br><span class=\"line\">// 遍历所有的方法</span><br><span class=\"line\">for (int i = 0; i &lt; count; i++) &#123;</span><br><span class=\"line\">// 获得方法</span><br><span class=\"line\">Method method = methodList[i];</span><br><span class=\"line\">// 获得方法名</span><br><span class=\"line\">NSString *methodName = NSStringFromSelector(method_getName(method));</span><br><span class=\"line\">// 拼接方法名</span><br><span class=\"line\">[methodNames appendString:methodName];</span><br><span class=\"line\">[methodNames appendString:@&quot;, &quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 释放</span><br><span class=\"line\">free(methodList);</span><br><span class=\"line\"></span><br><span class=\"line\">// 打印方法名</span><br><span class=\"line\">NSLog(@&quot;%@ %@&quot;, cls, methodNames);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">[super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">// self.person1 是初始后添加了kvo监听的</span><br><span class=\"line\">// self.person2 是初始后没有添加监听的</span><br><span class=\"line\"></span><br><span class=\"line\">[self printMethodNamesOfClass:object_getClass(self.person1)];</span><br><span class=\"line\">[self printMethodNamesOfClass:object_getClass(self.person2)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//打印结果：</span><br><span class=\"line\">2018-08-08 22:17:51.417379+0800 Interview01[1001:40651] NSKVONotifying_Person setAge:, class, dealloc, _isKVOA,</span><br><span class=\"line\">2018-08-08 22:17:51.417532+0800 Interview01[1001:40651] Person setAge:, age,</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>实现结论，及通过上面测试推出的伪代码，如下：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;NSKVONotifying_Person.h&quot;</span><br><span class=\"line\">//继承自我们创建的 `Person`</span><br><span class=\"line\">@interface NSKVONotifying_Person : Person</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation NSKVONotifying_Person</span><br><span class=\"line\"></span><br><span class=\"line\">/// 伪代码</span><br><span class=\"line\">- (void)setAge:(int)age &#123;</span><br><span class=\"line\">_NSSetIntValueAndNotify();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void _NSSetIntValueAndNotify() &#123;</span><br><span class=\"line\">[self willChangeValueForKey:@&quot;age&quot;];</span><br><span class=\"line\">[super setAge:age];//这个方法内部会触发kvo的代理方法</span><br><span class=\"line\">[self didChangeValueForKey:@&quot;age&quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)didChangeValueForKey:(NSString *)key &#123;</span><br><span class=\"line\">// 通知监听器，某某属性值发生了改变</span><br><span class=\"line\">[oberser observeValueForKeyPath:key ofObject:self change:nil context:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>相关面试题：</p>\n<ol>\n<li>iOS用什么方式实现对一个对象的KVO（KVO的本质）：</li>\n</ol>\n<ul>\n<li>\n<p>利用runtime API动态生成一个子类，并且让instance对象的isa指向这个全新的子类；</p>\n</li>\n<li>\n<p>当修改instance对象的属性的时候，会调用Foundation的_NSSetxxxValueAndNotify函数；</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">willChangeValueForKey:</span><br><span class=\"line\">父类原来的setter</span><br><span class=\"line\">didChangeVlaueForKey:</span><br><span class=\"line\">didChangeVlaueForKey:的内部会触发Oberser的监听方法；</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>如何手动触发kvo：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//直接手动调用如下方法：</span><br><span class=\"line\">[obj willChangeValueForKey:@&quot;key&quot;];</span><br><span class=\"line\">...</span><br><span class=\"line\">[obj didChangeVlaueForKey:@&quot;key&quot;];</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>直接修改成员变量会触发KVO吗？</li>\n</ol>\n<p>不会，必须调用对应的set方法，才会触发KVO；</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Key Value Observe</p>\n<h3>基本使用：</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation ViewController</span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">[super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">self.person1 = [[Person alloc] init];</span><br><span class=\"line\">self.person2 = [[Person alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">// 给person1对象添加KVO监听</span><br><span class=\"line\">NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class=\"line\">[self.person1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 当监听对象的属性值发生改变时，就会调用</span><br><span class=\"line\">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">NSLog(@&quot;监听到%@的%@属性值改变了 - %@ - %@&quot;, object, keyPath, change, context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>验证其实现</h3>\n<p>首先我们使用点语言给对象的属性赋值，其实是调用了对象-set…方法；</p>\n<blockquote>\n<p>为了验证其实现过程，我们可以现时创建两个类，并监听其中一个类的值改变，然后同时给两对象属性赋亲值，并在set方法和赋值的地址同时打断点，你会发现当第一个obj赋值完后，第二个对象还没有赋值，但监听回调方法就已经执行，说明系统是在-set方法内部做了一些特殊处理；</p>\n</blockquote>\n<p>进一步验证其实现：</p>\n<blockquote>\n<p>这一方面没有源码给我们研究，我们只有通过一些调试来猜测他的实现。</p>\n</blockquote>\n<ol>\n<li>先来从对象的内存地址开始，你想进一步的查看它的相关属性都需要它的内存地址、 isa 指针：分别在监听前和后打印下对象的内存地址：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.......</span><br><span class=\"line\">//对象的申明和初始化部份的代码我省略了，没有什么特别的，就是正常的申明和初始化实例</span><br><span class=\"line\">//分别初始化了两上实例对象：person1 和 person2</span><br><span class=\"line\">.......</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;person1添加KVO监听之前 - %@ - %@&quot;,</span><br><span class=\"line\">object_getClass(self.person1),</span><br><span class=\"line\">object_getClass(self.person2));</span><br><span class=\"line\"></span><br><span class=\"line\">[self.person1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;person1添加KVO监听之后 - %@ - %@&quot;,</span><br><span class=\"line\">object_getClass(self.person1),</span><br><span class=\"line\">object_getClass(self.person2));</span><br><span class=\"line\"></span><br><span class=\"line\">//打印结果：</span><br><span class=\"line\">person1添加KVO监听之前 - Person  -  Person</span><br><span class=\"line\">person1添加KVO监听之后 - NSKVONotifying_Person  -  Person</span><br></pre></td></tr></table></figure>\n<p>你会发现person1添加监听的，监听后类发生了变化，但这个类并不是我们创建的，可能是系统通过runtime动态创建的.</p>\n<ol start=\"2\">\n<li>进一步确认下它的meta-class是谁？</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 给person1对象添加KVO监听</span><br><span class=\"line\">[self.person1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;元类对象 - %@ - %@&quot;,</span><br><span class=\"line\">object_getClass(object_getClass(self.person1)), // self.person1.isa.isa</span><br><span class=\"line\">object_getClass(object_getClass(self.person2))); // self.person2.isa.isa</span><br><span class=\"line\"></span><br><span class=\"line\">//打印结果：</span><br><span class=\"line\">元类对象 - NSKVONotifying_Person  -  Person</span><br></pre></td></tr></table></figure>\n<p>我之前的《NSObject本质》文中讲过class的isa指向meta-class，<code>NSKVONotifying_Person</code>的元类还是它自己创建的。</p>\n<ol start=\"3\">\n<li>通过runtime的函数及lldb打印方法的实现：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSLog(@&quot;person1添加KVO监听之前 - %p %p&quot;,</span><br><span class=\"line\">[self.person1 methodForSelector:@selector(setAge:)],</span><br><span class=\"line\">[self.person2 methodForSelector:@selector(setAge:)]);</span><br><span class=\"line\"></span><br><span class=\"line\">// 给person1对象添加KVO监听</span><br><span class=\"line\">[self.person1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;person1添加KVO监听之后 - %p %p&quot;,</span><br><span class=\"line\">[self.person1 methodForSelector:@selector(setAge:)],</span><br><span class=\"line\">[self.person2 methodForSelector:@selector(setAge:)]);</span><br><span class=\"line\"></span><br><span class=\"line\">//这里打个断点</span><br><span class=\"line\"></span><br><span class=\"line\">//打印结果：</span><br><span class=\"line\">person1添加KVO监听之前 - 0x10c6535f0 0x10c6535f0</span><br><span class=\"line\">person1添加KVO监听之后 - 0x10c9f8f8e 0x10c6535f0</span><br><span class=\"line\">//通过lldb指使：`p (IMP)对象的IMP的内存地址` 可以打印出其set方法，</span><br><span class=\"line\">(lldb) p (IMP)0x10c6535f0</span><br><span class=\"line\">(IMP) $0 = 0x000000010c6535f0 (Interview01`-[MJPerson setAge:] at MJPerson.m:13)</span><br><span class=\"line\">(lldb) p (IMP)0x10c9f8f8e</span><br><span class=\"line\">(IMP) $1 = 0x000000010c9f8f8e (Foundation`_NSSetIntValueAndNotify)</span><br><span class=\"line\">(lldb)</span><br></pre></td></tr></table></figure>\n<p>如上分别打印监听前后的IMP的实现，你会发现监听前的set方法还是原来的set方法，但监听后发生了改变，成了<code>_NSSetIntValueAndNotify</code>，但我们在第一点的时候确认过，不管监听还是不监听set方法都是一样调了的，但肯定还是在set方法的赋值前后做了什么，现在依然没有确确的结论</p>\n<ol start=\"4\">\n<li>我们自己申明一个<code>NSKVONotifying_Person</code>类，重写下set方法看会怎么样：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ViewController中的代码不变，还是我们第一步所展示的代码，</span><br><span class=\"line\">//只是在工程新创建了一个NSKVONotifying_Person类，</span><br><span class=\"line\">//这个类什么都不干，创建好参与编译就可以了</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation NSKVONotifying_Person</span><br><span class=\"line\">- (void)setAge:(int)age &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\">//运行后终端直接报错，如下：</span><br><span class=\"line\">[general] KVO failed to allocate class pair for name NSKVONotifying_Person, automatic key-value observing will not work for this class</span><br></pre></td></tr></table></figure>\n<p>我们自己创建这样一个类后，直接监听失败，因为系统在创建这个类的时候，发现已经创建过了，所以无法创建；到目前为此还是无法抓到更重要的信息</p>\n<ol start=\"5\">\n<li>试试能不能通过逆向的一些工具来查看<code>Foundation.frame</code>框架的基本实现：</li>\n</ol>\n<ul>\n<li>我这里通过<code>Hopper Disassembler v4</code>工具查看，你也可以通过其实的逆向工具，具体的使用请自行百度，或者查看我的逆向相关文章；</li>\n<li>从越狱手机上的目录(如下图1)：<code>device/System/Library/Caches/com.apple.dyld</code>上复制出<code>dyld_shared_cache_arm64</code>库，然后使用电脑的终端通过指令：<code>./dsc_extractor dyld_shared_cache_arm64 test</code>(指令说明：./dsc_extractor固定指令 跟上文件名 然后输出目录)，从中抽取出<code>Foundation.frame</code>框架出来。</li>\n<li>最后将其抽出的<code>Foundation.frame</code>可执行文件拖入<code>Hopper Disassembler v4</code>工具上，查找<code>_NSSetIntValueAndNotify()</code>这个函数，你会发现有很多类似的函数(如下图2)，而且逆向后的可执行文件也可看到有调用一个<code>_changedValurForKey:key:key:usingBlock</code>这样的方法，说明它在这个方法里面确实是有调用值改变时的方法；</li>\n</ul>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180802224529.png\" alt></p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20180802225509.png\" alt></p>\n<ul>\n<li>也可以通过终端命令指令导出符号表，从符号表里面也可能看到：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Foundation库下所有的跟ValueAndNotif下相关的函数。</span><br><span class=\"line\">$nm Foundation | grep ValueAndNotify</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>通过遍历其类的所有方法列表，把方法打印出来，也可以判定：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//通过runtime遍历其方法列表</span><br><span class=\"line\">- (void)printMethodNamesOfClass:(Class)cls &#123;</span><br><span class=\"line\">unsigned int count;</span><br><span class=\"line\">// 获得方法数组</span><br><span class=\"line\">Method *methodList = class_copyMethodList(cls, &amp;count);</span><br><span class=\"line\"></span><br><span class=\"line\">// 存储方法名</span><br><span class=\"line\">NSMutableString *methodNames = [NSMutableString string];</span><br><span class=\"line\"></span><br><span class=\"line\">// 遍历所有的方法</span><br><span class=\"line\">for (int i = 0; i &lt; count; i++) &#123;</span><br><span class=\"line\">// 获得方法</span><br><span class=\"line\">Method method = methodList[i];</span><br><span class=\"line\">// 获得方法名</span><br><span class=\"line\">NSString *methodName = NSStringFromSelector(method_getName(method));</span><br><span class=\"line\">// 拼接方法名</span><br><span class=\"line\">[methodNames appendString:methodName];</span><br><span class=\"line\">[methodNames appendString:@&quot;, &quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 释放</span><br><span class=\"line\">free(methodList);</span><br><span class=\"line\"></span><br><span class=\"line\">// 打印方法名</span><br><span class=\"line\">NSLog(@&quot;%@ %@&quot;, cls, methodNames);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">[super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">// self.person1 是初始后添加了kvo监听的</span><br><span class=\"line\">// self.person2 是初始后没有添加监听的</span><br><span class=\"line\"></span><br><span class=\"line\">[self printMethodNamesOfClass:object_getClass(self.person1)];</span><br><span class=\"line\">[self printMethodNamesOfClass:object_getClass(self.person2)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//打印结果：</span><br><span class=\"line\">2018-08-08 22:17:51.417379+0800 Interview01[1001:40651] NSKVONotifying_Person setAge:, class, dealloc, _isKVOA,</span><br><span class=\"line\">2018-08-08 22:17:51.417532+0800 Interview01[1001:40651] Person setAge:, age,</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>实现结论，及通过上面测试推出的伪代码，如下：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;NSKVONotifying_Person.h&quot;</span><br><span class=\"line\">//继承自我们创建的 `Person`</span><br><span class=\"line\">@interface NSKVONotifying_Person : Person</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation NSKVONotifying_Person</span><br><span class=\"line\"></span><br><span class=\"line\">/// 伪代码</span><br><span class=\"line\">- (void)setAge:(int)age &#123;</span><br><span class=\"line\">_NSSetIntValueAndNotify();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void _NSSetIntValueAndNotify() &#123;</span><br><span class=\"line\">[self willChangeValueForKey:@&quot;age&quot;];</span><br><span class=\"line\">[super setAge:age];//这个方法内部会触发kvo的代理方法</span><br><span class=\"line\">[self didChangeValueForKey:@&quot;age&quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)didChangeValueForKey:(NSString *)key &#123;</span><br><span class=\"line\">// 通知监听器，某某属性值发生了改变</span><br><span class=\"line\">[oberser observeValueForKeyPath:key ofObject:self change:nil context:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>相关面试题：</p>\n<ol>\n<li>iOS用什么方式实现对一个对象的KVO（KVO的本质）：</li>\n</ol>\n<ul>\n<li>\n<p>利用runtime API动态生成一个子类，并且让instance对象的isa指向这个全新的子类；</p>\n</li>\n<li>\n<p>当修改instance对象的属性的时候，会调用Foundation的_NSSetxxxValueAndNotify函数；</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">willChangeValueForKey:</span><br><span class=\"line\">父类原来的setter</span><br><span class=\"line\">didChangeVlaueForKey:</span><br><span class=\"line\">didChangeVlaueForKey:的内部会触发Oberser的监听方法；</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>如何手动触发kvo：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//直接手动调用如下方法：</span><br><span class=\"line\">[obj willChangeValueForKey:@&quot;key&quot;];</span><br><span class=\"line\">...</span><br><span class=\"line\">[obj didChangeVlaueForKey:@&quot;key&quot;];</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>直接修改成员变量会触发KVO吗？</li>\n</ol>\n<p>不会，必须调用对应的set方法，才会触发KVO；</p>\n"},{"title":"Runtime","catalog":true,"date":"2019-02-22T14:50:41.000Z","subtitle":"__forwarding_ 底层实现解剖","header-img":"note_head_img.jpg","catagories":["Objective-C"],"_content":"\n# runtime\n\n- 什么是Runtime？平时项目中有用过么？\n  - OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行\n  - OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数\n  - 平时编写的OC代码，底层都是转换成了Runtime API进行调用\n- 具体应用\n  - 利用关联对象（AssociatedObject）给分类添加属性\n  - 遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）\n  - 交换方法实现（交换系统的方法）\n  - 利用消息转发机制解决方法找不到的异常问题\n\n### 方法缓存\n\n**缓存策略：方法调用后会存入方法缓存列表，以键值对形式存储，方法地址作为key，具体方法作为值，如果调用的是父类的方法，本类中没有缓存，调用时会缓存到自己的缓存方法列表中；**\n\n**缓存方法查找：先从自己的缓存方法列表中查找，如果没有找到则去一层层的往父类查找，查找到同时会缓存到自己的缓存方法列表里面；**\n\n## objc_msgSend执行流程\n\n> objc_msgSend执行流程可以分为3大阶段:\n>\n> - 消息发送阶段\n> - 动态方法解析阶段\n> - 消息转发阶段\n\n### 一、消息发送阶段：\n\n> OC中的方法调用，其实都是转换为objc_msgSend函数的调用\n>\n> 消息发送阶段：消息接收者通过isa指针找到接收者的类对象，再从接收者的类对象中找到方法实现，找到方法后，还会缓存到方法缓存列表，方便下次调用\n>\n> **注：**如果消息接收者是类对象（调用的是类方法），那么就是：类对象通过父类的isa找到superClass(即元类对象)；类对象的类对象 == 元类对象\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190209184255.png)\n\n### 二、动态方法解析阶段：\n\n> 下图中进入消息发送流程时，如果在动态解析方法做了处理，找到了方法实现，那在调用方法实现的同时还会做方法缓存处理。\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190219225443.png)\n\n```objective-c\n// Method可以理解为等价于struct method_t *\n// struct method_t *otherMethod = (struct method_t *)class_getInstanceMethod(self, @selector(other));\nstruct method_t {\n    SEL sel;\n    char *types;\n    IMP imp;\n}; \n\nvoid c_other(id self, SEL _cmd) {\n    NSLog(@\"c_other - %@ - %@\", self, NSStringFromSelector(_cmd));\n}\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n    if (sel == @selector(test)) {\n        // 动态添加test方法的实现\n        /** 写法一：*/\n        // \"v16@0:8\" 解读：返回值为void，16为这个方法共占用16字节，\n        // @代表第一个参数类型为id类型，0代表@参数从内存的第0个位置开始，:代表第二个参数类型为SEL，:号后面8代表:参数是从内存中的第8个位置开始\n        class_addMethod(self, sel, (IMP)c_other, \"v16@0:8\");\n        \n        /** 写法二：*/\n        // 获取其他方法\n        Method method = class_getInstanceMethod(self, @selector(other));\n        // 动态添加test方法的实现\n        class_addMethod(self, sel,\n                        method_getImplementation(method),\n                        method_getTypeEncoding(method));\n        \n        // 返回YES代表有动态添加方法\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n```\n\n如下图objc源码中可以看出：\n会先判定方法是否动态解析过(triedResolver)，如果没有，则进入动态解析，如果解析过，则进入消息转发流程(_objc_msgForward_impcache)，并缓存方法到缓存方法列表中，便于下次调用；\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190219232606.png)\n\n### 三、消息转发：\n\n动态方法解析阶段没有做处理的时候，会进入消息转发阶段，\n\n- 消息转发\n\n  ```objective-c\n  - (id)forwardingTargetForSelector:(SEL)aSelector\n  {\n      if (aSelector == @selector(test)) {\n          /* 从本质上讲，其实也就是在调用这句代码：\n          objc_msgSend([[Cat alloc] init], aSelector)\n          **/\n          return [[Cat alloc] init];\n      }\n      return [super forwardingTargetForSelector:aSelector];\n  }\n  ```\n\n  如果在- (id)forwardingTargetForSelector:方法还是没有处理，那接下会来到下面的返回方法签名方法\n\n  \n\n- 返回方法签名：- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n\n  只有在返回方法签名的方法中返回了正确的方法签名，否则不会进入下面的方法，一样崩溃\n\n  ```objective-c\n  // 方法签名：返回值类型、参数类型\n  - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n  {\n      if (aSelector == @selector(test)) {\n          //以下两句代码是等价的，参数的占用位置可以省略不写\n          return [NSMethodSignature signatureWithObjCTypes:\"v20@0:8i16\"];\n          return [NSMethodSignature signatureWithObjCTypes:\"v@:i\"];\n          //补充：使用这种方法直接返回也是可以，但前提是Cat对象需要实现对的方法\n          return [[[Cat alloc] init] methodSignatureForSelector:aSelector];\n      }\n      return [super methodSignatureForSelector:aSelector];\n  }\n  ```\n\n  返回了正常方法签名后，必须实现- (void)forwardInvocation:方法\n\n  \n\n- 方法转发处理：- (void)forwardInvocation:(NSInvocation *)anInvocation\n\n  在这个方法中，我们就可以随意处理了，随意处理即：你可以什么事都不做，只实现这个方法就可以了\n\n  ```objective-c\n  /**\n   NSInvocation封装了一个方法调用，包括：方法调用者、方法名、方法参数\n   anInvocation.target 方法调用者\n   anInvocation.selector 方法名\n   [anInvocation getArgument:NULL atIndex:0]\n   */\n  - (void)forwardInvocation:(NSInvocation *)anInvocation\n  {\n  //    转发给Cat对象去处理，当然Cat需要实现了对应的方法，不然还是崩溃\n  //    anInvocation.target = [[Cat alloc] init];\n  //    [anInvocation invoke];\n      //等价上面的代码\n      [anInvocation invokeWithTarget:[[Cat alloc] init]];\n      \n      /* 获取第一个参数\n       atIndex:2 因为第0位是消息接收者，第1位当前的selector，但也不能超出下标，否则崩溃\n       */\n      int value;\n      [anInvocation getArgument:&value atIndex:2];\n      NSLog(@\"argument：%d\", value);\n  }\n  ```\n\n## 类对象的消息转发阶段\n\n- 因为是类方法，所以是+号开头，但直接靠代码自动提示，是没有的，敲不出来的，方法名与实例方法名一样\n\n```objective-c\n+ (id)forwardingTargetForSelector:(SEL)aSelector {\n    // objc_msgSend([[Cat alloc] init], @selector(test))\n    if (aSelector == @selector(test)) {\n        return [Cat class];\n    }\n    return [[Cat alloc] init];\n    return [super forwardingTargetForSelector:aSelector];\n}\n\n+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if (aSelector == @selector(test)) return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];\n    \n    return [super methodSignatureForSelector:aSelector];\n}\n\n+ (void)forwardInvocation:(NSInvocation *)anInvocation {\n    NSLog(@\"abc\");\n}\n```\n\n### 补充内容：从objc的本质去看消息转发实现\n\n- 先来写一段测试代码：\n\n  - 条件1：方法调用者是类对象，调用类方法；\n  - 条件2：在`+forwardingTargetForSelector`中返回一个实例对象(正常情况应该是返回一个类对象);\n  - 条件3：在这个类里面对应的类方法和实例方法都实现，看运行后程序级否调用成功；\n\n  分别有两个类：Cat、Person，然后Person在main函数中调用test方法，Person实现中进行转发\n\n  ```objective-c\n  // Cat\n  @interface Cat : NSObject\n  + (void)test;\n  - (void)test;\n  @end\n  \n  @implementation Cat\n  + (void)test {\n      NSLog(@\"%s\", __func__);\n  }\n  - (void)test {\n      NSLog(@\"%s\", __func__);\n  }\n  @end\n      \n  // Person\n  @interface Person : NSObject\n  + (void)test;\n  @end\n  \n  @implementation Person\n  + (id)forwardingTargetForSelector:(SEL)aSelector {\n      if (aSelector == @selector(test)) return [[Cat alloc] init];\n      return [super forwardingTargetForSelector:aSelector];\n  }\n  @end\n  \n  // main.m\n  int main(int argc, const char * argv[]) {\n      @autoreleasepool {\n         //调用Person类对象的test方法\n          [Person test];\n      }\n      return 0;\n  }\n  ```\n\n  运行后的打印结果是：\n\n  注意：没有崩溃，并成功的调用了-开头的test方法，为什么会这样，我们继续往下看，等下解答\n\n  ```\n  2018-02-21 22:33:51.863918+0800 消息转发[4731:536691] -[Cat test]\n  ```\n\n- `__forwarding__`这一部份的实现是不开源的，只能我们自己去摸索猜测，但有国外的开发者已经按苹果objc源码分析出了`__forwarding__`的内部实现，虽然不能保证是一模一样的，但大致的流程是一致的，如下图是来自国外开发者对其实现的分析的**伪代码**：\n\n  - 在调用`(id)forwardingTargetForSelector:(SEL)aSelector`方法的不管是实例对象对还是类对象，最终都是在调用`objc_msgSend(…)`，所以刚在的现象也就很好的解释了：\n\n    **它的内部不会关心是类还是实例，只关心是谁是消息接收者，消息接收者有没有实现对应的方法。**\n\n  ![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190221214800.png)\n\n###  讲一下 OC 的消息机制\n\n- OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）\n- objc_msgSend底层有3大阶段\n  - 消息发送（缓存列表查找、方法数组查找、父类查找）\n  - 动态方法解析\n  - 消息转发","source":"_posts/Runtime.md","raw":"---\ntitle: Runtime\ncatalog: true\ndate: 2019-02-22 22:50:41\nsubtitle: __forwarding_ 底层实现解剖\nheader-img: note_head_img.jpg\ncatagories:\n  - Objective-C\ntags:\n  - NSObject\n  - 底层原理\n---\n\n# runtime\n\n- 什么是Runtime？平时项目中有用过么？\n  - OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行\n  - OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数\n  - 平时编写的OC代码，底层都是转换成了Runtime API进行调用\n- 具体应用\n  - 利用关联对象（AssociatedObject）给分类添加属性\n  - 遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）\n  - 交换方法实现（交换系统的方法）\n  - 利用消息转发机制解决方法找不到的异常问题\n\n### 方法缓存\n\n**缓存策略：方法调用后会存入方法缓存列表，以键值对形式存储，方法地址作为key，具体方法作为值，如果调用的是父类的方法，本类中没有缓存，调用时会缓存到自己的缓存方法列表中；**\n\n**缓存方法查找：先从自己的缓存方法列表中查找，如果没有找到则去一层层的往父类查找，查找到同时会缓存到自己的缓存方法列表里面；**\n\n## objc_msgSend执行流程\n\n> objc_msgSend执行流程可以分为3大阶段:\n>\n> - 消息发送阶段\n> - 动态方法解析阶段\n> - 消息转发阶段\n\n### 一、消息发送阶段：\n\n> OC中的方法调用，其实都是转换为objc_msgSend函数的调用\n>\n> 消息发送阶段：消息接收者通过isa指针找到接收者的类对象，再从接收者的类对象中找到方法实现，找到方法后，还会缓存到方法缓存列表，方便下次调用\n>\n> **注：**如果消息接收者是类对象（调用的是类方法），那么就是：类对象通过父类的isa找到superClass(即元类对象)；类对象的类对象 == 元类对象\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190209184255.png)\n\n### 二、动态方法解析阶段：\n\n> 下图中进入消息发送流程时，如果在动态解析方法做了处理，找到了方法实现，那在调用方法实现的同时还会做方法缓存处理。\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190219225443.png)\n\n```objective-c\n// Method可以理解为等价于struct method_t *\n// struct method_t *otherMethod = (struct method_t *)class_getInstanceMethod(self, @selector(other));\nstruct method_t {\n    SEL sel;\n    char *types;\n    IMP imp;\n}; \n\nvoid c_other(id self, SEL _cmd) {\n    NSLog(@\"c_other - %@ - %@\", self, NSStringFromSelector(_cmd));\n}\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n    if (sel == @selector(test)) {\n        // 动态添加test方法的实现\n        /** 写法一：*/\n        // \"v16@0:8\" 解读：返回值为void，16为这个方法共占用16字节，\n        // @代表第一个参数类型为id类型，0代表@参数从内存的第0个位置开始，:代表第二个参数类型为SEL，:号后面8代表:参数是从内存中的第8个位置开始\n        class_addMethod(self, sel, (IMP)c_other, \"v16@0:8\");\n        \n        /** 写法二：*/\n        // 获取其他方法\n        Method method = class_getInstanceMethod(self, @selector(other));\n        // 动态添加test方法的实现\n        class_addMethod(self, sel,\n                        method_getImplementation(method),\n                        method_getTypeEncoding(method));\n        \n        // 返回YES代表有动态添加方法\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n```\n\n如下图objc源码中可以看出：\n会先判定方法是否动态解析过(triedResolver)，如果没有，则进入动态解析，如果解析过，则进入消息转发流程(_objc_msgForward_impcache)，并缓存方法到缓存方法列表中，便于下次调用；\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190219232606.png)\n\n### 三、消息转发：\n\n动态方法解析阶段没有做处理的时候，会进入消息转发阶段，\n\n- 消息转发\n\n  ```objective-c\n  - (id)forwardingTargetForSelector:(SEL)aSelector\n  {\n      if (aSelector == @selector(test)) {\n          /* 从本质上讲，其实也就是在调用这句代码：\n          objc_msgSend([[Cat alloc] init], aSelector)\n          **/\n          return [[Cat alloc] init];\n      }\n      return [super forwardingTargetForSelector:aSelector];\n  }\n  ```\n\n  如果在- (id)forwardingTargetForSelector:方法还是没有处理，那接下会来到下面的返回方法签名方法\n\n  \n\n- 返回方法签名：- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n\n  只有在返回方法签名的方法中返回了正确的方法签名，否则不会进入下面的方法，一样崩溃\n\n  ```objective-c\n  // 方法签名：返回值类型、参数类型\n  - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n  {\n      if (aSelector == @selector(test)) {\n          //以下两句代码是等价的，参数的占用位置可以省略不写\n          return [NSMethodSignature signatureWithObjCTypes:\"v20@0:8i16\"];\n          return [NSMethodSignature signatureWithObjCTypes:\"v@:i\"];\n          //补充：使用这种方法直接返回也是可以，但前提是Cat对象需要实现对的方法\n          return [[[Cat alloc] init] methodSignatureForSelector:aSelector];\n      }\n      return [super methodSignatureForSelector:aSelector];\n  }\n  ```\n\n  返回了正常方法签名后，必须实现- (void)forwardInvocation:方法\n\n  \n\n- 方法转发处理：- (void)forwardInvocation:(NSInvocation *)anInvocation\n\n  在这个方法中，我们就可以随意处理了，随意处理即：你可以什么事都不做，只实现这个方法就可以了\n\n  ```objective-c\n  /**\n   NSInvocation封装了一个方法调用，包括：方法调用者、方法名、方法参数\n   anInvocation.target 方法调用者\n   anInvocation.selector 方法名\n   [anInvocation getArgument:NULL atIndex:0]\n   */\n  - (void)forwardInvocation:(NSInvocation *)anInvocation\n  {\n  //    转发给Cat对象去处理，当然Cat需要实现了对应的方法，不然还是崩溃\n  //    anInvocation.target = [[Cat alloc] init];\n  //    [anInvocation invoke];\n      //等价上面的代码\n      [anInvocation invokeWithTarget:[[Cat alloc] init]];\n      \n      /* 获取第一个参数\n       atIndex:2 因为第0位是消息接收者，第1位当前的selector，但也不能超出下标，否则崩溃\n       */\n      int value;\n      [anInvocation getArgument:&value atIndex:2];\n      NSLog(@\"argument：%d\", value);\n  }\n  ```\n\n## 类对象的消息转发阶段\n\n- 因为是类方法，所以是+号开头，但直接靠代码自动提示，是没有的，敲不出来的，方法名与实例方法名一样\n\n```objective-c\n+ (id)forwardingTargetForSelector:(SEL)aSelector {\n    // objc_msgSend([[Cat alloc] init], @selector(test))\n    if (aSelector == @selector(test)) {\n        return [Cat class];\n    }\n    return [[Cat alloc] init];\n    return [super forwardingTargetForSelector:aSelector];\n}\n\n+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if (aSelector == @selector(test)) return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];\n    \n    return [super methodSignatureForSelector:aSelector];\n}\n\n+ (void)forwardInvocation:(NSInvocation *)anInvocation {\n    NSLog(@\"abc\");\n}\n```\n\n### 补充内容：从objc的本质去看消息转发实现\n\n- 先来写一段测试代码：\n\n  - 条件1：方法调用者是类对象，调用类方法；\n  - 条件2：在`+forwardingTargetForSelector`中返回一个实例对象(正常情况应该是返回一个类对象);\n  - 条件3：在这个类里面对应的类方法和实例方法都实现，看运行后程序级否调用成功；\n\n  分别有两个类：Cat、Person，然后Person在main函数中调用test方法，Person实现中进行转发\n\n  ```objective-c\n  // Cat\n  @interface Cat : NSObject\n  + (void)test;\n  - (void)test;\n  @end\n  \n  @implementation Cat\n  + (void)test {\n      NSLog(@\"%s\", __func__);\n  }\n  - (void)test {\n      NSLog(@\"%s\", __func__);\n  }\n  @end\n      \n  // Person\n  @interface Person : NSObject\n  + (void)test;\n  @end\n  \n  @implementation Person\n  + (id)forwardingTargetForSelector:(SEL)aSelector {\n      if (aSelector == @selector(test)) return [[Cat alloc] init];\n      return [super forwardingTargetForSelector:aSelector];\n  }\n  @end\n  \n  // main.m\n  int main(int argc, const char * argv[]) {\n      @autoreleasepool {\n         //调用Person类对象的test方法\n          [Person test];\n      }\n      return 0;\n  }\n  ```\n\n  运行后的打印结果是：\n\n  注意：没有崩溃，并成功的调用了-开头的test方法，为什么会这样，我们继续往下看，等下解答\n\n  ```\n  2018-02-21 22:33:51.863918+0800 消息转发[4731:536691] -[Cat test]\n  ```\n\n- `__forwarding__`这一部份的实现是不开源的，只能我们自己去摸索猜测，但有国外的开发者已经按苹果objc源码分析出了`__forwarding__`的内部实现，虽然不能保证是一模一样的，但大致的流程是一致的，如下图是来自国外开发者对其实现的分析的**伪代码**：\n\n  - 在调用`(id)forwardingTargetForSelector:(SEL)aSelector`方法的不管是实例对象对还是类对象，最终都是在调用`objc_msgSend(…)`，所以刚在的现象也就很好的解释了：\n\n    **它的内部不会关心是类还是实例，只关心是谁是消息接收者，消息接收者有没有实现对应的方法。**\n\n  ![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190221214800.png)\n\n###  讲一下 OC 的消息机制\n\n- OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）\n- objc_msgSend底层有3大阶段\n  - 消息发送（缓存列表查找、方法数组查找、父类查找）\n  - 动态方法解析\n  - 消息转发","slug":"Runtime","published":1,"updated":"2019-02-23T05:39:51.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsh3gt6d0017ncez1q0wlnz3","content":"<h1><span id=\"runtime\">runtime</span></h1>\n<ul>\n<li>什么是Runtime？平时项目中有用过么？\n<ul>\n<li>OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行</li>\n<li>OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数</li>\n<li>平时编写的OC代码，底层都是转换成了Runtime API进行调用</li>\n</ul>\n</li>\n<li>具体应用\n<ul>\n<li>利用关联对象（AssociatedObject）给分类添加属性</li>\n<li>遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）</li>\n<li>交换方法实现（交换系统的方法）</li>\n<li>利用消息转发机制解决方法找不到的异常问题</li>\n</ul>\n</li>\n</ul>\n<h3><span id=\"方法缓存\">方法缓存</span></h3>\n<p><strong>缓存策略：方法调用后会存入方法缓存列表，以键值对形式存储，方法地址作为key，具体方法作为值，如果调用的是父类的方法，本类中没有缓存，调用时会缓存到自己的缓存方法列表中；</strong></p>\n<p><strong>缓存方法查找：先从自己的缓存方法列表中查找，如果没有找到则去一层层的往父类查找，查找到同时会缓存到自己的缓存方法列表里面；</strong></p>\n<h2><span id=\"objc_msgsend执行流程\">objc_msgSend执行流程</span></h2>\n<blockquote>\n<p>objc_msgSend执行流程可以分为3大阶段:</p>\n<ul>\n<li>消息发送阶段</li>\n<li>动态方法解析阶段</li>\n<li>消息转发阶段</li>\n</ul>\n</blockquote>\n<h3><span id=\"一-消息发送阶段\">一、消息发送阶段：</span></h3>\n<blockquote>\n<p>OC中的方法调用，其实都是转换为objc_msgSend函数的调用</p>\n<p>消息发送阶段：消息接收者通过isa指针找到接收者的类对象，再从接收者的类对象中找到方法实现，找到方法后，还会缓存到方法缓存列表，方便下次调用</p>\n<p>**注：**如果消息接收者是类对象（调用的是类方法），那么就是：类对象通过父类的isa找到superClass(即元类对象)；类对象的类对象 == 元类对象</p>\n</blockquote>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190209184255.png\" alt></p>\n<h3><span id=\"二-动态方法解析阶段\">二、动态方法解析阶段：</span></h3>\n<blockquote>\n<p>下图中进入消息发送流程时，如果在动态解析方法做了处理，找到了方法实现，那在调用方法实现的同时还会做方法缓存处理。</p>\n</blockquote>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190219225443.png\" alt></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Method可以理解为等价于struct method_t *</span><br><span class=\"line\">// struct method_t *otherMethod = (struct method_t *)class_getInstanceMethod(self, @selector(other));</span><br><span class=\"line\">struct method_t &#123;</span><br><span class=\"line\">    SEL sel;</span><br><span class=\"line\">    char *types;</span><br><span class=\"line\">    IMP imp;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\">void c_other(id self, SEL _cmd) &#123;</span><br><span class=\"line\">    NSLog(@&quot;c_other - %@ - %@&quot;, self, NSStringFromSelector(_cmd));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class=\"line\">    if (sel == @selector(test)) &#123;</span><br><span class=\"line\">        // 动态添加test方法的实现</span><br><span class=\"line\">        /** 写法一：*/</span><br><span class=\"line\">        // &quot;v16@0:8&quot; 解读：返回值为void，16为这个方法共占用16字节，</span><br><span class=\"line\">        // @代表第一个参数类型为id类型，0代表@参数从内存的第0个位置开始，:代表第二个参数类型为SEL，:号后面8代表:参数是从内存中的第8个位置开始</span><br><span class=\"line\">        class_addMethod(self, sel, (IMP)c_other, &quot;v16@0:8&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        /** 写法二：*/</span><br><span class=\"line\">        // 获取其他方法</span><br><span class=\"line\">        Method method = class_getInstanceMethod(self, @selector(other));</span><br><span class=\"line\">        // 动态添加test方法的实现</span><br><span class=\"line\">        class_addMethod(self, sel,</span><br><span class=\"line\">                        method_getImplementation(method),</span><br><span class=\"line\">                        method_getTypeEncoding(method));</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 返回YES代表有动态添加方法</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [super resolveInstanceMethod:sel];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如下图objc源码中可以看出：<br>\n会先判定方法是否动态解析过(triedResolver)，如果没有，则进入动态解析，如果解析过，则进入消息转发流程(_objc_msgForward_impcache)，并缓存方法到缓存方法列表中，便于下次调用；</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190219232606.png\" alt></p>\n<h3><span id=\"三-消息转发\">三、消息转发：</span></h3>\n<p>动态方法解析阶段没有做处理的时候，会进入消息转发阶段，</p>\n<ul>\n<li>\n<p>消息转发</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (aSelector == @selector(test)) &#123;</span><br><span class=\"line\">        /* 从本质上讲，其实也就是在调用这句代码：</span><br><span class=\"line\">        objc_msgSend([[Cat alloc] init], aSelector)</span><br><span class=\"line\">        **/</span><br><span class=\"line\">        return [[Cat alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [super forwardingTargetForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果在- (id)forwardingTargetForSelector:方法还是没有处理，那接下会来到下面的返回方法签名方法</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>返回方法签名：- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</p>\n<p>只有在返回方法签名的方法中返回了正确的方法签名，否则不会进入下面的方法，一样崩溃</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 方法签名：返回值类型、参数类型</span><br><span class=\"line\">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (aSelector == @selector(test)) &#123;</span><br><span class=\"line\">        //以下两句代码是等价的，参数的占用位置可以省略不写</span><br><span class=\"line\">        return [NSMethodSignature signatureWithObjCTypes:&quot;v20@0:8i16&quot;];</span><br><span class=\"line\">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:i&quot;];</span><br><span class=\"line\">        //补充：使用这种方法直接返回也是可以，但前提是Cat对象需要实现对的方法</span><br><span class=\"line\">        return [[[Cat alloc] init] methodSignatureForSelector:aSelector];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [super methodSignatureForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>返回了正常方法签名后，必须实现- (void)forwardInvocation:方法</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>方法转发处理：- (void)forwardInvocation:(NSInvocation *)anInvocation</p>\n<p>在这个方法中，我们就可以随意处理了，随意处理即：你可以什么事都不做，只实现这个方法就可以了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> NSInvocation封装了一个方法调用，包括：方法调用者、方法名、方法参数</span><br><span class=\"line\"> anInvocation.target 方法调用者</span><br><span class=\"line\"> anInvocation.selector 方法名</span><br><span class=\"line\"> [anInvocation getArgument:NULL atIndex:0]</span><br><span class=\"line\"> */</span><br><span class=\"line\">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">//    转发给Cat对象去处理，当然Cat需要实现了对应的方法，不然还是崩溃</span><br><span class=\"line\">//    anInvocation.target = [[Cat alloc] init];</span><br><span class=\"line\">//    [anInvocation invoke];</span><br><span class=\"line\">    //等价上面的代码</span><br><span class=\"line\">    [anInvocation invokeWithTarget:[[Cat alloc] init]];</span><br><span class=\"line\">    </span><br><span class=\"line\">    /* 获取第一个参数</span><br><span class=\"line\">     atIndex:2 因为第0位是消息接收者，第1位当前的selector，但也不能超出下标，否则崩溃</span><br><span class=\"line\">     */</span><br><span class=\"line\">    int value;</span><br><span class=\"line\">    [anInvocation getArgument:&amp;value atIndex:2];</span><br><span class=\"line\">    NSLog(@&quot;argument：%d&quot;, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2><span id=\"类对象的消息转发阶段\">类对象的消息转发阶段</span></h2>\n<ul>\n<li>因为是类方法，所以是+号开头，但直接靠代码自动提示，是没有的，敲不出来的，方法名与实例方法名一样</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    // objc_msgSend([[Cat alloc] init], @selector(test))</span><br><span class=\"line\">    if (aSelector == @selector(test)) &#123;</span><br><span class=\"line\">        return [Cat class];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [[Cat alloc] init];</span><br><span class=\"line\">    return [super forwardingTargetForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    if (aSelector == @selector(test)) return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    return [super methodSignatureForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class=\"line\">    NSLog(@&quot;abc&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"补充内容从objc的本质去看消息转发实现\">补充内容：从objc的本质去看消息转发实现</span></h3>\n<ul>\n<li>\n<p>先来写一段测试代码：</p>\n<ul>\n<li>条件1：方法调用者是类对象，调用类方法；</li>\n<li>条件2：在<code>+forwardingTargetForSelector</code>中返回一个实例对象(正常情况应该是返回一个类对象);</li>\n<li>条件3：在这个类里面对应的类方法和实例方法都实现，看运行后程序级否调用成功；</li>\n</ul>\n<p>分别有两个类：Cat、Person，然后Person在main函数中调用test方法，Person实现中进行转发</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Cat</span><br><span class=\"line\">@interface Cat : NSObject</span><br><span class=\"line\">+ (void)test;</span><br><span class=\"line\">- (void)test;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Cat</span><br><span class=\"line\">+ (void)test &#123;</span><br><span class=\"line\">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)test &#123;</span><br><span class=\"line\">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\">    </span><br><span class=\"line\">// Person</span><br><span class=\"line\">@interface Person : NSObject</span><br><span class=\"line\">+ (void)test;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\">+ (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    if (aSelector == @selector(test)) return [[Cat alloc] init];</span><br><span class=\"line\">    return [super forwardingTargetForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">// main.m</span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">       //调用Person类对象的test方法</span><br><span class=\"line\">        [Person test];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行后的打印结果是：</p>\n<p>注意：没有崩溃，并成功的调用了-开头的test方法，为什么会这样，我们继续往下看，等下解答</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018<span class=\"selector-tag\">-02-21</span> 22<span class=\"selector-pseudo\">:33</span><span class=\"selector-pseudo\">:51.863918+0800</span> 消息转发<span class=\"selector-attr\">[4731:536691]</span> <span class=\"selector-tag\">-</span><span class=\"selector-attr\">[Cat test]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>__forwarding__</code>这一部份的实现是不开源的，只能我们自己去摸索猜测，但有国外的开发者已经按苹果objc源码分析出了<code>__forwarding__</code>的内部实现，虽然不能保证是一模一样的，但大致的流程是一致的，如下图是来自国外开发者对其实现的分析的<strong>伪代码</strong>：</p>\n<ul>\n<li>\n<p>在调用<code>(id)forwardingTargetForSelector:(SEL)aSelector</code>方法的不管是实例对象对还是类对象，最终都是在调用<code>objc_msgSend(…)</code>，所以刚在的现象也就很好的解释了：</p>\n<p><strong>它的内部不会关心是类还是实例，只关心是谁是消息接收者，消息接收者有没有实现对应的方法。</strong></p>\n</li>\n</ul>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190221214800.png\" alt></p>\n</li>\n</ul>\n<h3><span id=\"讲一下-oc-的消息机制\">讲一下 OC 的消息机制</span></h3>\n<ul>\n<li>OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）</li>\n<li>objc_msgSend底层有3大阶段\n<ul>\n<li>消息发送（缓存列表查找、方法数组查找、父类查找）</li>\n<li>动态方法解析</li>\n<li>消息转发</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>runtime</h1>\n<ul>\n<li>什么是Runtime？平时项目中有用过么？\n<ul>\n<li>OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行</li>\n<li>OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数</li>\n<li>平时编写的OC代码，底层都是转换成了Runtime API进行调用</li>\n</ul>\n</li>\n<li>具体应用\n<ul>\n<li>利用关联对象（AssociatedObject）给分类添加属性</li>\n<li>遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）</li>\n<li>交换方法实现（交换系统的方法）</li>\n<li>利用消息转发机制解决方法找不到的异常问题</li>\n</ul>\n</li>\n</ul>\n<h3>方法缓存</h3>\n<p><strong>缓存策略：方法调用后会存入方法缓存列表，以键值对形式存储，方法地址作为key，具体方法作为值，如果调用的是父类的方法，本类中没有缓存，调用时会缓存到自己的缓存方法列表中；</strong></p>\n<p><strong>缓存方法查找：先从自己的缓存方法列表中查找，如果没有找到则去一层层的往父类查找，查找到同时会缓存到自己的缓存方法列表里面；</strong></p>\n<h2>objc_msgSend执行流程</h2>\n<blockquote>\n<p>objc_msgSend执行流程可以分为3大阶段:</p>\n<ul>\n<li>消息发送阶段</li>\n<li>动态方法解析阶段</li>\n<li>消息转发阶段</li>\n</ul>\n</blockquote>\n<h3>一、消息发送阶段：</h3>\n<blockquote>\n<p>OC中的方法调用，其实都是转换为objc_msgSend函数的调用</p>\n<p>消息发送阶段：消息接收者通过isa指针找到接收者的类对象，再从接收者的类对象中找到方法实现，找到方法后，还会缓存到方法缓存列表，方便下次调用</p>\n<p>**注：**如果消息接收者是类对象（调用的是类方法），那么就是：类对象通过父类的isa找到superClass(即元类对象)；类对象的类对象 == 元类对象</p>\n</blockquote>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190209184255.png\" alt></p>\n<h3>二、动态方法解析阶段：</h3>\n<blockquote>\n<p>下图中进入消息发送流程时，如果在动态解析方法做了处理，找到了方法实现，那在调用方法实现的同时还会做方法缓存处理。</p>\n</blockquote>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190219225443.png\" alt></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Method可以理解为等价于struct method_t *</span><br><span class=\"line\">// struct method_t *otherMethod = (struct method_t *)class_getInstanceMethod(self, @selector(other));</span><br><span class=\"line\">struct method_t &#123;</span><br><span class=\"line\">    SEL sel;</span><br><span class=\"line\">    char *types;</span><br><span class=\"line\">    IMP imp;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\">void c_other(id self, SEL _cmd) &#123;</span><br><span class=\"line\">    NSLog(@&quot;c_other - %@ - %@&quot;, self, NSStringFromSelector(_cmd));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class=\"line\">    if (sel == @selector(test)) &#123;</span><br><span class=\"line\">        // 动态添加test方法的实现</span><br><span class=\"line\">        /** 写法一：*/</span><br><span class=\"line\">        // &quot;v16@0:8&quot; 解读：返回值为void，16为这个方法共占用16字节，</span><br><span class=\"line\">        // @代表第一个参数类型为id类型，0代表@参数从内存的第0个位置开始，:代表第二个参数类型为SEL，:号后面8代表:参数是从内存中的第8个位置开始</span><br><span class=\"line\">        class_addMethod(self, sel, (IMP)c_other, &quot;v16@0:8&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        /** 写法二：*/</span><br><span class=\"line\">        // 获取其他方法</span><br><span class=\"line\">        Method method = class_getInstanceMethod(self, @selector(other));</span><br><span class=\"line\">        // 动态添加test方法的实现</span><br><span class=\"line\">        class_addMethod(self, sel,</span><br><span class=\"line\">                        method_getImplementation(method),</span><br><span class=\"line\">                        method_getTypeEncoding(method));</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 返回YES代表有动态添加方法</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [super resolveInstanceMethod:sel];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如下图objc源码中可以看出：<br>\n会先判定方法是否动态解析过(triedResolver)，如果没有，则进入动态解析，如果解析过，则进入消息转发流程(_objc_msgForward_impcache)，并缓存方法到缓存方法列表中，便于下次调用；</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190219232606.png\" alt></p>\n<h3>三、消息转发：</h3>\n<p>动态方法解析阶段没有做处理的时候，会进入消息转发阶段，</p>\n<ul>\n<li>\n<p>消息转发</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (aSelector == @selector(test)) &#123;</span><br><span class=\"line\">        /* 从本质上讲，其实也就是在调用这句代码：</span><br><span class=\"line\">        objc_msgSend([[Cat alloc] init], aSelector)</span><br><span class=\"line\">        **/</span><br><span class=\"line\">        return [[Cat alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [super forwardingTargetForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果在- (id)forwardingTargetForSelector:方法还是没有处理，那接下会来到下面的返回方法签名方法</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>返回方法签名：- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</p>\n<p>只有在返回方法签名的方法中返回了正确的方法签名，否则不会进入下面的方法，一样崩溃</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 方法签名：返回值类型、参数类型</span><br><span class=\"line\">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (aSelector == @selector(test)) &#123;</span><br><span class=\"line\">        //以下两句代码是等价的，参数的占用位置可以省略不写</span><br><span class=\"line\">        return [NSMethodSignature signatureWithObjCTypes:&quot;v20@0:8i16&quot;];</span><br><span class=\"line\">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:i&quot;];</span><br><span class=\"line\">        //补充：使用这种方法直接返回也是可以，但前提是Cat对象需要实现对的方法</span><br><span class=\"line\">        return [[[Cat alloc] init] methodSignatureForSelector:aSelector];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [super methodSignatureForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>返回了正常方法签名后，必须实现- (void)forwardInvocation:方法</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>方法转发处理：- (void)forwardInvocation:(NSInvocation *)anInvocation</p>\n<p>在这个方法中，我们就可以随意处理了，随意处理即：你可以什么事都不做，只实现这个方法就可以了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> NSInvocation封装了一个方法调用，包括：方法调用者、方法名、方法参数</span><br><span class=\"line\"> anInvocation.target 方法调用者</span><br><span class=\"line\"> anInvocation.selector 方法名</span><br><span class=\"line\"> [anInvocation getArgument:NULL atIndex:0]</span><br><span class=\"line\"> */</span><br><span class=\"line\">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">//    转发给Cat对象去处理，当然Cat需要实现了对应的方法，不然还是崩溃</span><br><span class=\"line\">//    anInvocation.target = [[Cat alloc] init];</span><br><span class=\"line\">//    [anInvocation invoke];</span><br><span class=\"line\">    //等价上面的代码</span><br><span class=\"line\">    [anInvocation invokeWithTarget:[[Cat alloc] init]];</span><br><span class=\"line\">    </span><br><span class=\"line\">    /* 获取第一个参数</span><br><span class=\"line\">     atIndex:2 因为第0位是消息接收者，第1位当前的selector，但也不能超出下标，否则崩溃</span><br><span class=\"line\">     */</span><br><span class=\"line\">    int value;</span><br><span class=\"line\">    [anInvocation getArgument:&amp;value atIndex:2];</span><br><span class=\"line\">    NSLog(@&quot;argument：%d&quot;, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2>类对象的消息转发阶段</h2>\n<ul>\n<li>因为是类方法，所以是+号开头，但直接靠代码自动提示，是没有的，敲不出来的，方法名与实例方法名一样</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    // objc_msgSend([[Cat alloc] init], @selector(test))</span><br><span class=\"line\">    if (aSelector == @selector(test)) &#123;</span><br><span class=\"line\">        return [Cat class];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [[Cat alloc] init];</span><br><span class=\"line\">    return [super forwardingTargetForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    if (aSelector == @selector(test)) return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    return [super methodSignatureForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class=\"line\">    NSLog(@&quot;abc&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>补充内容：从objc的本质去看消息转发实现</h3>\n<ul>\n<li>\n<p>先来写一段测试代码：</p>\n<ul>\n<li>条件1：方法调用者是类对象，调用类方法；</li>\n<li>条件2：在<code>+forwardingTargetForSelector</code>中返回一个实例对象(正常情况应该是返回一个类对象);</li>\n<li>条件3：在这个类里面对应的类方法和实例方法都实现，看运行后程序级否调用成功；</li>\n</ul>\n<p>分别有两个类：Cat、Person，然后Person在main函数中调用test方法，Person实现中进行转发</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Cat</span><br><span class=\"line\">@interface Cat : NSObject</span><br><span class=\"line\">+ (void)test;</span><br><span class=\"line\">- (void)test;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Cat</span><br><span class=\"line\">+ (void)test &#123;</span><br><span class=\"line\">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)test &#123;</span><br><span class=\"line\">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\">    </span><br><span class=\"line\">// Person</span><br><span class=\"line\">@interface Person : NSObject</span><br><span class=\"line\">+ (void)test;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\">+ (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    if (aSelector == @selector(test)) return [[Cat alloc] init];</span><br><span class=\"line\">    return [super forwardingTargetForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">// main.m</span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">       //调用Person类对象的test方法</span><br><span class=\"line\">        [Person test];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行后的打印结果是：</p>\n<p>注意：没有崩溃，并成功的调用了-开头的test方法，为什么会这样，我们继续往下看，等下解答</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018<span class=\"selector-tag\">-02-21</span> 22<span class=\"selector-pseudo\">:33</span><span class=\"selector-pseudo\">:51.863918+0800</span> 消息转发<span class=\"selector-attr\">[4731:536691]</span> <span class=\"selector-tag\">-</span><span class=\"selector-attr\">[Cat test]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>__forwarding__</code>这一部份的实现是不开源的，只能我们自己去摸索猜测，但有国外的开发者已经按苹果objc源码分析出了<code>__forwarding__</code>的内部实现，虽然不能保证是一模一样的，但大致的流程是一致的，如下图是来自国外开发者对其实现的分析的<strong>伪代码</strong>：</p>\n<ul>\n<li>\n<p>在调用<code>(id)forwardingTargetForSelector:(SEL)aSelector</code>方法的不管是实例对象对还是类对象，最终都是在调用<code>objc_msgSend(…)</code>，所以刚在的现象也就很好的解释了：</p>\n<p><strong>它的内部不会关心是类还是实例，只关心是谁是消息接收者，消息接收者有没有实现对应的方法。</strong></p>\n</li>\n</ul>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190221214800.png\" alt></p>\n</li>\n</ul>\n<h3>讲一下 OC 的消息机制</h3>\n<ul>\n<li>OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）</li>\n<li>objc_msgSend底层有3大阶段\n<ul>\n<li>消息发送（缓存列表查找、方法数组查找、父类查找）</li>\n<li>动态方法解析</li>\n<li>消息转发</li>\n</ul>\n</li>\n</ul>\n"},{"title":"iOS-Block本质","catalog":true,"date":"2019-02-22T14:54:34.000Z","subtitle":"Block本质解剖","header-img":"note_head_img.jpg","catagories":["Objective-C"],"_content":"\n## iOS-Block本质\n\n### 本质：\n\n- block本质上也是一个OC对象，它内部也有个isa指针\n\n- block是封装了函数调用以及函数调用环境的OC对象\n\n- block的底层结构如下图二所示\n\n  ![底层结构](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016212502.png)\n\n#### 底层数据结构(底层代码分析)：\n\n- block底层是一个**\\__main_block_impl_0**这样一个结构体，结构体的第一个成员又是一个结构体**\\__block_impl**，这个结构体里面有个isa指针，还有个**FuncPtr**，**FuncPtr**其实就是存放block块里面的代码实现，注意**\\__block_impl  impl**这个不是一个用指针指向**\\__block_impl**，所以相当于**\\__main_block_impl_0**直接拥有**\\__block_impl**这个结构体，**\\__block_impl**里面的每个成员都可看成是**\\__main_block_impl_0**的成员\n\n  ![底层数据结构](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181017205811.png)\n\n### 变量捕获机制\n\n> 为了保证block内部能够正常访问外部的变量，block有个变量捕获机制\n\n- 访问局部 auto 变量\n\n  > blcok内部会自动捕获auto变量当时的值(值传递)，block内部也会生成一个age的成员变量，如下它捕获时是10，所以你后面再改age也不会跟着变化，因为它也是值传递\n\n  ```objective-c\n  int age = 10;\n  block = ^{\n      // age的值捕获进来（capture）\n      NSLog(@\"age is %d\", age);//结果是10\n  };\n  age = 20;\n  ```\n\n- 访问局部 static 变量\n\n  > static修饰局部变量时， 变量生命周期变了(直到程序结束才销毁)，在这种情况下block内部也会捕获变量，但他捕获的不是具体的值了，而是变量的指针\n\n  ```objective-c\n  static int height = 10;\n  block = ^{\n      // age的值捕获进来（capture）\n      NSLog(@\"height is %d\", height);//结果是20\n  };\n  height = 20;\n  ```\n\n- 访问全局变量\n\n  > block内部不会捕获，是在使用时直接访问的\n\n  ```objective-c\n  int age_ = 10;\n  static int height_ = 10;\n  \n  int main(int argc, const char * argv[]) {\n      @autoreleasepool {\n          \n          void (^block)(void) = ^{\n              //打印结果：20, 20\n              NSLog(@\"age is %d, height is %d\", age_, height_);\n          };\n  \n          age_ = 20;\n          height_ = 20;\n  \n          block();\n      }\n      return 0;\n  }\n  ```\n\n- 访问对象的成员变量时\n\n  > 不管是下面那种方式访问，都会捕获self，self他是每个方法都有的隐匿参数，调用者是谁，self就是谁，访问的时候block内部是直接通过self去访问的，内部不会捕获age\n\n  ```objective-c\n  - (void)test\n     block = ^{\n         NSLog(@\"age is %d\", _age);\n         NSLog(@\"age is %d\", [self age]);//self.age\n     };\n  }\n  ```\n\n**变量捕获机制总结，如下图：**\n\n> 也可以自己通过终端 xcrun命令将.m文件转成c++文件，就能看到底层实现\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016212641.png)\n\n  **联想问题：为什么要局部变量时要捕获，全局则不捕获？**\n\n> 1. 首先局部变量的作用域是函数范围内，出了函数，变量就会被销毁，但block存在夸函数调用，这种情况下就无法访问到对应变量了，所以只能把对应变量捕获到block内部；\n> 2. 全局变量在任何位置都可以访问，所以没必要捕获到block内部，直接访问就可以了。\n\n\n\n### Block的种类\n\n- _NSConcreteMallocBlock\n\n> block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型\n\n| **block 类型**                                 | **环境**                    |\n| :--------------------------------------------- | :-------------------------- |\n| \\__NSGlobalBlock__   (\\_NSConcreteGlobalBlock) | 没有访问auto变量            |\n| \\__NSStackBlock__    (\\_NSConcreteStackBlock)  | 访问了auto变量              |\n| \\__NSMallocBlock__   (\\_NSConcreteMallocBlock) | \\__NSStackBlock__调用了copy |\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016212911.png)\n\n> 每一种类型的block调用copy后的结果如下所示\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016213450.png)\n\n### Block 对象类型、auto变量\n\n- ARC环境下：\n\n  > 在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如以下情况\n\n  - block作为函数返回值时\n\n  - 将block赋值给__strong指针时\n\n  - block作为Cocoa API中方法名含有usingBlock的方法参数时(如NSArray的`enumerateObjectsUsingBlock:`方法)\n\n  - block作为GCD API的方法参数时，如下对象Person不会立即释放，而是等3秒后才释放\n\n    ```objective-c\n    -(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {\n        Person *p = [[Person alloc] init];\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n            NSLog(@\"%@\",p);\n        })\n    }\n    ```\n\n  - block内如果访问了对象类型的的自动变量，内部会默认对其强引用，使用修饰符除外\n\n  - 局部的block默认是globalBock，存放在数据区，如果访问了auto变量，block会自动调用copy操作，则变成MallocBlock存放在堆区，待Block出了作用域后，会自动销毁(内部会release操作)\n\n- MRC环境下：\n\n  - 局部的block默认是globalBock，存放在数据区，如果访问了auto变量，则变成stackBlock存放在栈区，需要手动调用block copy操作才会成为MallocBlock\n\n- Block内部结构变化\n\n  - Block内部如果没有访问对象类型，Block的Desc的结构如下：\n\n    ```c++\n    static struct __main_block_desc_0 {\n        size_t reserved;\n        size_t Block_size;\n    }\n    ```\n\n  - Block内部如果访问对象类型，Block的Desc的结构如下：\n\n    > 因为你访问了一个对象，肯定得对对象进行内存管理操作(copy、return、release)，所以需要以下两个函数进行内管理\n\n    ```c++\n    static struct __main_block_desc_0 {\n        size_t reserved;\n        size_t Block_size;\n        void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n        void (*dispose)(struct __main_block_impl_0*);\n    }\n    ```\n\n- 当block内部访问了对象类型的auto变量时\n\n  - 如果block是在栈上，将不会对auto变量产生强引用\n\n- 如果block被拷贝到堆上\n\n  - 会调用block内部的copy函数\n  - copy函数内部会调用_Block_object_assign函数\n  - _Block_object_assign函数会根据auto变量的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用，用\\__\\_block修饰的对象/变量，block内部会强引用他\n\n- 如果block从堆上移除\n\n  - 会调用block内部的dispose函数\n  - dispose函数内部会调用_Block_object_dispose函数\n  - _Block_object_dispose函数会自动释放引用的auto变量（release）\n\n### \\__block修饰符\n\n- __block可以用于解决block内部无法修改auto变量值的问题\n- __block不能修饰全局变量、静态变量（static）\n- 编译器会将__block变量包装成一个对象\n\n\\__block修饰auto变量：会进行包装成结构体，而对应的block内部会含有一个`__Block_byref_age_0`成员，其指针指向那个结构体，结构体如下，下对`age`变量为例：\n\n```c++\nstruct __Block_byref_age_0 {\n\tvoid *_.isa;\n\t__Block_byref__age__0 *__forwarding;\n\tint __flags ;\n\tint __size;\n\tint age;//这个就是被修饰的auto变量\n};\n//这个__forwarding其实指的是自己，目的是为了block从栈拷贝到堆上后跨域访问变量的问题，block从栈拷贝到堆后，就是在栈和堆中各有一块内存，再通过__forwarding去访问，不管变量是在栈还是堆，__forwarding永远者能访问到，如下图：\n```\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181219221215.png)\n\n\\__block修饰对象类型：会进行包装成结构体，而对应的block内部会含有一个`__Block_byref_age_0`成员，其指针指向那个结构体，结构体如下，下面以`Persion`对象为例：\n\n```c++\nstruct __Block_byref_age_0 {\n\tvoid *_.isa;\n\t__Block_byref__age__0 *__forwarding;\n\tint __flags ;\n\tint __size;\n\tvoid (*__Block_byref_id_object_copy)(void*, void*);\n\tvoid (*__Block_byref_id_object_dispose)(void*);\n\tPersion*__strong person;//这个就是被修饰的对象\n};\n\n```\n\n\n\n没有直接修改变量或者对象的内存地址时，是不需要添加__block修饰符的，如下只是在使用array的指针，并没有修改，这种情况下加了反而是一种负担**：\n\n```objective-c\nNSMutableArray *array = [NSMutableArray array];\nBlock block = ^{\n\t[array add0bject :@\"123\"];\n\t[array add0bject :@\"123\"];\n}\n\n```\n\n\n\n### Block的内存管理\n\n- 如果block被拷贝到堆上\n  - 会调用block内部的copy函数\n  - copy函数内部会调用_Block_object_assign函数\n  - _Block_object_assign函数会根据auto变量的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用，用\\__\\_block修饰的对象/变量，block内部会强引用他\n- 如果block从堆上移除\n  - 会调用block内部的dispose函数\n  - dispose函数内部会调用_Block_object_dispose函数\n  - _Block_object_dispose函数会自动释放引用的auto变量（release）\n\n### **解决循环引用问题** **- ARC**\n\n- 用__weak、__unsafe_unretained解决\n- 用__block解决（必须要调用block，然后block内部把对象置nil）\n\n### **解决循环引用问题** **- MRC**\n\n- 用__unsafe_unretained解决\n- 用__block解决(在MRC下block用了\\_\\_block修饰的对象，block内部不会对其对象做return操作)","source":"_posts/iOS-Block本质.md","raw":"---\ntitle: iOS-Block本质\ncatalog: true\ndate: 2019-02-22 22:54:34\nsubtitle: Block本质解剖\nheader-img: note_head_img.jpg\ncatagories:\n  - Objective-C\ntags:\n  - NSObject\n  - 底层原理\n---\n\n## iOS-Block本质\n\n### 本质：\n\n- block本质上也是一个OC对象，它内部也有个isa指针\n\n- block是封装了函数调用以及函数调用环境的OC对象\n\n- block的底层结构如下图二所示\n\n  ![底层结构](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016212502.png)\n\n#### 底层数据结构(底层代码分析)：\n\n- block底层是一个**\\__main_block_impl_0**这样一个结构体，结构体的第一个成员又是一个结构体**\\__block_impl**，这个结构体里面有个isa指针，还有个**FuncPtr**，**FuncPtr**其实就是存放block块里面的代码实现，注意**\\__block_impl  impl**这个不是一个用指针指向**\\__block_impl**，所以相当于**\\__main_block_impl_0**直接拥有**\\__block_impl**这个结构体，**\\__block_impl**里面的每个成员都可看成是**\\__main_block_impl_0**的成员\n\n  ![底层数据结构](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181017205811.png)\n\n### 变量捕获机制\n\n> 为了保证block内部能够正常访问外部的变量，block有个变量捕获机制\n\n- 访问局部 auto 变量\n\n  > blcok内部会自动捕获auto变量当时的值(值传递)，block内部也会生成一个age的成员变量，如下它捕获时是10，所以你后面再改age也不会跟着变化，因为它也是值传递\n\n  ```objective-c\n  int age = 10;\n  block = ^{\n      // age的值捕获进来（capture）\n      NSLog(@\"age is %d\", age);//结果是10\n  };\n  age = 20;\n  ```\n\n- 访问局部 static 变量\n\n  > static修饰局部变量时， 变量生命周期变了(直到程序结束才销毁)，在这种情况下block内部也会捕获变量，但他捕获的不是具体的值了，而是变量的指针\n\n  ```objective-c\n  static int height = 10;\n  block = ^{\n      // age的值捕获进来（capture）\n      NSLog(@\"height is %d\", height);//结果是20\n  };\n  height = 20;\n  ```\n\n- 访问全局变量\n\n  > block内部不会捕获，是在使用时直接访问的\n\n  ```objective-c\n  int age_ = 10;\n  static int height_ = 10;\n  \n  int main(int argc, const char * argv[]) {\n      @autoreleasepool {\n          \n          void (^block)(void) = ^{\n              //打印结果：20, 20\n              NSLog(@\"age is %d, height is %d\", age_, height_);\n          };\n  \n          age_ = 20;\n          height_ = 20;\n  \n          block();\n      }\n      return 0;\n  }\n  ```\n\n- 访问对象的成员变量时\n\n  > 不管是下面那种方式访问，都会捕获self，self他是每个方法都有的隐匿参数，调用者是谁，self就是谁，访问的时候block内部是直接通过self去访问的，内部不会捕获age\n\n  ```objective-c\n  - (void)test\n     block = ^{\n         NSLog(@\"age is %d\", _age);\n         NSLog(@\"age is %d\", [self age]);//self.age\n     };\n  }\n  ```\n\n**变量捕获机制总结，如下图：**\n\n> 也可以自己通过终端 xcrun命令将.m文件转成c++文件，就能看到底层实现\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016212641.png)\n\n  **联想问题：为什么要局部变量时要捕获，全局则不捕获？**\n\n> 1. 首先局部变量的作用域是函数范围内，出了函数，变量就会被销毁，但block存在夸函数调用，这种情况下就无法访问到对应变量了，所以只能把对应变量捕获到block内部；\n> 2. 全局变量在任何位置都可以访问，所以没必要捕获到block内部，直接访问就可以了。\n\n\n\n### Block的种类\n\n- _NSConcreteMallocBlock\n\n> block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型\n\n| **block 类型**                                 | **环境**                    |\n| :--------------------------------------------- | :-------------------------- |\n| \\__NSGlobalBlock__   (\\_NSConcreteGlobalBlock) | 没有访问auto变量            |\n| \\__NSStackBlock__    (\\_NSConcreteStackBlock)  | 访问了auto变量              |\n| \\__NSMallocBlock__   (\\_NSConcreteMallocBlock) | \\__NSStackBlock__调用了copy |\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016212911.png)\n\n> 每一种类型的block调用copy后的结果如下所示\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016213450.png)\n\n### Block 对象类型、auto变量\n\n- ARC环境下：\n\n  > 在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如以下情况\n\n  - block作为函数返回值时\n\n  - 将block赋值给__strong指针时\n\n  - block作为Cocoa API中方法名含有usingBlock的方法参数时(如NSArray的`enumerateObjectsUsingBlock:`方法)\n\n  - block作为GCD API的方法参数时，如下对象Person不会立即释放，而是等3秒后才释放\n\n    ```objective-c\n    -(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {\n        Person *p = [[Person alloc] init];\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n            NSLog(@\"%@\",p);\n        })\n    }\n    ```\n\n  - block内如果访问了对象类型的的自动变量，内部会默认对其强引用，使用修饰符除外\n\n  - 局部的block默认是globalBock，存放在数据区，如果访问了auto变量，block会自动调用copy操作，则变成MallocBlock存放在堆区，待Block出了作用域后，会自动销毁(内部会release操作)\n\n- MRC环境下：\n\n  - 局部的block默认是globalBock，存放在数据区，如果访问了auto变量，则变成stackBlock存放在栈区，需要手动调用block copy操作才会成为MallocBlock\n\n- Block内部结构变化\n\n  - Block内部如果没有访问对象类型，Block的Desc的结构如下：\n\n    ```c++\n    static struct __main_block_desc_0 {\n        size_t reserved;\n        size_t Block_size;\n    }\n    ```\n\n  - Block内部如果访问对象类型，Block的Desc的结构如下：\n\n    > 因为你访问了一个对象，肯定得对对象进行内存管理操作(copy、return、release)，所以需要以下两个函数进行内管理\n\n    ```c++\n    static struct __main_block_desc_0 {\n        size_t reserved;\n        size_t Block_size;\n        void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n        void (*dispose)(struct __main_block_impl_0*);\n    }\n    ```\n\n- 当block内部访问了对象类型的auto变量时\n\n  - 如果block是在栈上，将不会对auto变量产生强引用\n\n- 如果block被拷贝到堆上\n\n  - 会调用block内部的copy函数\n  - copy函数内部会调用_Block_object_assign函数\n  - _Block_object_assign函数会根据auto变量的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用，用\\__\\_block修饰的对象/变量，block内部会强引用他\n\n- 如果block从堆上移除\n\n  - 会调用block内部的dispose函数\n  - dispose函数内部会调用_Block_object_dispose函数\n  - _Block_object_dispose函数会自动释放引用的auto变量（release）\n\n### \\__block修饰符\n\n- __block可以用于解决block内部无法修改auto变量值的问题\n- __block不能修饰全局变量、静态变量（static）\n- 编译器会将__block变量包装成一个对象\n\n\\__block修饰auto变量：会进行包装成结构体，而对应的block内部会含有一个`__Block_byref_age_0`成员，其指针指向那个结构体，结构体如下，下对`age`变量为例：\n\n```c++\nstruct __Block_byref_age_0 {\n\tvoid *_.isa;\n\t__Block_byref__age__0 *__forwarding;\n\tint __flags ;\n\tint __size;\n\tint age;//这个就是被修饰的auto变量\n};\n//这个__forwarding其实指的是自己，目的是为了block从栈拷贝到堆上后跨域访问变量的问题，block从栈拷贝到堆后，就是在栈和堆中各有一块内存，再通过__forwarding去访问，不管变量是在栈还是堆，__forwarding永远者能访问到，如下图：\n```\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181219221215.png)\n\n\\__block修饰对象类型：会进行包装成结构体，而对应的block内部会含有一个`__Block_byref_age_0`成员，其指针指向那个结构体，结构体如下，下面以`Persion`对象为例：\n\n```c++\nstruct __Block_byref_age_0 {\n\tvoid *_.isa;\n\t__Block_byref__age__0 *__forwarding;\n\tint __flags ;\n\tint __size;\n\tvoid (*__Block_byref_id_object_copy)(void*, void*);\n\tvoid (*__Block_byref_id_object_dispose)(void*);\n\tPersion*__strong person;//这个就是被修饰的对象\n};\n\n```\n\n\n\n没有直接修改变量或者对象的内存地址时，是不需要添加__block修饰符的，如下只是在使用array的指针，并没有修改，这种情况下加了反而是一种负担**：\n\n```objective-c\nNSMutableArray *array = [NSMutableArray array];\nBlock block = ^{\n\t[array add0bject :@\"123\"];\n\t[array add0bject :@\"123\"];\n}\n\n```\n\n\n\n### Block的内存管理\n\n- 如果block被拷贝到堆上\n  - 会调用block内部的copy函数\n  - copy函数内部会调用_Block_object_assign函数\n  - _Block_object_assign函数会根据auto变量的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用，用\\__\\_block修饰的对象/变量，block内部会强引用他\n- 如果block从堆上移除\n  - 会调用block内部的dispose函数\n  - dispose函数内部会调用_Block_object_dispose函数\n  - _Block_object_dispose函数会自动释放引用的auto变量（release）\n\n### **解决循环引用问题** **- ARC**\n\n- 用__weak、__unsafe_unretained解决\n- 用__block解决（必须要调用block，然后block内部把对象置nil）\n\n### **解决循环引用问题** **- MRC**\n\n- 用__unsafe_unretained解决\n- 用__block解决(在MRC下block用了\\_\\_block修饰的对象，block内部不会对其对象做return操作)","slug":"iOS-Block本质","published":1,"updated":"2019-02-23T05:38:36.780Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsh3gt6e0019ncezn34suc4o","content":"<h2><span id=\"ios-block本质\">iOS-Block本质</span></h2>\n<h3><span id=\"本质\">本质：</span></h3>\n<ul>\n<li>\n<p>block本质上也是一个OC对象，它内部也有个isa指针</p>\n</li>\n<li>\n<p>block是封装了函数调用以及函数调用环境的OC对象</p>\n</li>\n<li>\n<p>block的底层结构如下图二所示</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016212502.png\" alt=\"底层结构\"></p>\n</li>\n</ul>\n<h4><span id=\"底层数据结构底层代码分析\">底层数据结构(底层代码分析)：</span></h4>\n<ul>\n<li>\n<p>block底层是一个**__main_block_impl_0<strong>这样一个结构体，结构体的第一个成员又是一个结构体</strong>__block_impl**，这个结构体里面有个isa指针，还有个<strong>FuncPtr</strong>，<strong>FuncPtr</strong>其实就是存放block块里面的代码实现，注意**__block_impl  impl<strong>这个不是一个用指针指向</strong>__block_impl**，所以相当于**__main_block_impl_0<strong>直接拥有</strong>__block_impl<strong>这个结构体，</strong>__block_impl<strong>里面的每个成员都可看成是</strong>__main_block_impl_0**的成员</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181017205811.png\" alt=\"底层数据结构\"></p>\n</li>\n</ul>\n<h3><span id=\"变量捕获机制\">变量捕获机制</span></h3>\n<blockquote>\n<p>为了保证block内部能够正常访问外部的变量，block有个变量捕获机制</p>\n</blockquote>\n<ul>\n<li>\n<p>访问局部 auto 变量</p>\n<blockquote>\n<p>blcok内部会自动捕获auto变量当时的值(值传递)，block内部也会生成一个age的成员变量，如下它捕获时是10，所以你后面再改age也不会跟着变化，因为它也是值传递</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age = 10;</span><br><span class=\"line\">block = ^&#123;</span><br><span class=\"line\">    // age的值捕获进来（capture）</span><br><span class=\"line\">    NSLog(@&quot;age is %d&quot;, age);//结果是10</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">age = 20;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>访问局部 static 变量</p>\n<blockquote>\n<p>static修饰局部变量时， 变量生命周期变了(直到程序结束才销毁)，在这种情况下block内部也会捕获变量，但他捕获的不是具体的值了，而是变量的指针</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int height = 10;</span><br><span class=\"line\">block = ^&#123;</span><br><span class=\"line\">    // age的值捕获进来（capture）</span><br><span class=\"line\">    NSLog(@&quot;height is %d&quot;, height);//结果是20</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">height = 20;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>访问全局变量</p>\n<blockquote>\n<p>block内部不会捕获，是在使用时直接访问的</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age_ = 10;</span><br><span class=\"line\">static int height_ = 10;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        void (^block)(void) = ^&#123;</span><br><span class=\"line\">            //打印结果：20, 20</span><br><span class=\"line\">            NSLog(@&quot;age is %d, height is %d&quot;, age_, height_);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        age_ = 20;</span><br><span class=\"line\">        height_ = 20;</span><br><span class=\"line\"></span><br><span class=\"line\">        block();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>访问对象的成员变量时</p>\n<blockquote>\n<p>不管是下面那种方式访问，都会捕获self，self他是每个方法都有的隐匿参数，调用者是谁，self就是谁，访问的时候block内部是直接通过self去访问的，内部不会捕获age</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)test</span><br><span class=\"line\">   block = ^&#123;</span><br><span class=\"line\">       NSLog(@&quot;age is %d&quot;, _age);</span><br><span class=\"line\">       NSLog(@&quot;age is %d&quot;, [self age]);//self.age</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>变量捕获机制总结，如下图：</strong></p>\n<blockquote>\n<p>也可以自己通过终端 xcrun命令将.m文件转成c++文件，就能看到底层实现</p>\n</blockquote>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016212641.png\" alt></p>\n<p><strong>联想问题：为什么要局部变量时要捕获，全局则不捕获？</strong></p>\n<blockquote>\n<ol>\n<li>首先局部变量的作用域是函数范围内，出了函数，变量就会被销毁，但block存在夸函数调用，这种情况下就无法访问到对应变量了，所以只能把对应变量捕获到block内部；</li>\n<li>全局变量在任何位置都可以访问，所以没必要捕获到block内部，直接访问就可以了。</li>\n</ol>\n</blockquote>\n<h3><span id=\"block的种类\">Block的种类</span></h3>\n<ul>\n<li>_NSConcreteMallocBlock</li>\n</ul>\n<blockquote>\n<p>block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>block 类型</strong></th>\n<th style=\"text-align:left\"><strong>环境</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">_<em>NSGlobalBlock</em>_   (_NSConcreteGlobalBlock)</td>\n<td style=\"text-align:left\">没有访问auto变量</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">_<em>NSStackBlock</em>_    (_NSConcreteStackBlock)</td>\n<td style=\"text-align:left\">访问了auto变量</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">_<em>NSMallocBlock</em>_   (_NSConcreteMallocBlock)</td>\n<td style=\"text-align:left\">__NSStackBlock__调用了copy</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016212911.png\" alt></p>\n<blockquote>\n<p>每一种类型的block调用copy后的结果如下所示</p>\n</blockquote>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016213450.png\" alt></p>\n<h3><span id=\"block-对象类型-auto变量\">Block 对象类型、auto变量</span></h3>\n<ul>\n<li>\n<p>ARC环境下：</p>\n<blockquote>\n<p>在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如以下情况</p>\n</blockquote>\n<ul>\n<li>\n<p>block作为函数返回值时</p>\n</li>\n<li>\n<p>将block赋值给__strong指针时</p>\n</li>\n<li>\n<p>block作为Cocoa API中方法名含有usingBlock的方法参数时(如NSArray的<code>enumerateObjectsUsingBlock:</code>方法)</p>\n</li>\n<li>\n<p>block作为GCD API的方法参数时，如下对象Person不会立即释放，而是等3秒后才释放</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class=\"line\">    Person *p = [[Person alloc] init];</span><br><span class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;,p);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>block内如果访问了对象类型的的自动变量，内部会默认对其强引用，使用修饰符除外</p>\n</li>\n<li>\n<p>局部的block默认是globalBock，存放在数据区，如果访问了auto变量，block会自动调用copy操作，则变成MallocBlock存放在堆区，待Block出了作用域后，会自动销毁(内部会release操作)</p>\n</li>\n</ul>\n</li>\n<li>\n<p>MRC环境下：</p>\n<ul>\n<li>局部的block默认是globalBock，存放在数据区，如果访问了auto变量，则变成stackBlock存放在栈区，需要手动调用block copy操作才会成为MallocBlock</li>\n</ul>\n</li>\n<li>\n<p>Block内部结构变化</p>\n<ul>\n<li>\n<p>Block内部如果没有访问对象类型，Block的Desc的结构如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">main_block_desc_0</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> reserved;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> Block_size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>Block内部如果访问对象类型，Block的Desc的结构如下：</p>\n<blockquote>\n<p>因为你访问了一个对象，肯定得对对象进行内存管理操作(copy、return、release)，所以需要以下两个函数进行内管理</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">main_block_desc_0</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> reserved;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> Block_size;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>当block内部访问了对象类型的auto变量时</p>\n<ul>\n<li>如果block是在栈上，将不会对auto变量产生强引用</li>\n</ul>\n</li>\n<li>\n<p>如果block被拷贝到堆上</p>\n<ul>\n<li>会调用block内部的copy函数</li>\n<li>copy函数内部会调用_Block_object_assign函数</li>\n<li>_Block_object_assign函数会根据auto变量的修饰符（__strong、__weak、_<em>unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用，用_</em>_block修饰的对象/变量，block内部会强引用他</li>\n</ul>\n</li>\n<li>\n<p>如果block从堆上移除</p>\n<ul>\n<li>会调用block内部的dispose函数</li>\n<li>dispose函数内部会调用_Block_object_dispose函数</li>\n<li>_Block_object_dispose函数会自动释放引用的auto变量（release）</li>\n</ul>\n</li>\n</ul>\n<h3><span id=\"__block修饰符\">__block修饰符</span></h3>\n<ul>\n<li>__block可以用于解决block内部无法修改auto变量值的问题</li>\n<li>__block不能修饰全局变量、静态变量（static）</li>\n<li>编译器会将__block变量包装成一个对象</li>\n</ul>\n<p>__block修饰auto变量：会进行包装成结构体，而对应的block内部会含有一个<code>__Block_byref_age_0</code>成员，其指针指向那个结构体，结构体如下，下对<code>age</code>变量为例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">Block_byref_age_0</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *_.isa;</span><br><span class=\"line\">\t__Block_byref__age__0 *__forwarding;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> __flags ;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> __size;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;<span class=\"comment\">//这个就是被修饰的auto变量</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//这个__forwarding其实指的是自己，目的是为了block从栈拷贝到堆上后跨域访问变量的问题，block从栈拷贝到堆后，就是在栈和堆中各有一块内存，再通过__forwarding去访问，不管变量是在栈还是堆，__forwarding永远者能访问到，如下图：</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181219221215.png\" alt></p>\n<p>__block修饰对象类型：会进行包装成结构体，而对应的block内部会含有一个<code>__Block_byref_age_0</code>成员，其指针指向那个结构体，结构体如下，下面以<code>Persion</code>对象为例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">Block_byref_age_0</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *_.isa;</span><br><span class=\"line\">\t__Block_byref__age__0 *__forwarding;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> __flags ;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> __size;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*__Block_byref_id_object_copy)(<span class=\"keyword\">void</span>*, <span class=\"keyword\">void</span>*);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*__Block_byref_id_object_dispose)(<span class=\"keyword\">void</span>*);</span><br><span class=\"line\">\tPersion*__strong person;<span class=\"comment\">//这个就是被修饰的对象</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>没有直接修改变量或者对象的内存地址时，是不需要添加__block修饰符的，如下只是在使用array的指针，并没有修改，这种情况下加了反而是一种负担**：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableArray *array = [NSMutableArray array];</span><br><span class=\"line\">Block block = ^&#123;</span><br><span class=\"line\">\t[array add0bject :@&quot;123&quot;];</span><br><span class=\"line\">\t[array add0bject :@&quot;123&quot;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"block的内存管理\">Block的内存管理</span></h3>\n<ul>\n<li>如果block被拷贝到堆上\n<ul>\n<li>会调用block内部的copy函数</li>\n<li>copy函数内部会调用_Block_object_assign函数</li>\n<li>_Block_object_assign函数会根据auto变量的修饰符（__strong、__weak、_<em>unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用，用_</em>_block修饰的对象/变量，block内部会强引用他</li>\n</ul>\n</li>\n<li>如果block从堆上移除\n<ul>\n<li>会调用block内部的dispose函数</li>\n<li>dispose函数内部会调用_Block_object_dispose函数</li>\n<li>_Block_object_dispose函数会自动释放引用的auto变量（release）</li>\n</ul>\n</li>\n</ul>\n<h3><span id=\"解决循环引用问题-arc\"><strong>解决循环引用问题</strong> <strong>- ARC</strong></span></h3>\n<ul>\n<li>用__weak、__unsafe_unretained解决</li>\n<li>用__block解决（必须要调用block，然后block内部把对象置nil）</li>\n</ul>\n<h3><span id=\"解决循环引用问题-mrc\"><strong>解决循环引用问题</strong> <strong>- MRC</strong></span></h3>\n<ul>\n<li>用__unsafe_unretained解决</li>\n<li>用__block解决(在MRC下block用了__block修饰的对象，block内部不会对其对象做return操作)</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>iOS-Block本质</h2>\n<h3>本质：</h3>\n<ul>\n<li>\n<p>block本质上也是一个OC对象，它内部也有个isa指针</p>\n</li>\n<li>\n<p>block是封装了函数调用以及函数调用环境的OC对象</p>\n</li>\n<li>\n<p>block的底层结构如下图二所示</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016212502.png\" alt=\"底层结构\"></p>\n</li>\n</ul>\n<h4>底层数据结构(底层代码分析)：</h4>\n<ul>\n<li>\n<p>block底层是一个**__main_block_impl_0<strong>这样一个结构体，结构体的第一个成员又是一个结构体</strong>__block_impl**，这个结构体里面有个isa指针，还有个<strong>FuncPtr</strong>，<strong>FuncPtr</strong>其实就是存放block块里面的代码实现，注意**__block_impl  impl<strong>这个不是一个用指针指向</strong>__block_impl**，所以相当于**__main_block_impl_0<strong>直接拥有</strong>__block_impl<strong>这个结构体，</strong>__block_impl<strong>里面的每个成员都可看成是</strong>__main_block_impl_0**的成员</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181017205811.png\" alt=\"底层数据结构\"></p>\n</li>\n</ul>\n<h3>变量捕获机制</h3>\n<blockquote>\n<p>为了保证block内部能够正常访问外部的变量，block有个变量捕获机制</p>\n</blockquote>\n<ul>\n<li>\n<p>访问局部 auto 变量</p>\n<blockquote>\n<p>blcok内部会自动捕获auto变量当时的值(值传递)，block内部也会生成一个age的成员变量，如下它捕获时是10，所以你后面再改age也不会跟着变化，因为它也是值传递</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age = 10;</span><br><span class=\"line\">block = ^&#123;</span><br><span class=\"line\">    // age的值捕获进来（capture）</span><br><span class=\"line\">    NSLog(@&quot;age is %d&quot;, age);//结果是10</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">age = 20;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>访问局部 static 变量</p>\n<blockquote>\n<p>static修饰局部变量时， 变量生命周期变了(直到程序结束才销毁)，在这种情况下block内部也会捕获变量，但他捕获的不是具体的值了，而是变量的指针</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int height = 10;</span><br><span class=\"line\">block = ^&#123;</span><br><span class=\"line\">    // age的值捕获进来（capture）</span><br><span class=\"line\">    NSLog(@&quot;height is %d&quot;, height);//结果是20</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">height = 20;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>访问全局变量</p>\n<blockquote>\n<p>block内部不会捕获，是在使用时直接访问的</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age_ = 10;</span><br><span class=\"line\">static int height_ = 10;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        void (^block)(void) = ^&#123;</span><br><span class=\"line\">            //打印结果：20, 20</span><br><span class=\"line\">            NSLog(@&quot;age is %d, height is %d&quot;, age_, height_);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        age_ = 20;</span><br><span class=\"line\">        height_ = 20;</span><br><span class=\"line\"></span><br><span class=\"line\">        block();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>访问对象的成员变量时</p>\n<blockquote>\n<p>不管是下面那种方式访问，都会捕获self，self他是每个方法都有的隐匿参数，调用者是谁，self就是谁，访问的时候block内部是直接通过self去访问的，内部不会捕获age</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)test</span><br><span class=\"line\">   block = ^&#123;</span><br><span class=\"line\">       NSLog(@&quot;age is %d&quot;, _age);</span><br><span class=\"line\">       NSLog(@&quot;age is %d&quot;, [self age]);//self.age</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>变量捕获机制总结，如下图：</strong></p>\n<blockquote>\n<p>也可以自己通过终端 xcrun命令将.m文件转成c++文件，就能看到底层实现</p>\n</blockquote>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016212641.png\" alt></p>\n<p><strong>联想问题：为什么要局部变量时要捕获，全局则不捕获？</strong></p>\n<blockquote>\n<ol>\n<li>首先局部变量的作用域是函数范围内，出了函数，变量就会被销毁，但block存在夸函数调用，这种情况下就无法访问到对应变量了，所以只能把对应变量捕获到block内部；</li>\n<li>全局变量在任何位置都可以访问，所以没必要捕获到block内部，直接访问就可以了。</li>\n</ol>\n</blockquote>\n<h3>Block的种类</h3>\n<ul>\n<li>_NSConcreteMallocBlock</li>\n</ul>\n<blockquote>\n<p>block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>block 类型</strong></th>\n<th style=\"text-align:left\"><strong>环境</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">_<em>NSGlobalBlock</em>_   (_NSConcreteGlobalBlock)</td>\n<td style=\"text-align:left\">没有访问auto变量</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">_<em>NSStackBlock</em>_    (_NSConcreteStackBlock)</td>\n<td style=\"text-align:left\">访问了auto变量</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">_<em>NSMallocBlock</em>_   (_NSConcreteMallocBlock)</td>\n<td style=\"text-align:left\">__NSStackBlock__调用了copy</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016212911.png\" alt></p>\n<blockquote>\n<p>每一种类型的block调用copy后的结果如下所示</p>\n</blockquote>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181016213450.png\" alt></p>\n<h3>Block 对象类型、auto变量</h3>\n<ul>\n<li>\n<p>ARC环境下：</p>\n<blockquote>\n<p>在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如以下情况</p>\n</blockquote>\n<ul>\n<li>\n<p>block作为函数返回值时</p>\n</li>\n<li>\n<p>将block赋值给__strong指针时</p>\n</li>\n<li>\n<p>block作为Cocoa API中方法名含有usingBlock的方法参数时(如NSArray的<code>enumerateObjectsUsingBlock:</code>方法)</p>\n</li>\n<li>\n<p>block作为GCD API的方法参数时，如下对象Person不会立即释放，而是等3秒后才释放</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class=\"line\">    Person *p = [[Person alloc] init];</span><br><span class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;,p);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>block内如果访问了对象类型的的自动变量，内部会默认对其强引用，使用修饰符除外</p>\n</li>\n<li>\n<p>局部的block默认是globalBock，存放在数据区，如果访问了auto变量，block会自动调用copy操作，则变成MallocBlock存放在堆区，待Block出了作用域后，会自动销毁(内部会release操作)</p>\n</li>\n</ul>\n</li>\n<li>\n<p>MRC环境下：</p>\n<ul>\n<li>局部的block默认是globalBock，存放在数据区，如果访问了auto变量，则变成stackBlock存放在栈区，需要手动调用block copy操作才会成为MallocBlock</li>\n</ul>\n</li>\n<li>\n<p>Block内部结构变化</p>\n<ul>\n<li>\n<p>Block内部如果没有访问对象类型，Block的Desc的结构如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">main_block_desc_0</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> reserved;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> Block_size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>Block内部如果访问对象类型，Block的Desc的结构如下：</p>\n<blockquote>\n<p>因为你访问了一个对象，肯定得对对象进行内存管理操作(copy、return、release)，所以需要以下两个函数进行内管理</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">main_block_desc_0</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> reserved;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> Block_size;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>当block内部访问了对象类型的auto变量时</p>\n<ul>\n<li>如果block是在栈上，将不会对auto变量产生强引用</li>\n</ul>\n</li>\n<li>\n<p>如果block被拷贝到堆上</p>\n<ul>\n<li>会调用block内部的copy函数</li>\n<li>copy函数内部会调用_Block_object_assign函数</li>\n<li>_Block_object_assign函数会根据auto变量的修饰符（__strong、__weak、_<em>unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用，用_</em>_block修饰的对象/变量，block内部会强引用他</li>\n</ul>\n</li>\n<li>\n<p>如果block从堆上移除</p>\n<ul>\n<li>会调用block内部的dispose函数</li>\n<li>dispose函数内部会调用_Block_object_dispose函数</li>\n<li>_Block_object_dispose函数会自动释放引用的auto变量（release）</li>\n</ul>\n</li>\n</ul>\n<h3>__block修饰符</h3>\n<ul>\n<li>__block可以用于解决block内部无法修改auto变量值的问题</li>\n<li>__block不能修饰全局变量、静态变量（static）</li>\n<li>编译器会将__block变量包装成一个对象</li>\n</ul>\n<p>__block修饰auto变量：会进行包装成结构体，而对应的block内部会含有一个<code>__Block_byref_age_0</code>成员，其指针指向那个结构体，结构体如下，下对<code>age</code>变量为例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">Block_byref_age_0</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *_.isa;</span><br><span class=\"line\">\t__Block_byref__age__0 *__forwarding;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> __flags ;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> __size;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;<span class=\"comment\">//这个就是被修饰的auto变量</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//这个__forwarding其实指的是自己，目的是为了block从栈拷贝到堆上后跨域访问变量的问题，block从栈拷贝到堆后，就是在栈和堆中各有一块内存，再通过__forwarding去访问，不管变量是在栈还是堆，__forwarding永远者能访问到，如下图：</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20181219221215.png\" alt></p>\n<p>__block修饰对象类型：会进行包装成结构体，而对应的block内部会含有一个<code>__Block_byref_age_0</code>成员，其指针指向那个结构体，结构体如下，下面以<code>Persion</code>对象为例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">Block_byref_age_0</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *_.isa;</span><br><span class=\"line\">\t__Block_byref__age__0 *__forwarding;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> __flags ;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> __size;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*__Block_byref_id_object_copy)(<span class=\"keyword\">void</span>*, <span class=\"keyword\">void</span>*);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*__Block_byref_id_object_dispose)(<span class=\"keyword\">void</span>*);</span><br><span class=\"line\">\tPersion*__strong person;<span class=\"comment\">//这个就是被修饰的对象</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>没有直接修改变量或者对象的内存地址时，是不需要添加__block修饰符的，如下只是在使用array的指针，并没有修改，这种情况下加了反而是一种负担**：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableArray *array = [NSMutableArray array];</span><br><span class=\"line\">Block block = ^&#123;</span><br><span class=\"line\">\t[array add0bject :@&quot;123&quot;];</span><br><span class=\"line\">\t[array add0bject :@&quot;123&quot;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>Block的内存管理</h3>\n<ul>\n<li>如果block被拷贝到堆上\n<ul>\n<li>会调用block内部的copy函数</li>\n<li>copy函数内部会调用_Block_object_assign函数</li>\n<li>_Block_object_assign函数会根据auto变量的修饰符（__strong、__weak、_<em>unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用，用_</em>_block修饰的对象/变量，block内部会强引用他</li>\n</ul>\n</li>\n<li>如果block从堆上移除\n<ul>\n<li>会调用block内部的dispose函数</li>\n<li>dispose函数内部会调用_Block_object_dispose函数</li>\n<li>_Block_object_dispose函数会自动释放引用的auto变量（release）</li>\n</ul>\n</li>\n</ul>\n<h3><strong>解决循环引用问题</strong> <strong>- ARC</strong></h3>\n<ul>\n<li>用__weak、__unsafe_unretained解决</li>\n<li>用__block解决（必须要调用block，然后block内部把对象置nil）</li>\n</ul>\n<h3><strong>解决循环引用问题</strong> <strong>- MRC</strong></h3>\n<ul>\n<li>用__unsafe_unretained解决</li>\n<li>用__block解决(在MRC下block用了__block修饰的对象，block内部不会对其对象做return操作)</li>\n</ul>\n"},{"title":"iOS armv7, armv7s, arm64区别与应用32位、64位配置","catalog":true,"date":"2018-08-29T09:18:39.000Z","subtitle":"详细了解手机架构","header-img":"note_head_img.jpg","catagories":["Objective-C"],"_content":"## iOS armv7, armv7s, arm64区别与应用32位、64位配置\n### 历程\n\n1. 2015年2月1日不允许不支持arm64的应用的提交；\n2. iOS10发布后，如果你的应用中使用到了32位的类、库，没有相应支持64位机型的库，则首次启动后会弹窗式提示：“ xxx可能使iPhone变慢...”；\n3. iOS10.3公测版发布:封杀32位应用；\n4. 苹果系统（iOS7/iOS8-iOS9）,32位的framework和64位的framework是共存的，所以如果所有的应用都是64位的话，系统就自动不加载32位的framework，这样可以少占用资源，另外对运行的速度是有好处的，也就是说，你会感觉手机运行的快了一点。应用在兼容64位系统后，内存的占用肯定会变多一点，不过性能也有相应的提升。\n\n#### 下面了解下64与32位的区别：\n\n##### 数据类型的变化：\n\n1. 在32位的年代，使用的是IPL32的规范，到了64位之后，改成了LP64规范。\n2. 数据类型里面，NSInteger在32位时等同于int，在64位时等同于long，而这个数据结构使用很广，很多不规范的时候会直接和int替换使用，在32位是毫无问题，但在64位时，这就是隐患了。CGFloat也有同样的问题\n3. 如果使用了偏移量来访问struct的项，那么需要认真仔细的检查，其余的还算好，当然如果你用了malloc，那么也请检查一下分配的内存大小，建议是多使用sizeof来帮助计算。\n4. 方法调用上的变化：在64位系统在运行时调用函数和32位系统是不同的。主要的区别在于传递具有可变参数个数的函数的参数时，我们来看下面的代码：\n    ```\n    int fixedFunction(int a, int b);  \n    int variadicFunction(int a, ...); \n       int main  \n    {  \n    int value2 = fixedFunction(5,5);  \n    int value1 = variadicFunction(5,5);  \n    }\n    ```\n    第一个函数是固定传入2个参数，第二个函数是参数个数不定的，在使用中,也\n    传入了2个参数。在32位系统下，这两个函数的参数传递是非常类似的，在64\n    位系统下，这两者就是截然不同了。\n5. 项目中使用的第三方库肯定需要支持64位系统，否则还是白搭。大家需要检查自己使用的第三方的库，看是否支持64位的版本。苹果系统中（iOS7/iOS8-iOS9）,32位的framework和64位的framework是共存的，所以如果所有的应用都是64位的话，系统就自动不加载32位的framework，这样可以少占用资源，另外对运行的速度是有好处的，也就是说，你会感觉手机运行的快了一点。应用在兼容64位系统后，内存的占用肯定会变多一点，不过性能也有相应的提升。\n\n#### 增加应用对64位的支持：\n\n##### 一、配置前确认工作：\n\n如果你不能确定库是否支持了arm64，可以在cmd模式下用file命令来检查一下库文件：\n\n```\n$lipo -info /Users/xxx/NHPushStreamSDK/FFmpeg-iOS/lib/libavcodec.a\n//指令说明：lipo -info 静态库(动态库)文件完整路径\n```\n\narmv7，armv7s和arm64,i386,x86_64这些都代表什么？\n* armv7｜armv7s｜arm64都是ARM处理器的指令集\n* i386｜x86_64 是Mac处理器的指令集\n  <br>\n###### 了解ARM\n__Arm处理器，因为其低功耗和小尺寸而闻名，几乎所有的手机处理器都基于arm，其在嵌入式系统中的应用非常广泛，它的性能在同等功耗产品中也很出色。\n\nArmv6、armv7、armv7s、arm64都是arm处理器的指令集，所有指令集原则上都是向下兼容的，如iPhone4S的CPU默认指令集为armv7指令集，但它同时也兼容armv6指令集，只是使用armv6指令集时无法充分发挥其性能，即无法使用armv7指令集中的新特性，同理，iPhone5的处理器标配armv7s指令集，同时也支持armv7指令集，只是无法进行相关的性能优化，从而导致程序的执行效率没那么高。\n<br>\n\n> 这些指令集在哪些设备中有用到呢？\n\n| arm64     | armv7s    | armv7               |\n| ------------------------------------------ | ------------------------------- | ------------------- |\n| iPhone6s        | iPhone5      | iPhone4             |\n| iphone6s plus          | iPhone5C                        | iPhone4S            |\n| iphone6           | iPad4(iPad with Retina Display) | iPad                |\n| iphone6 plus       |       | iPad2               |\n| iphone5s       |        | iPad3(The New iPad) |\n| iPad Air         |      | iPad mini        |\n| iPad mini2 (iPad mini with Retina Display) |         | iPod Touch 3G       |\n|           |            | iPod Touch4         |\n>i386是针对intel通用微处理器32位处理器\n>x86_64是针对x86架构的64位处理器\n\n>模拟器32位处理器测试需要i386架构，\n>模拟器64位处理器测试需要x86_64架构，\n>真机32位处理器需要armv7,或者armv7s架构，\n>真机64位处理器需要arm64架构。\n\n\n###### Xcode Build Setting中指令集相关选项释义\n1. Architectures\n   指定工程被编译成可支持哪些指令集类型，而支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包会变大(Space-separated list of identifiers. Specifies the architectures (ABIs, processor models) to which the binary is targeted. When this build setting specifies more than one architecture, the generated binary may contain object code for each of the specified architectures. )。\n\n2. Valid Architectures\n   限制可能被支持的指令集的范围，也就是Xcode编译出来的二进制包类型最终从这些类型产生，而编译出哪种指令集的包，将由Architectures与Valid Architectures（因此这个不能为空）的交集来确定(Space-separated list of identifiers. Specifies the architectures for which the binary may be built. During the build, this list is intersected with the value of ARCHS build setting; the resulting list specifies the architectures the binary can run on. If the resulting architecture list is empty, the target generates no binary.)。\n\n3. Build Active Architecture Only\n   指定是否只对当前连接设备所支持的指令集编译\n    当其值设置为YES，这个属性设置为yes，是为了debug的时候编译速度更快，它只编译当前的architecture版本，而设置为no时，会编译所有的版本。 所以，一般debug的时候可以选择设置为yes，release的时候要改为no，以适应不同设备。\n    <br>\n    <br>\n##### 二、工程配置，增加64位的支持\n> note：在Xcode6.1.1及以上 Valid Architectures  设置里， 默认为 Standard architectures(armv7,arm64),如果你想改的话，自己在other中更改。\n\n* 使用 standard architectures (including 64-bit)(armv7,arm64) 参数，则打的包里面有32位、64位两份代码，在iPhone5s（ iPhone5s的cpu是64位的 ）下，会首选运行64位代码包， 其余的iPhone（ 其余iPhone都是32位的,iPhone5c也是32位 ），只能运行32位包，但是包含两种架构的代码包，只有运行在ios6，ios7系统上。 这也就是说，这种打包方式，对手机几乎没要求，但是对系统有要求，即ios6以上。 \n* 使用 standard architectures (armv7,armv7s) 参数， 则打的包里只有32位代码， iPhone5s的cpu是64位，但是可以兼容32位代码，即可以运行32位代码。但是这会降低iPhone5s的性能。 其余的iPhone对32位代码包更没问题， 而32位代码包，对系统也几乎也没什么限制。 \n* 要发挥iPhone5s及以上的64位机型性能，就要包含64位包，那么系统最低要求为ios6。 如果要兼容ios5以及更低的系统，只能打32位的包，系统都能通用，但是会丧失iPhone5s的性能。\n  <br>\n#### Valid Architectures与Architectures指令集交集表：\n| Valid Architectures设置 | Architectures设置    | 生成二进制包支持的指令集(取交集) |\n| ----------------------- | -------------------- | ------------------------------------------- |\n| armv7, armv7s, arm64  |  armv7s   | armv7s  |\n| armv7, armv7s  | armv7s,arm64  |  armv7s   |\n| armv7, armv7s, arm64  |  armv6, armv7s, arm64 | armv7s, arm64                                      |\n| armv6, armv7, armv7s   |  armv6, armv7s, arm64 | armv6, armv7s                               |\n| armv7, arm64 ,armv7s   | armv7, arm64 ,armv7s  | armv7, arm64 ,armv7s |\n| armv7, armv7s, arm64  |  armv7，armv7s  | armv7s, armv7 |\n\n>1. 比如 Valid Architectures设置的支持arm指令集版本有：armv7/armv7s/arm64，对应的Architectures设置的支持arm指令集版本有：armv7s，这时Xcode只会生成一个armv7s指令集的二进制包。\n> 2. xcode默认的设置：\n        **Architectures** : `Strandard architectures - $(ARCHS_STANDARD)` //相当于arm64 armv7s armv7\n       **Valid Architectures** : `arm64 armv7s armv7`\n>3. 如果你对ipa安装包大小有要求，可以减少安装包的指令集的数量，这样就可以尽可能的减少包的大小。\n\n![自定设置](https://upload-images.jianshu.io/upload_images/2443108-7013ad449e239282.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![系统默认设置](https://upload-images.jianshu.io/upload_images/2443108-67cf1a85da78e2d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<br>\n#### 制作静态库.a是指令集选择\n现在回归到正题，如何制作一个“没有问题”的.a静态库，通过以上信息了解到，当我们做App的时候，为了追求高效率，并且减小包的大小，Build Active Architecture Only设置成YES，Architectures按Xcode默认配置就可以，因为arm64向前兼容。但制作.a静态库就不同了，因为要保证兼容性，包括不同iOS设备以及模拟器运行不出错，所以结合当前行业情况，要做到最大的兼容性。\nValidArchitectures设置为：armv7｜armv7s｜arm64｜i386｜x86_64 \nArchitectures设置不变（或根据你需要）:  armv7｜arm64\n然后分别选择iOS设备和模拟器进行编译，最后找到相关的.a进行合包:\n* 合并两个不同构架的库文件\n```\n$ lipo -create /Users/xxxxxx/lib/libv7.a  /Users/xxxxxx/lib/lib64.a  -output /Users/xxxxxx/lib/lib.a\n//指令说明： lipo -create 库文件1一完整路径  库文件2完整路径  -output 输出的文件名路径\n```\n* 从某个库文件中提起出指定构架的库文件\n```\nDesktop$ lipo -thin arm64 debugserver -output debugserver2\n//指令说明：lipo -thin 对应构架指令 对应文件 -output 输出的文件名路径\n```\n使用lipo -create 真机库.a的路径 模拟器库.a的的路径 －output 合成库的名字.a ，这样就制作了一个通用的静态库.a。\n制作动态、静态库详情可以参考[【链接】](http://blog.csdn.NET/lizhongfu2013/article/details/12648633)\n\n\n<br>\n#### 其它注意点：\n1. 因此如果一些程序中使用的静态库不支持armv7s，而你的工程支持armv7s时，就会出现`“xxxx does not contain a(n) armv7s slice:xxxxx for architecture armv7s\"`的编译错误，想要解决这个问题，有两个方法：\n    1. 如果是开源的，能够找到源代码，则可以用源代码重新打一个支持armv7s的libaray, 或者在工程中直接使用源代码，而不是静态库。\n    2. 如果不是开源的，要么就坐等第三方库的支持，要么就暂时让你的工程不支持armv7s。\n2. 此外，模拟器并不运行arm代码，软件会被编译成x86可以运行的指令。所以生成静态库时都是会先生成两个.a，一个是i386的用于在模拟器运行，另一个是在真实设备上运行的，然后再用命令将两个.a合并成一个。\n3. 需要注意的是iOS模拟器没有运行arm指令集，编译运行的是x86指令集，所以，只有在iOS设备上，才会执行设备对应的arm指令集。\n4. 连接的手机指令集匹配是由高到低（arm64 > armv7s > armv7）依次匹配的。\n\n\n[简书链接](https://www.jianshu.com/p/567d3b730608)\n\n部份资源[链接](\nhttp://blog.csdn.net/sakulafly/article/details/41089411)","source":"_posts/iOS-armv7-armv7s-arm64区别与应用32位、64位配置.md","raw":"---\ntitle: 'iOS armv7, armv7s, arm64区别与应用32位、64位配置'\ncatalog: true\ndate: 2018-08-29 17:18:39\nsubtitle: 详细了解手机架构\nheader-img: note_head_img.jpg\ncatagories:\n  - Objective-C\ntags:\n  - NSObject\n  - 底层原理\n---\n## iOS armv7, armv7s, arm64区别与应用32位、64位配置\n### 历程\n\n1. 2015年2月1日不允许不支持arm64的应用的提交；\n2. iOS10发布后，如果你的应用中使用到了32位的类、库，没有相应支持64位机型的库，则首次启动后会弹窗式提示：“ xxx可能使iPhone变慢...”；\n3. iOS10.3公测版发布:封杀32位应用；\n4. 苹果系统（iOS7/iOS8-iOS9）,32位的framework和64位的framework是共存的，所以如果所有的应用都是64位的话，系统就自动不加载32位的framework，这样可以少占用资源，另外对运行的速度是有好处的，也就是说，你会感觉手机运行的快了一点。应用在兼容64位系统后，内存的占用肯定会变多一点，不过性能也有相应的提升。\n\n#### 下面了解下64与32位的区别：\n\n##### 数据类型的变化：\n\n1. 在32位的年代，使用的是IPL32的规范，到了64位之后，改成了LP64规范。\n2. 数据类型里面，NSInteger在32位时等同于int，在64位时等同于long，而这个数据结构使用很广，很多不规范的时候会直接和int替换使用，在32位是毫无问题，但在64位时，这就是隐患了。CGFloat也有同样的问题\n3. 如果使用了偏移量来访问struct的项，那么需要认真仔细的检查，其余的还算好，当然如果你用了malloc，那么也请检查一下分配的内存大小，建议是多使用sizeof来帮助计算。\n4. 方法调用上的变化：在64位系统在运行时调用函数和32位系统是不同的。主要的区别在于传递具有可变参数个数的函数的参数时，我们来看下面的代码：\n    ```\n    int fixedFunction(int a, int b);  \n    int variadicFunction(int a, ...); \n       int main  \n    {  \n    int value2 = fixedFunction(5,5);  \n    int value1 = variadicFunction(5,5);  \n    }\n    ```\n    第一个函数是固定传入2个参数，第二个函数是参数个数不定的，在使用中,也\n    传入了2个参数。在32位系统下，这两个函数的参数传递是非常类似的，在64\n    位系统下，这两者就是截然不同了。\n5. 项目中使用的第三方库肯定需要支持64位系统，否则还是白搭。大家需要检查自己使用的第三方的库，看是否支持64位的版本。苹果系统中（iOS7/iOS8-iOS9）,32位的framework和64位的framework是共存的，所以如果所有的应用都是64位的话，系统就自动不加载32位的framework，这样可以少占用资源，另外对运行的速度是有好处的，也就是说，你会感觉手机运行的快了一点。应用在兼容64位系统后，内存的占用肯定会变多一点，不过性能也有相应的提升。\n\n#### 增加应用对64位的支持：\n\n##### 一、配置前确认工作：\n\n如果你不能确定库是否支持了arm64，可以在cmd模式下用file命令来检查一下库文件：\n\n```\n$lipo -info /Users/xxx/NHPushStreamSDK/FFmpeg-iOS/lib/libavcodec.a\n//指令说明：lipo -info 静态库(动态库)文件完整路径\n```\n\narmv7，armv7s和arm64,i386,x86_64这些都代表什么？\n* armv7｜armv7s｜arm64都是ARM处理器的指令集\n* i386｜x86_64 是Mac处理器的指令集\n  <br>\n###### 了解ARM\n__Arm处理器，因为其低功耗和小尺寸而闻名，几乎所有的手机处理器都基于arm，其在嵌入式系统中的应用非常广泛，它的性能在同等功耗产品中也很出色。\n\nArmv6、armv7、armv7s、arm64都是arm处理器的指令集，所有指令集原则上都是向下兼容的，如iPhone4S的CPU默认指令集为armv7指令集，但它同时也兼容armv6指令集，只是使用armv6指令集时无法充分发挥其性能，即无法使用armv7指令集中的新特性，同理，iPhone5的处理器标配armv7s指令集，同时也支持armv7指令集，只是无法进行相关的性能优化，从而导致程序的执行效率没那么高。\n<br>\n\n> 这些指令集在哪些设备中有用到呢？\n\n| arm64     | armv7s    | armv7               |\n| ------------------------------------------ | ------------------------------- | ------------------- |\n| iPhone6s        | iPhone5      | iPhone4             |\n| iphone6s plus          | iPhone5C                        | iPhone4S            |\n| iphone6           | iPad4(iPad with Retina Display) | iPad                |\n| iphone6 plus       |       | iPad2               |\n| iphone5s       |        | iPad3(The New iPad) |\n| iPad Air         |      | iPad mini        |\n| iPad mini2 (iPad mini with Retina Display) |         | iPod Touch 3G       |\n|           |            | iPod Touch4         |\n>i386是针对intel通用微处理器32位处理器\n>x86_64是针对x86架构的64位处理器\n\n>模拟器32位处理器测试需要i386架构，\n>模拟器64位处理器测试需要x86_64架构，\n>真机32位处理器需要armv7,或者armv7s架构，\n>真机64位处理器需要arm64架构。\n\n\n###### Xcode Build Setting中指令集相关选项释义\n1. Architectures\n   指定工程被编译成可支持哪些指令集类型，而支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包会变大(Space-separated list of identifiers. Specifies the architectures (ABIs, processor models) to which the binary is targeted. When this build setting specifies more than one architecture, the generated binary may contain object code for each of the specified architectures. )。\n\n2. Valid Architectures\n   限制可能被支持的指令集的范围，也就是Xcode编译出来的二进制包类型最终从这些类型产生，而编译出哪种指令集的包，将由Architectures与Valid Architectures（因此这个不能为空）的交集来确定(Space-separated list of identifiers. Specifies the architectures for which the binary may be built. During the build, this list is intersected with the value of ARCHS build setting; the resulting list specifies the architectures the binary can run on. If the resulting architecture list is empty, the target generates no binary.)。\n\n3. Build Active Architecture Only\n   指定是否只对当前连接设备所支持的指令集编译\n    当其值设置为YES，这个属性设置为yes，是为了debug的时候编译速度更快，它只编译当前的architecture版本，而设置为no时，会编译所有的版本。 所以，一般debug的时候可以选择设置为yes，release的时候要改为no，以适应不同设备。\n    <br>\n    <br>\n##### 二、工程配置，增加64位的支持\n> note：在Xcode6.1.1及以上 Valid Architectures  设置里， 默认为 Standard architectures(armv7,arm64),如果你想改的话，自己在other中更改。\n\n* 使用 standard architectures (including 64-bit)(armv7,arm64) 参数，则打的包里面有32位、64位两份代码，在iPhone5s（ iPhone5s的cpu是64位的 ）下，会首选运行64位代码包， 其余的iPhone（ 其余iPhone都是32位的,iPhone5c也是32位 ），只能运行32位包，但是包含两种架构的代码包，只有运行在ios6，ios7系统上。 这也就是说，这种打包方式，对手机几乎没要求，但是对系统有要求，即ios6以上。 \n* 使用 standard architectures (armv7,armv7s) 参数， 则打的包里只有32位代码， iPhone5s的cpu是64位，但是可以兼容32位代码，即可以运行32位代码。但是这会降低iPhone5s的性能。 其余的iPhone对32位代码包更没问题， 而32位代码包，对系统也几乎也没什么限制。 \n* 要发挥iPhone5s及以上的64位机型性能，就要包含64位包，那么系统最低要求为ios6。 如果要兼容ios5以及更低的系统，只能打32位的包，系统都能通用，但是会丧失iPhone5s的性能。\n  <br>\n#### Valid Architectures与Architectures指令集交集表：\n| Valid Architectures设置 | Architectures设置    | 生成二进制包支持的指令集(取交集) |\n| ----------------------- | -------------------- | ------------------------------------------- |\n| armv7, armv7s, arm64  |  armv7s   | armv7s  |\n| armv7, armv7s  | armv7s,arm64  |  armv7s   |\n| armv7, armv7s, arm64  |  armv6, armv7s, arm64 | armv7s, arm64                                      |\n| armv6, armv7, armv7s   |  armv6, armv7s, arm64 | armv6, armv7s                               |\n| armv7, arm64 ,armv7s   | armv7, arm64 ,armv7s  | armv7, arm64 ,armv7s |\n| armv7, armv7s, arm64  |  armv7，armv7s  | armv7s, armv7 |\n\n>1. 比如 Valid Architectures设置的支持arm指令集版本有：armv7/armv7s/arm64，对应的Architectures设置的支持arm指令集版本有：armv7s，这时Xcode只会生成一个armv7s指令集的二进制包。\n> 2. xcode默认的设置：\n        **Architectures** : `Strandard architectures - $(ARCHS_STANDARD)` //相当于arm64 armv7s armv7\n       **Valid Architectures** : `arm64 armv7s armv7`\n>3. 如果你对ipa安装包大小有要求，可以减少安装包的指令集的数量，这样就可以尽可能的减少包的大小。\n\n![自定设置](https://upload-images.jianshu.io/upload_images/2443108-7013ad449e239282.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![系统默认设置](https://upload-images.jianshu.io/upload_images/2443108-67cf1a85da78e2d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<br>\n#### 制作静态库.a是指令集选择\n现在回归到正题，如何制作一个“没有问题”的.a静态库，通过以上信息了解到，当我们做App的时候，为了追求高效率，并且减小包的大小，Build Active Architecture Only设置成YES，Architectures按Xcode默认配置就可以，因为arm64向前兼容。但制作.a静态库就不同了，因为要保证兼容性，包括不同iOS设备以及模拟器运行不出错，所以结合当前行业情况，要做到最大的兼容性。\nValidArchitectures设置为：armv7｜armv7s｜arm64｜i386｜x86_64 \nArchitectures设置不变（或根据你需要）:  armv7｜arm64\n然后分别选择iOS设备和模拟器进行编译，最后找到相关的.a进行合包:\n* 合并两个不同构架的库文件\n```\n$ lipo -create /Users/xxxxxx/lib/libv7.a  /Users/xxxxxx/lib/lib64.a  -output /Users/xxxxxx/lib/lib.a\n//指令说明： lipo -create 库文件1一完整路径  库文件2完整路径  -output 输出的文件名路径\n```\n* 从某个库文件中提起出指定构架的库文件\n```\nDesktop$ lipo -thin arm64 debugserver -output debugserver2\n//指令说明：lipo -thin 对应构架指令 对应文件 -output 输出的文件名路径\n```\n使用lipo -create 真机库.a的路径 模拟器库.a的的路径 －output 合成库的名字.a ，这样就制作了一个通用的静态库.a。\n制作动态、静态库详情可以参考[【链接】](http://blog.csdn.NET/lizhongfu2013/article/details/12648633)\n\n\n<br>\n#### 其它注意点：\n1. 因此如果一些程序中使用的静态库不支持armv7s，而你的工程支持armv7s时，就会出现`“xxxx does not contain a(n) armv7s slice:xxxxx for architecture armv7s\"`的编译错误，想要解决这个问题，有两个方法：\n    1. 如果是开源的，能够找到源代码，则可以用源代码重新打一个支持armv7s的libaray, 或者在工程中直接使用源代码，而不是静态库。\n    2. 如果不是开源的，要么就坐等第三方库的支持，要么就暂时让你的工程不支持armv7s。\n2. 此外，模拟器并不运行arm代码，软件会被编译成x86可以运行的指令。所以生成静态库时都是会先生成两个.a，一个是i386的用于在模拟器运行，另一个是在真实设备上运行的，然后再用命令将两个.a合并成一个。\n3. 需要注意的是iOS模拟器没有运行arm指令集，编译运行的是x86指令集，所以，只有在iOS设备上，才会执行设备对应的arm指令集。\n4. 连接的手机指令集匹配是由高到低（arm64 > armv7s > armv7）依次匹配的。\n\n\n[简书链接](https://www.jianshu.com/p/567d3b730608)\n\n部份资源[链接](\nhttp://blog.csdn.net/sakulafly/article/details/41089411)","slug":"iOS-armv7-armv7s-arm64区别与应用32位、64位配置","published":1,"updated":"2019-02-23T05:40:34.998Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsh3gt6f001bncezpzb128gf","content":"<h2><span id=\"ios-armv7-armv7s-arm64区别与应用32位-64位配置\">iOS armv7, armv7s, arm64区别与应用32位、64位配置</span></h2>\n<h3><span id=\"历程\">历程</span></h3>\n<ol>\n<li>2015年2月1日不允许不支持arm64的应用的提交；</li>\n<li>iOS10发布后，如果你的应用中使用到了32位的类、库，没有相应支持64位机型的库，则首次启动后会弹窗式提示：“ xxx可能使iPhone变慢…”；</li>\n<li>iOS10.3公测版发布:封杀32位应用；</li>\n<li>苹果系统（iOS7/iOS8-iOS9）,32位的framework和64位的framework是共存的，所以如果所有的应用都是64位的话，系统就自动不加载32位的framework，这样可以少占用资源，另外对运行的速度是有好处的，也就是说，你会感觉手机运行的快了一点。应用在兼容64位系统后，内存的占用肯定会变多一点，不过性能也有相应的提升。</li>\n</ol>\n<h4><span id=\"下面了解下64与32位的区别\">下面了解下64与32位的区别：</span></h4>\n<h5><span id=\"数据类型的变化\">数据类型的变化：</span></h5>\n<ol>\n<li>\n<p>在32位的年代，使用的是IPL32的规范，到了64位之后，改成了LP64规范。</p>\n</li>\n<li>\n<p>数据类型里面，NSInteger在32位时等同于int，在64位时等同于long，而这个数据结构使用很广，很多不规范的时候会直接和int替换使用，在32位是毫无问题，但在64位时，这就是隐患了。CGFloat也有同样的问题</p>\n</li>\n<li>\n<p>如果使用了偏移量来访问struct的项，那么需要认真仔细的检查，其余的还算好，当然如果你用了malloc，那么也请检查一下分配的内存大小，建议是多使用sizeof来帮助计算。</p>\n</li>\n<li>\n<p>方法调用上的变化：在64位系统在运行时调用函数和32位系统是不同的。主要的区别在于传递具有可变参数个数的函数的参数时，我们来看下面的代码：</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fixedFunction</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">variadicFunction</span><span class=\"params\">(<span class=\"keyword\">int</span> a, ...)</span></span>; </span><br><span class=\"line\">   <span class=\"keyword\">int</span> main  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\"><span class=\"keyword\">int</span> value2 = fixedFunction(<span class=\"number\">5</span>,<span class=\"number\">5</span>);  </span><br><span class=\"line\"><span class=\"keyword\">int</span> value1 = variadicFunction(<span class=\"number\">5</span>,<span class=\"number\">5</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一个函数是固定传入2个参数，第二个函数是参数个数不定的，在使用中,也<br>\n传入了2个参数。在32位系统下，这两个函数的参数传递是非常类似的，在64<br>\n位系统下，这两者就是截然不同了。</p>\n</li>\n<li>\n<p>项目中使用的第三方库肯定需要支持64位系统，否则还是白搭。大家需要检查自己使用的第三方的库，看是否支持64位的版本。苹果系统中（iOS7/iOS8-iOS9）,32位的framework和64位的framework是共存的，所以如果所有的应用都是64位的话，系统就自动不加载32位的framework，这样可以少占用资源，另外对运行的速度是有好处的，也就是说，你会感觉手机运行的快了一点。应用在兼容64位系统后，内存的占用肯定会变多一点，不过性能也有相应的提升。</p>\n</li>\n</ol>\n<h4><span id=\"增加应用对64位的支持\">增加应用对64位的支持：</span></h4>\n<h5><span id=\"一-配置前确认工作\">一、配置前确认工作：</span></h5>\n<p>如果你不能确定库是否支持了arm64，可以在cmd模式下用file命令来检查一下库文件：</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$lipo -info /Users/xxx/NHPushStreamSDK/FFmpeg-iOS/<span class=\"class\"><span class=\"keyword\">lib</span>/<span class=\"title\">libavcodec</span>.<span class=\"title\">a</span></span></span><br><span class=\"line\">/<span class=\"regexp\">/指令说明：lipo -info 静态库(动态库)文件完整路径</span></span><br></pre></td></tr></table></figure>\n<p>armv7，armv7s和arm64,i386,x86_64这些都代表什么？</p>\n<ul>\n<li>armv7｜armv7s｜arm64都是ARM处理器的指令集</li>\n<li>i386｜x86_64 是Mac处理器的指令集<br>\n<br></li>\n</ul>\n<h6><span id=\"了解arm\">了解ARM</span></h6>\n<p>__Arm处理器，因为其低功耗和小尺寸而闻名，几乎所有的手机处理器都基于arm，其在嵌入式系统中的应用非常广泛，它的性能在同等功耗产品中也很出色。</p>\n<p>Armv6、armv7、armv7s、arm64都是arm处理器的指令集，所有指令集原则上都是向下兼容的，如iPhone4S的CPU默认指令集为armv7指令集，但它同时也兼容armv6指令集，只是使用armv6指令集时无法充分发挥其性能，即无法使用armv7指令集中的新特性，同理，iPhone5的处理器标配armv7s指令集，同时也支持armv7指令集，只是无法进行相关的性能优化，从而导致程序的执行效率没那么高。<br>\n<br></p>\n<blockquote>\n<p>这些指令集在哪些设备中有用到呢？</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>arm64</th>\n<th>armv7s</th>\n<th>armv7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>iPhone6s</td>\n<td>iPhone5</td>\n<td>iPhone4</td>\n</tr>\n<tr>\n<td>iphone6s plus</td>\n<td>iPhone5C</td>\n<td>iPhone4S</td>\n</tr>\n<tr>\n<td>iphone6</td>\n<td>iPad4(iPad with Retina Display)</td>\n<td>iPad</td>\n</tr>\n<tr>\n<td>iphone6 plus</td>\n<td></td>\n<td>iPad2</td>\n</tr>\n<tr>\n<td>iphone5s</td>\n<td></td>\n<td>iPad3(The New iPad)</td>\n</tr>\n<tr>\n<td>iPad Air</td>\n<td></td>\n<td>iPad mini</td>\n</tr>\n<tr>\n<td>iPad mini2 (iPad mini with Retina Display)</td>\n<td></td>\n<td>iPod Touch 3G</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>iPod Touch4</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>i386是针对intel通用微处理器32位处理器<br>\nx86_64是针对x86架构的64位处理器</p>\n</blockquote>\n<blockquote>\n<p>模拟器32位处理器测试需要i386架构，<br>\n模拟器64位处理器测试需要x86_64架构，<br>\n真机32位处理器需要armv7,或者armv7s架构，<br>\n真机64位处理器需要arm64架构。</p>\n</blockquote>\n<h6><span id=\"xcode-build-setting中指令集相关选项释义\">Xcode Build Setting中指令集相关选项释义</span></h6>\n<ol>\n<li>\n<p>Architectures<br>\n指定工程被编译成可支持哪些指令集类型，而支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包会变大(Space-separated list of identifiers. Specifies the architectures (ABIs, processor models) to which the binary is targeted. When this build setting specifies more than one architecture, the generated binary may contain object code for each of the specified architectures. )。</p>\n</li>\n<li>\n<p>Valid Architectures<br>\n限制可能被支持的指令集的范围，也就是Xcode编译出来的二进制包类型最终从这些类型产生，而编译出哪种指令集的包，将由Architectures与Valid Architectures（因此这个不能为空）的交集来确定(Space-separated list of identifiers. Specifies the architectures for which the binary may be built. During the build, this list is intersected with the value of ARCHS build setting; the resulting list specifies the architectures the binary can run on. If the resulting architecture list is empty, the target generates no binary.)。</p>\n</li>\n<li>\n<p>Build Active Architecture Only<br>\n指定是否只对当前连接设备所支持的指令集编译<br>\n当其值设置为YES，这个属性设置为yes，是为了debug的时候编译速度更快，它只编译当前的architecture版本，而设置为no时，会编译所有的版本。 所以，一般debug的时候可以选择设置为yes，release的时候要改为no，以适应不同设备。<br>\n<br><br>\n<br></p>\n</li>\n</ol>\n<h5><span id=\"二-工程配置增加64位的支持\">二、工程配置，增加64位的支持</span></h5>\n<blockquote>\n<p>note：在Xcode6.1.1及以上 Valid Architectures  设置里， 默认为 Standard architectures(armv7,arm64),如果你想改的话，自己在other中更改。</p>\n</blockquote>\n<ul>\n<li>使用 standard architectures (including 64-bit)(armv7,arm64) 参数，则打的包里面有32位、64位两份代码，在iPhone5s（ iPhone5s的cpu是64位的 ）下，会首选运行64位代码包， 其余的iPhone（ 其余iPhone都是32位的,iPhone5c也是32位 ），只能运行32位包，但是包含两种架构的代码包，只有运行在ios6，ios7系统上。 这也就是说，这种打包方式，对手机几乎没要求，但是对系统有要求，即ios6以上。</li>\n<li>使用 standard architectures (armv7,armv7s) 参数， 则打的包里只有32位代码， iPhone5s的cpu是64位，但是可以兼容32位代码，即可以运行32位代码。但是这会降低iPhone5s的性能。 其余的iPhone对32位代码包更没问题， 而32位代码包，对系统也几乎也没什么限制。</li>\n<li>要发挥iPhone5s及以上的64位机型性能，就要包含64位包，那么系统最低要求为ios6。 如果要兼容ios5以及更低的系统，只能打32位的包，系统都能通用，但是会丧失iPhone5s的性能。<br>\n<br></li>\n</ul>\n<h4><span id=\"valid-architectures与architectures指令集交集表\">Valid Architectures与Architectures指令集交集表：</span></h4>\n<table>\n<thead>\n<tr>\n<th>Valid Architectures设置</th>\n<th>Architectures设置</th>\n<th>生成二进制包支持的指令集(取交集)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>armv7, armv7s, arm64</td>\n<td>armv7s</td>\n<td>armv7s</td>\n</tr>\n<tr>\n<td>armv7, armv7s</td>\n<td>armv7s,arm64</td>\n<td>armv7s</td>\n</tr>\n<tr>\n<td>armv7, armv7s, arm64</td>\n<td>armv6, armv7s, arm64</td>\n<td>armv7s, arm64</td>\n</tr>\n<tr>\n<td>armv6, armv7, armv7s</td>\n<td>armv6, armv7s, arm64</td>\n<td>armv6, armv7s</td>\n</tr>\n<tr>\n<td>armv7, arm64 ,armv7s</td>\n<td>armv7, arm64 ,armv7s</td>\n<td>armv7, arm64 ,armv7s</td>\n</tr>\n<tr>\n<td>armv7, armv7s, arm64</td>\n<td>armv7，armv7s</td>\n<td>armv7s, armv7</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<ol>\n<li>比如 Valid Architectures设置的支持arm指令集版本有：armv7/armv7s/arm64，对应的Architectures设置的支持arm指令集版本有：armv7s，这时Xcode只会生成一个armv7s指令集的二进制包。</li>\n<li>xcode默认的设置：<br>\n<strong>Architectures</strong> : <code>Strandard architectures - $(ARCHS_STANDARD)</code> //相当于arm64 armv7s armv7<br>\n<strong>Valid Architectures</strong> : <code>arm64 armv7s armv7</code></li>\n<li>如果你对ipa安装包大小有要求，可以减少安装包的指令集的数量，这样就可以尽可能的减少包的大小。</li>\n</ol>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2443108-7013ad449e239282.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"自定设置\"><br>\n<img src=\"https://upload-images.jianshu.io/upload_images/2443108-67cf1a85da78e2d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"系统默认设置\"></p>\n<br>\n#### 制作静态库.a是指令集选择\n现在回归到正题，如何制作一个“没有问题”的.a静态库，通过以上信息了解到，当我们做App的时候，为了追求高效率，并且减小包的大小，Build Active Architecture Only设置成YES，Architectures按Xcode默认配置就可以，因为arm64向前兼容。但制作.a静态库就不同了，因为要保证兼容性，包括不同iOS设备以及模拟器运行不出错，所以结合当前行业情况，要做到最大的兼容性。\nValidArchitectures设置为：armv7｜armv7s｜arm64｜i386｜x86_64 \nArchitectures设置不变（或根据你需要）:  armv7｜arm64\n然后分别选择iOS设备和模拟器进行编译，最后找到相关的.a进行合包:\n* 合并两个不同构架的库文件\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ lipo -create /Users/xxxxxx/<span class=\"class\"><span class=\"keyword\">lib</span>/<span class=\"title\">libv7</span>.<span class=\"title\">a</span>  /<span class=\"title\">Users</span>/<span class=\"title\">xxxxxx</span>/<span class=\"title\">lib</span>/<span class=\"title\">lib64</span>.<span class=\"title\">a</span>  -<span class=\"title\">output</span> /<span class=\"title\">Users</span>/<span class=\"title\">xxxxxx</span>/<span class=\"title\">lib</span>/<span class=\"title\">lib</span>.<span class=\"title\">a</span></span></span><br><span class=\"line\">/<span class=\"regexp\">/指令说明： lipo -create 库文件1一完整路径  库文件2完整路径  -output 输出的文件名路径</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>从某个库文件中提起出指定构架的库文件</li>\n</ul>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Desktop<span class=\"symbol\">$</span> lipo -thin arm64 debugserver -output debugserver2</span><br><span class=\"line\"><span class=\"comment\">//指令说明：lipo -thin 对应构架指令 对应文件 -output 输出的文件名路径</span></span><br></pre></td></tr></table></figure>\n<p>使用lipo -create 真机库.a的路径 模拟器库.a的的路径 －output 合成库的名字.a ，这样就制作了一个通用的静态库.a。<br>\n制作动态、静态库详情可以参考<a href=\"http://blog.csdn.NET/lizhongfu2013/article/details/12648633\" target=\"_blank\" rel=\"noopener\">【链接】</a></p>\n<br>\n#### 其它注意点：\n1. 因此如果一些程序中使用的静态库不支持armv7s，而你的工程支持armv7s时，就会出现`“xxxx does not contain a(n) armv7s slice:xxxxx for architecture armv7s\"`的编译错误，想要解决这个问题，有两个方法：\n    1. 如果是开源的，能够找到源代码，则可以用源代码重新打一个支持armv7s的libaray, 或者在工程中直接使用源代码，而不是静态库。\n    2. 如果不是开源的，要么就坐等第三方库的支持，要么就暂时让你的工程不支持armv7s。\n2. 此外，模拟器并不运行arm代码，软件会被编译成x86可以运行的指令。所以生成静态库时都是会先生成两个.a，一个是i386的用于在模拟器运行，另一个是在真实设备上运行的，然后再用命令将两个.a合并成一个。\n3. 需要注意的是iOS模拟器没有运行arm指令集，编译运行的是x86指令集，所以，只有在iOS设备上，才会执行设备对应的arm指令集。\n4. 连接的手机指令集匹配是由高到低（arm64 > armv7s > armv7）依次匹配的。\n<p><a href=\"https://www.jianshu.com/p/567d3b730608\">简书链接</a></p>\n<p>部份资源<a href=\"http://blog.csdn.net/sakulafly/article/details/41089411\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2>iOS armv7, armv7s, arm64区别与应用32位、64位配置</h2>\n<h3>历程</h3>\n<ol>\n<li>2015年2月1日不允许不支持arm64的应用的提交；</li>\n<li>iOS10发布后，如果你的应用中使用到了32位的类、库，没有相应支持64位机型的库，则首次启动后会弹窗式提示：“ xxx可能使iPhone变慢…”；</li>\n<li>iOS10.3公测版发布:封杀32位应用；</li>\n<li>苹果系统（iOS7/iOS8-iOS9）,32位的framework和64位的framework是共存的，所以如果所有的应用都是64位的话，系统就自动不加载32位的framework，这样可以少占用资源，另外对运行的速度是有好处的，也就是说，你会感觉手机运行的快了一点。应用在兼容64位系统后，内存的占用肯定会变多一点，不过性能也有相应的提升。</li>\n</ol>\n<h4>下面了解下64与32位的区别：</h4>\n<h5>数据类型的变化：</h5>\n<ol>\n<li>\n<p>在32位的年代，使用的是IPL32的规范，到了64位之后，改成了LP64规范。</p>\n</li>\n<li>\n<p>数据类型里面，NSInteger在32位时等同于int，在64位时等同于long，而这个数据结构使用很广，很多不规范的时候会直接和int替换使用，在32位是毫无问题，但在64位时，这就是隐患了。CGFloat也有同样的问题</p>\n</li>\n<li>\n<p>如果使用了偏移量来访问struct的项，那么需要认真仔细的检查，其余的还算好，当然如果你用了malloc，那么也请检查一下分配的内存大小，建议是多使用sizeof来帮助计算。</p>\n</li>\n<li>\n<p>方法调用上的变化：在64位系统在运行时调用函数和32位系统是不同的。主要的区别在于传递具有可变参数个数的函数的参数时，我们来看下面的代码：</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fixedFunction</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">variadicFunction</span><span class=\"params\">(<span class=\"keyword\">int</span> a, ...)</span></span>; </span><br><span class=\"line\">   <span class=\"keyword\">int</span> main  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\"><span class=\"keyword\">int</span> value2 = fixedFunction(<span class=\"number\">5</span>,<span class=\"number\">5</span>);  </span><br><span class=\"line\"><span class=\"keyword\">int</span> value1 = variadicFunction(<span class=\"number\">5</span>,<span class=\"number\">5</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一个函数是固定传入2个参数，第二个函数是参数个数不定的，在使用中,也<br>\n传入了2个参数。在32位系统下，这两个函数的参数传递是非常类似的，在64<br>\n位系统下，这两者就是截然不同了。</p>\n</li>\n<li>\n<p>项目中使用的第三方库肯定需要支持64位系统，否则还是白搭。大家需要检查自己使用的第三方的库，看是否支持64位的版本。苹果系统中（iOS7/iOS8-iOS9）,32位的framework和64位的framework是共存的，所以如果所有的应用都是64位的话，系统就自动不加载32位的framework，这样可以少占用资源，另外对运行的速度是有好处的，也就是说，你会感觉手机运行的快了一点。应用在兼容64位系统后，内存的占用肯定会变多一点，不过性能也有相应的提升。</p>\n</li>\n</ol>\n<h4>增加应用对64位的支持：</h4>\n<h5>一、配置前确认工作：</h5>\n<p>如果你不能确定库是否支持了arm64，可以在cmd模式下用file命令来检查一下库文件：</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$lipo -info /Users/xxx/NHPushStreamSDK/FFmpeg-iOS/<span class=\"class\"><span class=\"keyword\">lib</span>/<span class=\"title\">libavcodec</span>.<span class=\"title\">a</span></span></span><br><span class=\"line\">/<span class=\"regexp\">/指令说明：lipo -info 静态库(动态库)文件完整路径</span></span><br></pre></td></tr></table></figure>\n<p>armv7，armv7s和arm64,i386,x86_64这些都代表什么？</p>\n<ul>\n<li>armv7｜armv7s｜arm64都是ARM处理器的指令集</li>\n<li>i386｜x86_64 是Mac处理器的指令集<br>\n<br></li>\n</ul>\n<h6>了解ARM</h6>\n<p>__Arm处理器，因为其低功耗和小尺寸而闻名，几乎所有的手机处理器都基于arm，其在嵌入式系统中的应用非常广泛，它的性能在同等功耗产品中也很出色。</p>\n<p>Armv6、armv7、armv7s、arm64都是arm处理器的指令集，所有指令集原则上都是向下兼容的，如iPhone4S的CPU默认指令集为armv7指令集，但它同时也兼容armv6指令集，只是使用armv6指令集时无法充分发挥其性能，即无法使用armv7指令集中的新特性，同理，iPhone5的处理器标配armv7s指令集，同时也支持armv7指令集，只是无法进行相关的性能优化，从而导致程序的执行效率没那么高。<br>\n<br></p>\n<blockquote>\n<p>这些指令集在哪些设备中有用到呢？</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>arm64</th>\n<th>armv7s</th>\n<th>armv7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>iPhone6s</td>\n<td>iPhone5</td>\n<td>iPhone4</td>\n</tr>\n<tr>\n<td>iphone6s plus</td>\n<td>iPhone5C</td>\n<td>iPhone4S</td>\n</tr>\n<tr>\n<td>iphone6</td>\n<td>iPad4(iPad with Retina Display)</td>\n<td>iPad</td>\n</tr>\n<tr>\n<td>iphone6 plus</td>\n<td></td>\n<td>iPad2</td>\n</tr>\n<tr>\n<td>iphone5s</td>\n<td></td>\n<td>iPad3(The New iPad)</td>\n</tr>\n<tr>\n<td>iPad Air</td>\n<td></td>\n<td>iPad mini</td>\n</tr>\n<tr>\n<td>iPad mini2 (iPad mini with Retina Display)</td>\n<td></td>\n<td>iPod Touch 3G</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>iPod Touch4</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>i386是针对intel通用微处理器32位处理器<br>\nx86_64是针对x86架构的64位处理器</p>\n</blockquote>\n<blockquote>\n<p>模拟器32位处理器测试需要i386架构，<br>\n模拟器64位处理器测试需要x86_64架构，<br>\n真机32位处理器需要armv7,或者armv7s架构，<br>\n真机64位处理器需要arm64架构。</p>\n</blockquote>\n<h6>Xcode Build Setting中指令集相关选项释义</h6>\n<ol>\n<li>\n<p>Architectures<br>\n指定工程被编译成可支持哪些指令集类型，而支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包会变大(Space-separated list of identifiers. Specifies the architectures (ABIs, processor models) to which the binary is targeted. When this build setting specifies more than one architecture, the generated binary may contain object code for each of the specified architectures. )。</p>\n</li>\n<li>\n<p>Valid Architectures<br>\n限制可能被支持的指令集的范围，也就是Xcode编译出来的二进制包类型最终从这些类型产生，而编译出哪种指令集的包，将由Architectures与Valid Architectures（因此这个不能为空）的交集来确定(Space-separated list of identifiers. Specifies the architectures for which the binary may be built. During the build, this list is intersected with the value of ARCHS build setting; the resulting list specifies the architectures the binary can run on. If the resulting architecture list is empty, the target generates no binary.)。</p>\n</li>\n<li>\n<p>Build Active Architecture Only<br>\n指定是否只对当前连接设备所支持的指令集编译<br>\n当其值设置为YES，这个属性设置为yes，是为了debug的时候编译速度更快，它只编译当前的architecture版本，而设置为no时，会编译所有的版本。 所以，一般debug的时候可以选择设置为yes，release的时候要改为no，以适应不同设备。<br>\n<br><br>\n<br></p>\n</li>\n</ol>\n<h5>二、工程配置，增加64位的支持</h5>\n<blockquote>\n<p>note：在Xcode6.1.1及以上 Valid Architectures  设置里， 默认为 Standard architectures(armv7,arm64),如果你想改的话，自己在other中更改。</p>\n</blockquote>\n<ul>\n<li>使用 standard architectures (including 64-bit)(armv7,arm64) 参数，则打的包里面有32位、64位两份代码，在iPhone5s（ iPhone5s的cpu是64位的 ）下，会首选运行64位代码包， 其余的iPhone（ 其余iPhone都是32位的,iPhone5c也是32位 ），只能运行32位包，但是包含两种架构的代码包，只有运行在ios6，ios7系统上。 这也就是说，这种打包方式，对手机几乎没要求，但是对系统有要求，即ios6以上。</li>\n<li>使用 standard architectures (armv7,armv7s) 参数， 则打的包里只有32位代码， iPhone5s的cpu是64位，但是可以兼容32位代码，即可以运行32位代码。但是这会降低iPhone5s的性能。 其余的iPhone对32位代码包更没问题， 而32位代码包，对系统也几乎也没什么限制。</li>\n<li>要发挥iPhone5s及以上的64位机型性能，就要包含64位包，那么系统最低要求为ios6。 如果要兼容ios5以及更低的系统，只能打32位的包，系统都能通用，但是会丧失iPhone5s的性能。<br>\n<br></li>\n</ul>\n<h4>Valid Architectures与Architectures指令集交集表：</h4>\n<table>\n<thead>\n<tr>\n<th>Valid Architectures设置</th>\n<th>Architectures设置</th>\n<th>生成二进制包支持的指令集(取交集)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>armv7, armv7s, arm64</td>\n<td>armv7s</td>\n<td>armv7s</td>\n</tr>\n<tr>\n<td>armv7, armv7s</td>\n<td>armv7s,arm64</td>\n<td>armv7s</td>\n</tr>\n<tr>\n<td>armv7, armv7s, arm64</td>\n<td>armv6, armv7s, arm64</td>\n<td>armv7s, arm64</td>\n</tr>\n<tr>\n<td>armv6, armv7, armv7s</td>\n<td>armv6, armv7s, arm64</td>\n<td>armv6, armv7s</td>\n</tr>\n<tr>\n<td>armv7, arm64 ,armv7s</td>\n<td>armv7, arm64 ,armv7s</td>\n<td>armv7, arm64 ,armv7s</td>\n</tr>\n<tr>\n<td>armv7, armv7s, arm64</td>\n<td>armv7，armv7s</td>\n<td>armv7s, armv7</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<ol>\n<li>比如 Valid Architectures设置的支持arm指令集版本有：armv7/armv7s/arm64，对应的Architectures设置的支持arm指令集版本有：armv7s，这时Xcode只会生成一个armv7s指令集的二进制包。</li>\n<li>xcode默认的设置：<br>\n<strong>Architectures</strong> : <code>Strandard architectures - $(ARCHS_STANDARD)</code> //相当于arm64 armv7s armv7<br>\n<strong>Valid Architectures</strong> : <code>arm64 armv7s armv7</code></li>\n<li>如果你对ipa安装包大小有要求，可以减少安装包的指令集的数量，这样就可以尽可能的减少包的大小。</li>\n</ol>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2443108-7013ad449e239282.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"自定设置\"><br>\n<img src=\"https://upload-images.jianshu.io/upload_images/2443108-67cf1a85da78e2d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"系统默认设置\"></p>\n<br>\n#### 制作静态库.a是指令集选择\n现在回归到正题，如何制作一个“没有问题”的.a静态库，通过以上信息了解到，当我们做App的时候，为了追求高效率，并且减小包的大小，Build Active Architecture Only设置成YES，Architectures按Xcode默认配置就可以，因为arm64向前兼容。但制作.a静态库就不同了，因为要保证兼容性，包括不同iOS设备以及模拟器运行不出错，所以结合当前行业情况，要做到最大的兼容性。\nValidArchitectures设置为：armv7｜armv7s｜arm64｜i386｜x86_64 \nArchitectures设置不变（或根据你需要）:  armv7｜arm64\n然后分别选择iOS设备和模拟器进行编译，最后找到相关的.a进行合包:\n* 合并两个不同构架的库文件\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ lipo -create /Users/xxxxxx/<span class=\"class\"><span class=\"keyword\">lib</span>/<span class=\"title\">libv7</span>.<span class=\"title\">a</span>  /<span class=\"title\">Users</span>/<span class=\"title\">xxxxxx</span>/<span class=\"title\">lib</span>/<span class=\"title\">lib64</span>.<span class=\"title\">a</span>  -<span class=\"title\">output</span> /<span class=\"title\">Users</span>/<span class=\"title\">xxxxxx</span>/<span class=\"title\">lib</span>/<span class=\"title\">lib</span>.<span class=\"title\">a</span></span></span><br><span class=\"line\">/<span class=\"regexp\">/指令说明： lipo -create 库文件1一完整路径  库文件2完整路径  -output 输出的文件名路径</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>从某个库文件中提起出指定构架的库文件</li>\n</ul>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Desktop<span class=\"symbol\">$</span> lipo -thin arm64 debugserver -output debugserver2</span><br><span class=\"line\"><span class=\"comment\">//指令说明：lipo -thin 对应构架指令 对应文件 -output 输出的文件名路径</span></span><br></pre></td></tr></table></figure>\n<p>使用lipo -create 真机库.a的路径 模拟器库.a的的路径 －output 合成库的名字.a ，这样就制作了一个通用的静态库.a。<br>\n制作动态、静态库详情可以参考<a href=\"http://blog.csdn.NET/lizhongfu2013/article/details/12648633\" target=\"_blank\" rel=\"noopener\">【链接】</a></p>\n<br>\n#### 其它注意点：\n1. 因此如果一些程序中使用的静态库不支持armv7s，而你的工程支持armv7s时，就会出现`“xxxx does not contain a(n) armv7s slice:xxxxx for architecture armv7s\"`的编译错误，想要解决这个问题，有两个方法：\n    1. 如果是开源的，能够找到源代码，则可以用源代码重新打一个支持armv7s的libaray, 或者在工程中直接使用源代码，而不是静态库。\n    2. 如果不是开源的，要么就坐等第三方库的支持，要么就暂时让你的工程不支持armv7s。\n2. 此外，模拟器并不运行arm代码，软件会被编译成x86可以运行的指令。所以生成静态库时都是会先生成两个.a，一个是i386的用于在模拟器运行，另一个是在真实设备上运行的，然后再用命令将两个.a合并成一个。\n3. 需要注意的是iOS模拟器没有运行arm指令集，编译运行的是x86指令集，所以，只有在iOS设备上，才会执行设备对应的arm指令集。\n4. 连接的手机指令集匹配是由高到低（arm64 > armv7s > armv7）依次匹配的。\n<p><a href=\"https://www.jianshu.com/p/567d3b730608\">简书链接</a></p>\n<p>部份资源<a href=\"http://blog.csdn.net/sakulafly/article/details/41089411\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n"},{"title":"Nodejs 入门篇","catalog":true,"date":"2019-02-22T14:57:26.000Z","subtitle":null,"header-img":"note_head_img.jpg","catagories":["Objective-C"],"_content":"\nNode.js 学习笔记\n\n[TOC]\n\n## 前言\n\n> 本书首先简要介绍 Node.js，然后通过示例讲解 Node.js 的基本特性，再用案例式教学的方式讲述 如何用 Node.js 进行 Web 开发，接着探讨一些 Node.js 进阶话题，最后展示如何将一个 Node.js 应用部署到 生产环境中。\n\n## 简介\n\n> 本书共6章，分别讨论了 Node.js的背景、安装和配置方法、基本特性、核心模块以及一 些进阶话题。除此之外，还有2个附录，分别介绍了JavaScript 的高级特性和 Node.js 编程规 范。\n>\n> - Node.js 简介\n> - 安装和配置Node.js\n> - Node.js 快速入门\n> - Node.js 核心模块\n> - 使用 Node.js 进行 Web 开发\n> - Node.js 进阶话题\n> - 附录A JavaScript 的高级特性\n> - 附录B Node.js 编程规范\n\n## 第一章 Node.js 简介\n\n### Node.js是什么\n\n> Node.js， 或者 Node， 是一个可以让 JavaScript 运行在服务器端的平台。 它可以让 JavaScript 脱离浏览器的束缚运行在一般的服务器环境下，就像运行 Python、Perl、PHP、Ruby 程序一样。你可以用 Node.js 轻松地进行服务器端应用开发，Python、Perl、PHP、Ruby 能 做的事情 Node.js 几乎都能做，而且可以做得更好。\n>\n> Node.js 是一个为实时Web（Real-time Web）应用开发而诞生的平台，它从诞生之初就充分 考虑了在实时响应、超大规模数据要求下架构的可扩展性。这使得它摒弃了传统平台依靠多线 程来实现高并发的设计思路，而采用了单线程、异步式I/O、事件驱动式的程序设计模型。这些 特性不仅带来了巨大的性能提升，还减少了多线程程序设计的复杂性，进而提高了开发效率。\n>\n> Node.js 不是一种独立的语言，与 PHP、Python、Perl、Ruby 的“既是语言也是平台” 不同。Node.js 也不是一个 JavaScript 框架，不同于 CakePHP、Django、Rails。Node.js 更不 是浏览器端的库，不能与 jQuery、ExtJS 相提并论。Node.js 是一个让 JavaScript 运行在服务 端的开发平台，它让 JavaScript 成为脚本语言世界的一等公民，在服务端堪与 PHP、Python、 Perl、Ruby 平起平坐。\n\n### Node.js能做什么\n\n```\n>  正如 JavaScript 为客户端而生，Node.js 为网络而生。Node.js 能做的远不止开发一个网 站那么简单，使用 Node.js，你可以轻松地开发：\n> * 具有复杂逻辑的网站；\n> *  基于社交网络的大规模 Web 应用；\n> *  Web Socket 服务器；\n> *  TCP/UDP 套接字应用程序；\n> * 命令行工具；\n> * 交互式终端程序；\n> *  带有图形用户界面的本地应用程序；\n> * 单元测试工具；\n> * 客户端 JavaScript 编译器。\n>   Node.js 内建了 HTTP 服务器支持，也就是说你可以轻而易举地实现一个网站和服务器 的组合。这和 PHP、Perl 不一样，因为在使用 PHP 的时候，必须先搭建一个 Apache 之类的\n```\n\n### JavaScript 简史\n\n> 作为 Node.js 的基础，JavaScript 是一个完全为网络而诞生的语言。在今天看来，JavaScript\n> 具有其他诸多语言不具备的优势，例如速度快、开销小、容易学习等，但在一开始它却并不\n> 是这样。多年以来，JavaScript 因为其低效和兼容性差而广受诟病，一直是一个被人嘲笑的 “丑小鸭”，它在成熟之前经历了无数困难和坎坷，个中究竟，还要从它的诞生讲起。\n>\n> JavaScript 首次出现在1995年，正如现在的 Node.js 一样，当年 JavaScript 的诞生决不是 偶然的。在1992年，一个叫 Nombas 的公司开发了“C减减”（C minus minus，Cmm）语言， 后来改名为 ScriptEase。ScriptEase 最初的设计是将一种微型脚本语言与一个叫做 Espresso Page 的工具配合，使脚本能够在浏览器中运行，因此 ScriptEase 成为了第一个客户端脚本语言。\n>\n> 2000年左右，也就是 ASP 蒸蒸日上的年代，很多开发者开始学习 JScript。然而 JScript 在 当时并不是很受欢迎。随着后来 LAMP 的兴起，以及Web 2.0 时代的到来，Ajax 等一系列概念的提出，JavaScript 成了前端开发的代名词，同时服务端 JavaScript 也逐渐被人 遗忘。\n>\n> Node.js 是目前 CommonJS 规范最热门的一个实现，它基于 CommonJS 的 Modules/1.0 规 范实现了 Node.js 的模块，同时随着 CommonJS 规范的更新，Node.js 也在不断跟进。\n>\n> CommonJS 规范包括了模块（modules）、包（packages）、系统（system）、二进制（binary）、 控制台（console）、编码（encodings）、文件系统（filesystems）、套接字（sockets）、单元测 试（unit testing）等部分。\n\n- 官方 API 文档http://nodejs.org/api/。 \n- CNodeJS 社区看看http://cnodejs.org/\n\n## 第二章 安装和配置Node.js\n\n### Mac OS X 上安装Node.js\n\n> 在官方链接： http://nodejs.org 找到Download 链接，然后选择Macintosh Installer，下载安装包。下载完成后运行安装包， 根据提示完成安装；\n>\n> Node.js 和 npm 会被安装到 /usr/local/bin 目录下，在macos下源码编译那么需要安装 Xcode\n>\n> 安装成功后在终端执行命令，确认是正确安装：`$ node -v` //查看版本号\n\n### Windows 上安装Node.js\n\n> 大同小异，或者自行百度\n>\n> 安装程序不会询问你安装路径， Node.js 会被自动安装到 C:\\Program Files\\nodejs 或 C:\\Program Files (x86)\\nodejs（64位系统）目录下，并且会在系统的 PATH 环境变量中增加该\n>\n> 源码编译：Node.js 在 Windows 下只能通过 Microsoft Visual Studio 编译\n\n### Linux 上安装Node.js\n\n> 大同小异，或者自行百度\n>\n> 源码编译：Linux上需要使用 g++ 来编译 Node.js。在 Debian/Ubuntu 中，你可以 通过 apt-get install g++ 命令安装g++。在 Fedora/Redhat/CentOS 中，你可以使用 yum install gcc-c++ 安装\n\n### 安装多版本管理器\n\n> 迄今为止Node.js 更新速度还很快，有时候新版本还会将旧版本的一些 API 废除，以至 于写好的代码不能向下兼容。有时候你可能想要尝试一下新版本有趣的特性，但又想要保持 一个相对稳定的环境。基于这种需求，Node.js 的社区开发了多版本管理器，用于在一台机 器上维护多个版本的 Node.js 实例， 方便按需切换。\n>\n> Node 多版本管理器（Node Version Manager，nvm）是一个通用的叫法，它目前有许多不同的实现。通常我们说的 nvm 是指 或者n\n\n- nvm\n\n  https://github.com/creationix/nvm\n\n  如果你已经安装好了 Node.js 和 npm 环境，就可以直接使用 `$ npm install -g nvm`\n\n- n\n\n  https://github.com/visionmedia/n\n\n  如果你已经安装好了 Node.js 和 npm 环境，就可以直接使用 `$ npm install -g n` n不支持Windows\n\n  安装完 n 以后，在终端中运行 n --help 即可看到它的使用说明\n\n## 第三章 Node.js 快速入门\n\n### Hello World\n\n```javascript\n//打开终端\n$ vim hello.js\n\n//在hello.js文件中写代码\nconsole.log('Hello World');\n\n//运行hello.js文件\n$ node hello.js\n\n//输出\nHello World\n\n//我们可以把要执行的语句作为 node -e 的参数直接执行。\n$ node -e \"console.log('Hello World');\" \n//输出\nHello World\n```\n\n### 使用 **node** 的 REPL 模式\n\n> REPL （Read-eval-print loop），即输入—求值—输出循环，可以进入一个即 时求值的运行环境。运行无参数的 node 将会启动一个 JavaScript 的交互式 shell：\n\n```javascript\n$ node\n> console.log('Hello World'); Hello World\nundefined\n> consol.log('Hello World');\n```\n\n### 建立 HTTP 服务器\n\n> Node.js 是为网络而诞生的平台，但又与 ASP、PHP 有很大的不同，究竟不同在哪里呢？ 如果你有 PHP 开发经验，会知道在成功运行 PHP 之前先要配置一个功能强大而复杂的 HTTP 服务器，譬如 Apache、IIS 或 Nginx，还需要将 PHP 配置为 HTTP 服务器的模块，或者使用 FastCGI 协议调用 PHP 解释器。这种架构是“浏览器  HTTP 服务器  PHP 解释器”的组织 方式，而Node.js采用了一种不同的组织方式，如下图所示：\n>\n> Node.js 将“HTTP服务器”这一层抽离，直接面向浏览器用户。这种架构 从某种意义上来说是颠覆性的， 因而会让人心存疑虑：Node.js作为HTTP服务器的效率足够吗？会不会提高耦合程度？不在这里讨论这种架构的利弊\n\n​\t![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/Node.js与PHP的架构.png)\n\n- 建立一个名为 app.js 的文件，内容为：\n\n  ```javascript\n  //app.js\n  var http = require('http');\n  http.createServer(function(req, res) {\n   res.writeHead(200, {'Content-Type': 'text/html'});\n   res.write('<h1>Node.js</h1>');\n   res.end('<p>Hello World</p>');\n  }).listen(3000);\n  console.log(\"HTTP server is listening at port 3000.\");\n  ```\n\n- 接下来运行 node app.js命令，打开浏览器访问 http://127.0.0.1:3000，即可看到如下图所示的内容。\n\n- supervisor\n\n  > supervisor 可以帮助你实现这个功能，它会监视你对代码的改动，并自动重启 Node.js。 使用方法很简单，首先使用 npm 安装 supervisor：\n  >\n  > `$ npm install -g supervisor`\n  >\n  > 接下来，使用 supervisor 命令启动 app.js：\n  >\n  > `$ supervisor app.js`\n  >\n  > 当代码被改动时，运行的脚本会被终止，然后重新启动。\n\n### 异、同步读取文件\n\n- 异步\n\n  ```javascript\n  // 让我们看看在 Node.js 中如何用异步的方式读取一个文件，下面是一个例子：\n  //readfile.js\n  var fs = require('fs');\n  fs.readFile('file.txt', 'utf-8', function (err, data) {\n     if (err) {\n        console.error(err);\n     } else {\n        console.log(data);\n     }\n  });\n  console.log('end.');\n  // 运行的结果如下：\n  end.\n  Contents of the file.\n  ```\n\n  > fs.readFile 调用时所做的工作只是将异步式 I/O 请求发送给了操作系统，然后立即 返回并执行后面的语句，执行完以后进入事件循环监听事件。当 fs 接收到 I/O 请求完成的 事件时，事件循环会主动调用回调函数以完成后续工作\n  >\n  > Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。在开发者看来，事 件由 EventEmitter 对象提供。前面提到的 fs.readFile 和 http.createServer 的回 调函数都是通过 EventEmitter 来实现的\n\n  \n\n- 同步\n\n  ```javascript\n  //readfilesync.js\n  var fs = require('fs');\n  var data = fs.readFileSync('file.txt', 'utf-8');\n  console.log(data);\n  console.log('end.');\n  //运行的结果与前面不同， 如下所示：\n  $ node readfilesync.js Contents of the file.\n  end.\n  ```\n\n### Node.js 的事件循环机制\n\n> Node.js 在什么时候会进入事件循环呢？答案是 Node.js 程序由事件循环开始，到事件循 环结束，所有的逻辑都是事件的回调函数，所以 Node.js 始终在事件循环中，程序入口就是 事件循环第一个事件的回调函数。事件的回调函数在执行的过程中，可能会发出 I/O 请求或 直接发射（emit）事件，执行完毕后再返回事件循环，事件循环会检查事件队列中有没有未 处理的事件，直到程序结束。图3-5说明了事件循环的原理。\n\n​\t![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/node_event_runloop.png)\n\n### 模块和包\n\n> 模块（Module）和包（Package）是 Node.js 最重要的支柱。开发一个具有一定规模的程 序不可能只用一个文件，通常需要把各个功能拆分、封装，然后组合起来，模块正是为了实 现这种方式而诞生的。在浏览器 JavaScript 中，脚本模块的拆分和组合通常使用 HTML 的 script 标签来实现。Node.js 提供了 require 函数来调用其他模块，而且模块都是基于文件的，机制十分简单。Node.js 的模块和包机制的实现参照了 CommonJS 的标准， 但并未完全遵循\n\n#### 什么是模块\n\n> 模块是 Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是 JavaScript 代码、JSON 或者编译过的 C/C++ 扩展。\n>\n> 在前面的例子中，我们曾经用到了 var http = require('http')，其中 http 是 Node.js 的一个核心模块\n\n1. 创建模块\n   在 Node.js 中，创建一个模块非常简单，因为一个文件就是一个模块，我们要关注的问 题仅仅在于如何在其他文件中获取这个模块。Node.js 提供了 exports 和 require 两个对 象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获 取模块的 exports 对象。\n\n   - 让我们以一个例子来了解模块。创建一个 module.js 的文件，内容是：\n\n     ```javascript\n     //module.js\n     var name;\n     exports.setName = function (thyName) {\n        name = thyName;\n     };\n     exports.sayHello = function () {\n        console.log('Hello ' + name);\n     };\n     //在同一目录下创建 getmodule.js， 内容是：\n     //getmodule.js\n     var myModule = require('./module');\n     myModule.setName('mynodetest'); \n     myModule.sayHello();\n     //-------------------------------------------------//\n     //运行\n     $ node getmodule.js，\n     //结果：\n     Hello mynodetest\n     ```\n\n     在以上示例中，module.js 通过 exports 对象把 setName 和 sayHello 作为模块的访 问接口，在 getmodule.js 中通过 require('./module') 加载这个模块，然后就可以直接访 问 module.js 中 exports 对象的成员函数了。\n\n2. 覆盖 exports\n\n   - 有时候我们只是想把一个对象封装到模块中，例如：\n\n     ```javascript\n     //hello.js\n     function Hello() {\n        var name;\n        this.setName = function (thyName) {\n           name = thyName;\n        };\n        this.sayHello = function () {\n           console.log('Hello ' + name);\n        };\n     };\n     \n     module.exports = Hello;\n     \n     //gethello.js\n     //这样就可以直接获得这个对象了：\n     var Hello = require('./hello');\n     hello = new Hello();\n     hello.setName('BYVoid');\n     hello.sayHello();\n     ```\n\n     注意，模块接口的唯一变化是使用 module.exports = Hello 代替了 exports.Hello= Hello。在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。事实上，exports 本身仅仅是一个普通的空对象，即 {}，它专门用来声明接口，本 质上是通过它为模块闭包的内部建立了一个有限的访问接口\n\n#### 什么是包\n\n> 包是在模块基础上更深一步的抽象，Node.js 的包类似于 C/C++ 的函数库或者 Java/.Net 的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。Node.js 根 据 CommonJS 规范实现了包机制，开发了 npm来解决包的发布和获取需求。\n> Node.js 的包是一个目录，其中包含一个 JSON 格式的包说明文件 package.json。严格符 合 CommonJS 规范的包应该具备以下特征：\n>\n> - package.json 必须在包的顶层目录下；\n> - 二进制文件应该在 bin 目录下；\n> - JavaScript 代码应该在 lib 目录下；\n> - 文档应该在 doc 目录下；\n> - 单元测试应该在 test 目录下。\n>\n> Node.js 对包的要求并没有这么严格，只要顶层目录下有 package.json，并符合一些规范 即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 CommonJS 规范。\n\n- 以文件夹作为模块\n\n  > 模块与文件是一一对应的。文件不仅可以是 JavaScript 代码或二进制代码，还可以是一 个文件夹。最简单的包，就是一个作为文件夹的模块。\n\n  ```javascript\n  //somepackage/index.js exports.hello = function() {\n   console.log('Hello.');\n  };\n  //然后在 somepackage 之外建立 getpackage.js，内容如下：\n  //getpackage.js\n  var somePackage = require('./somepackage'); \n  somePackage.hello();\n  //运行 \n  $ node getpackage.js，\n  //控制台将输出结果 Hello.。\n  \n  ```\n\n- package.json\n\n  在前面的例子中的somepackage文件夹下，创建一个叫package.json的文件，内容如下：\n\n  **还可以进入somepackage目录，使用命令来生成一个package.json:`$ npm init -f `**\n\n  ```javascript\n  {\n  \t\"main\" : \"./lib/interface.js\"\n  }\n  \n  ```\n\n  然后将 index.js 重命名为 interface.js 并放入 lib 子文件夹下。以同样的方式再次调用这个 包，依然可以正常使用。\n\n  因为Node.js 在调用某个包时，会首先检查包中 package.json 文件的 main 字段，将其作为 包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作 为包的接口。\n\n  > package.json 是 CommonJS 规定的用来描述包的文件，完全符合规范的 package.json 文 件应该含有以下字段。\n  >\n  > - name：包的名称，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含\n  >   空格。\n  > - description：包的简要说明。\n  > - version：符合语义化版本识别 规范的版本字符串。\n  > - keywords：关键字数组，通常用于搜索。\n  > - maintainers：维护者数组，每个元素要包含 name、email （可选）、web （可选）\n  >   字段。\n  > - contributors：贡献者数组，格式与maintainers相同。包的作者应该是贡献者\n  >   数组的第一个元素。\n  > - bugs：提交bug的地址，可以是网址或者电子邮件地址。\n  > - licenses：许可证数组，每个元素要包含 type （许可证的名称）和 url （链接到\n  >   许可证文本的地址）字段。\n  > - repositories：仓库托管地址数组，每个元素要包含 type（仓库的类型，如 git ）、url （仓库的地址）和 path （相对于仓库的路径，可选）字段。\n  > - dependencies：包的依赖，一个关联数组，由包名称和版本号组成。\n\n#### Node.js 包管理器\n\n> Node.js包管理器，即npm是 Node.js 官方提供的包管理工具①，它已经成了 Node.js 包的 标准发布平台，用于 Node.js 包的发布、传播、依赖控制。npm 提供了命令行工具，使你可 以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。\n\n- 获取一个包\n\n  ```\n  //使用 npm 安装包的命令格式为：\n  npm [install/i] [package_name]\n  //例如你要安装 express，可以在命令行运行：\n  $ npm install express\n  或者：$ npm i express\n  //安装成功后，放置在当前目录的 node_modules 子目录下\n  \n  ```\n\n- 本地模式和全局模式\n\n  > npm在默认情况下会从http://npmjs.org搜索或下载包，将包安装到当前目录的node_modules 子目录下。\n  >\n  > npm 还有另一种不同的安装模式被成为全局模式，使用方法为：\n  >\n  > $ npm [install/i] -g [package_name]\n  >\n  > eg.: $ npm install -g supervisor 命令，就是以全局模式安装 supervisor。\n\n  \n\n  - 当我们使用全局模 式安装时，npm 会将包安装到系统目录，如 /usr/local/lib/node_modules/，同时 package.json 文 件中 bin 字段包含的文件会被链接到 /usr/local/bin/\n\n  - 使用全局模式安装的包并不能直接在 JavaScript 文件中用 require 获得，因为 require 不会搜索 /usr/local/lib/node_modules/。\n\n    ​\t\t\t\t**表 - 本地模式与全局模式**\n\n    | 模式     | 可通过 require 使用 | 注册PATH |\n    | -------- | ------------------- | -------- |\n    | 本地模式 | 是                  | 否       |\n    | 全局模式 | 否                  | 是       |\n\n- 创建全局链接\n\n  > npm 提供了一个链接命令 npm link，它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 require 使用，但通过 npm link命令 可以打破这一限制。\n\n  例子：\n\n  我们已经通过 npm install -g express 安装了 express， 这时在工程的目录下运行命令：\n\n  ```\n  $ npm link express\n  ./node_modules/express -> /usr/local/lib/node_modules/express\n  \n  ```\n\n  我们可以在 node_modules 子目录中发现一个指向安装到全局的包的符号链接。通过这 种方法，我们就可以把全局包当本地包来使用了。\n\n#### 调试\n\n- 命令行调试：在命令行下执行 node debug debug.js，将会启动调试工具\n\n```\n$ node debug debug.js\n< debugger listening on port 5858 connecting... ok\nbreak in /home/byvoid/debug.js:1\n1 var a = 1;\n2 var b = 'world';\n3 var c = function(x) { debug>\n\n```\n\n​\t**Node.js 调试命令**\n\n| 命令                                    | 功能                                  |\n| --------------------------------------- | ------------------------------------- |\n| run                                     | 执行脚本，在第一行暂停                |\n| restart                                 | 重新执行脚本                          |\n| cont, c                                 | 继续执行，直到遇到下一个断点 单步执行 |\n| next, n                                 | 单步执行                              |\n| step, s                                 | 单步执行并进入函数                    |\n| out, o                                  | 从函数中步出                          |\n| setBreakpoint(), sb()                   | 在当前行设置断点                      |\n| setBreakpoint(‘f()’), sb(...)           | 在函数f的第一行设置断点               |\n| setBreakpoint(‘script.js’, 20), sb(...) | 在script.js 的第20行设置断点          |\n| clearBreakpoint, cb(…)                  | 清除所有断点                          |\n| backtrace, bt                           | 显示当前的调用栈                      |\n| list(5)                                 | 显示当前执行到的前后5行代码           |\n| watch(expr)                             | 把表达式 expr 加入监视列表            |\n| unwatch(expr)                           | 把表达式 expr 加入监视列表            |\n| watchers                                | 显示监视列表中所有的表达式和值        |\n| repl                                    | 在当前上下文打开即时求值环境          |\n| kill                                    | 终止当前执行的脚本                    |\n| scripts                                 | 显示当前已加载的所有脚本              |\n| version                                 | 显示 V8 的版本                        |\n\n- 远程调试：V8 提供的调试功能是基于 TCP 协议的，因此 Node.js 可以轻松地实现远程调试。在命令行下使用以下两个语句之一可以打开调试服务器：\n\n  - 打开调试服务器\n\n    ```\n    node --debug[=port] script.js \n    node --debug-brk[=port] script.js\n    \n    ```\n\n  - 当调试服务器启动以后，可以用命令行调试工具作为调试客户端连接，例如：\n\n    ```\n    //在一个终端中\n    $ node --debug-brk debug.js debugger listening on port 5858\n    //在另一个终端中\n    $ node debug 127.0.0.1:5858\n    connecting... ok\n    debug> n\n    break in /home/byvoid/debug.js:2\n    1 var a = 1;\n    2 var b = 'world';\n    3 var c = function (x) {\n    4 console.log('hello ' + x + a); debug>\n    \n    ```\n\n- 使用 node-inspector 调试 Node.js\n\n  > 大部分基于 Node.js 的应用都是运行在浏览器中的，例如强大的调试工具 node-inspector。 node-inspector 是一个完全基于 Node.js 的开源在线调试工具，提供了强大的调试功能和友好 的用户界面，它的使用方法十分简便。\n\n  - 首先，使用 npm install -g node-inspector 命令安装 node-inspector，然后在终 端中通过 node --debug-brk=5858 debug.js 命令连接你要除错的脚本的调试服务器， 启动 node-inspector：\n  - $ node-inspector\n  - 在浏览器中打开 http://127.0.0.1:8080/debug?port=5858，即可显示出优雅的 Web 调试工 具\n\n- 使用 Eclipse 调试 Node.js(这里不做介绍)\n\n  \n\n## 第四章 Node.js 核心模块\n\n> 核心模块是 Node.js 的心脏，它由一些精简而高效的库组成，为 Node.js 提供了基本的 API。本章中，我们挑选了一部分最常用的核心模块加以详细介绍，主要内容包括：\n>\n> - 全局对象； \n> - 常用工具；\n> - 事件机制；\n> - 文件系统访问；\n> - HTTP 服务器与客户端。\n\n### 全局对象\n\n#### 全局对象\n\n> JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可 以在程序的任何地方访问，即全局变量。在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。\n\n#### 全局变量\n\n> global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：\n>\n> - 在最外层定义的变量；\n> - 全局对象的属性；\n> - 隐式定义的变量（未定义直接赋值的变量）。\n\n### 常用工具 util\n\n> util 是一个 Node.js 核心模块，提供常用函数的集合，用于弥补核心 JavaScript 的功能 过于精简的不足。\n\n#### util.inherits\n\n> util.inherits(constructor, superConstructor) 是一个实现对象间原型继承 的函数。JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的，具体细节我们在附录A中讨论， 在这里我们只介绍 util.inherits 的用法，示例如下：\n\n```javascript\nvar util = require('util');\n\nfunction Base(){\n    this.name = 'base',\n    this.base = 1991,\n    this.sayHello = function(){\n        console.log('hello :'+ this.name);\n    };\n};\n\nBase.prototype.showName = function(){\n    console.log('this.name :', this.name);\n};\n\nfunction Sub(){\n    this.name = 'sub'\n};\n\nutil.inherits(Sub, Base);\n\nvar objBase = new Base();\nobjBase.showName();\nobjBase.sayHello();\nconsole.log(objBase);\n\nvar objSub = new Sub();\nobjSub.showName();\n// objSub.sayHello();\nconsole.log('objSub :', objSub);\nconsole.log('util.inspect(obj) :', util.inspect(objBase,true,2,true));\n\n//输入结果：\n➜  http0test node module.js\nthis.name : base\nhello :base\nBase { name: 'base', base: 1991, sayHello: [Function] }\nthis.name : sub\nobjSub : Sub { name: 'sub' }\nutil.inspect(obj) : Base {\n  name: 'base',\n  base: 1991,\n  sayHello:\n   { [Function]\n     [length]: 0,\n     [name]: '',\n     [arguments]: null,\n     [caller]: null,\n     [prototype]: { [constructor]: [Circular] } } }\n\n```\n\n\n\n#### util.inspect\n\n> util.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。\n>\n> - showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。\n> - depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 \n> - color 值如果为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。\n\n### 事件驱动 events\n\n> events 是 Node.js 最重要的模块，没有“之一”，原因是 Node.js 本身架构就是事件式 的，而它提供了唯一的接口，所以堪称 Node.js 事件编程的基石。events 模块不仅用于用户代码与 Node.js 下层事件循环的交互，还几乎被所有的模块依赖。\n\n#### 事件发射器（events.EventEmitter）\n\n> events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就 是事件发射与事件监听器功能的封装\n\n- 常规事件\n\n  ```javascript\n  //我们介绍一下EventEmitter常用的API。\n  //为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数 listener。\n  EventEmitter.on(event, listener) \n  //发射 event 事件，传递若干可选参数到事件监听器的参数表。\n  EventEmitter.emit(event, [arg1], [arg2], [...]) \n  //为指定事件注册一个单次监听器， 即监听器最多只会触发一次，触发后立刻解除该监听器。\n  EventEmitter.once(event, listener) \n  //移除指定事件的某个监听器，listener 必须是该事件已经注册过的监听器。\n  EventEmitter.removeListener(event, listener) \n  //移除所有事件的所有监听器，如果指定 event，则移除指定事件的所有监听器。\n  EventEmitter.removeAllListeners([event]) \n  //更详细的 API 文档参见 http://nodejs.org/api/events.html。\n  \n  ```\n\n  ```javascript\n  var events = require('events');\n  var emitter = new event.EventEmitter();\n  \n  emitter.on('someEvent', function (arg1, arg2) {\n    console.log('listener1', arg1, arg2);\n  });\n  \n  emitter.on('someEvent', function (arg1, arg2) {\n    console.log('listener2', arg1, arg2);\n  });\n  \n  emitter.emit('someEvent', 'byvoid', 1991);\n  // 运行的结果是：\n  // listener1 byvoid 1991 \n  // listener2 byvoid 1991\n  \n  ```\n\n- error事件\n\n  > EventEmitter 定义了一个特殊的事件 error，它包含了“错误”的语义，我们在遇到 异常的时候通常会发射 error 事件。当 error 被发射时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并打印调用栈\n\n  ```javascript\n  var events = require('events');\n  var emitter = new events.EventEmitter();\n  emitter.emit('error');\n  \n  ```\n\n### 文件系统 fs\n\n> fs 模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接等 POSIX 文件系统操作\n\n- fs.readFile: \n\n  fs.readFile(filename,[encoding],[callback(err,data)]) 是最简单的读取 文件的函数。它接受一个必选参数 filename，表示要读取的文件名。第二个参数 encoding 是可选的，表示文件的字符编码（不指定编码格式，则data形式输出）。callback 是回调函数，用于接收文件的内容。\n\n  ```javascript\n  // app.js\n  var fs = require('fs');\n  fs.readFile('output.txt', 'utf-8', function (err, data) {\n     if (err) {\n        console.error(err);\n     } else {\n        console.log('fileData: :', data);\n     }\n  });\n  //输出\n  ➜  nodejs_note node app.js\n  fileData: : nenhall 学习node.js 笔记\n  \n  ```\n\n- fs.readFileSync\n\n  fs.readFileSync(filename, [encoding])是 fs.readFile 同步的版本。它接受 的参数和 fs.readFile 相同，而读取到的文件内容会以函数返回值的形式返回。如果有错 误发生，fs 将会抛出异常，你需要使用 try 和 catch 捕捉并处理异常。\n\n- fs.open\n\n  fs.open(path, flags, [mode], [callback(err, fd)])是 POSIX open 函数的 封装，与 C 语言标准库中的 fopen 函数类似。它接受两个必选参数，path 为文件的路径， flags 可以是以下值:\n\n  ```\n  r ：以读取模式打开文件。\n  r+ ：以读写模式打开文件。\n  w ：以写入模式打开文件，如果文件不存在则创建。\n  w+ ：以读写模式打开文件，如果文件不存在则创建。\n  a ：以追加模式打开文件，如果文件不存在则创建。\n  a+ ：以读取追加模式打开文件，如果文件不存在则创建。\n  mode 参数用于创建文件时给文件指定权限，默认是 0666\n  callback：回调函数将会传递一个文 件描述符 fd\n  \n  注意：文件权限指的是 POSIX 操作系统中对文件读取和访问权限的规范，通常用一个八进制数来表示。例如 0754 表示文件所有者的权限是 7 （读、写、执行），同组的用户权限是 5 （读、执行），其他用户的权限是 4（读）， 写成字符表示就是 -rwxr-xr--。\n  \n  ```\n\n- fs.read \n\n  fs.read(fd, buffer, offset, length, position, [callback(err, bytesRead, buffer)])是 POSIX read 函数的封装，相比 fs.readFile 提供了更底层的接口。fs.read 的功能是从指定的文件描述符:\n\n  ```\n  fd 中读取数据并写入 \n  buffer 指向的缓冲区对象。\n  offset 是 buffer 的写入偏移量。\n  length 是要从文件中读取的字节数。\n  position 是文件读取的起始 位置， 如果 position 的值为 null ， 则会从当前文件指针的位置读取。\n  回调函数传递 bytesRead 和 buffer，分别表示读取的字节数和缓冲区对象。\n  \n  ```\n\n  相关函数：\n\n  fs.openSync(path, flags, [mode]) 对 fs.closeSync(fd)\n\n  fs.read(fd, buffer, offset, length, position, callback()])  对 fs.close(fd, [callback(err)])\n\n### HTTP 服务器与客户端\n\n> Node.js 标准库提供了 http 模块，其中封装了一个高效的 HTTP 服务器和一个简易的 HTTP 客户端。http.Server 是一个基于事件的 HTTP 服务器，它的核心由 Node.js 下层 C++ 部分实现，而接口由 JavaScript 封装，兼顾了高性能与简易性。http.request 则是一个 HTTP 客户端工具，用于向 HTTP 服务器发起请求\n\n#### HTTP 服务\n\n> http.Server 是 http 模块中的 HTTP 服务器对象，用 Node.js 做的所有基于 HTTP 协 议的系统，如网站、社交应用甚至代理服务器，都是基于 http.Server 实现的。它提供了 一套封装级别很低的 API，仅仅是流控制和简单的消息解析，所有的高层功能都要通过它的 接口来实现。\n\n- 实现一个服务器\n\n  ```javascript\n  //app.js\n  var http = require('http');\n  // 创建了一个 http.Server 的实例\n  // 将一个函数作为 HTTP 请求处理函数,这个函数接受两个参数，分别是请求对象(req)和响应对象(res)\n  http.createServer(function (req, res) {\n      //响应代码200（表示请求成功）,指定响应头为'Content-Type': 'text/html'\n     res.writeHead(200, {\n        'Content-Type': 'text/html'\n     });\n     // 写入响应体 '<h1>Node.js</h1>'\n     res.write('<h1>Node.js</h1>');\n     // 通过 res.end 结束并发送\n     res.end('<p>Hello World</p>');\n  }).listen(3000);//listen 函数，启动服务器并监听 3000 端口\n  \n  console.log(\"HTTP server is listening at port 3000.\");\n  \n  ```\n\n- **http.Server** 的事件\n\n  http.Server 是一个基于事件的 HTTP 服务器，所有的请求都被封装为独立的事件， 开发者只需要对它的事件编写响应函数即可实现 HTTP 服务器的所有功能。它继承自 EventEmitter\n\n  - request：当客户端请求到来时，该事件被触发，提供两个参数 req 和res，分别是http.ServerRequest 和 http.ServerResponse 的实例，表示请求和响应信息。\n  - connection ：当 TCP 连接建立时， 该事件被触发， 提供一个参数 socket ， 为net.Socket 的实例。connection 事件的粒度要大于 request ， 因为客户端在Keep-Alive 模式下可能会在同一个连接内发送多次请求。\n  - close ：当服务器关闭时，该事件被触发。注意不是在用户连接断开时。\n\n- **http.ServerRequest**\n\n  1. http.ServerRequest 是 HTTP 请求的信息，是后端开发者最关注的内容。它一般由 http.Server 的 request 事件发送，作为第一个参数传递，通常简称 request 或 req\n\n  2. HTTP 请求一般可以分为两部分：请求头（Request Header）和请求体（Requset Body）。 以上内容由于长度较短都可以在请求头解析完成后立即读取。\n\n  3. 请求体可能相对较长， 需要一定的时间传输，因此 http.ServerRequest 提供了以下3个事件用于控制请求体 传输。\n\n     - data ：当请求体数据到来时，该事件被触发。该事件提供一个参数 chunk，表示接收到的数据。如果该事件没有被监听，那么请求体将会被抛弃。该事件可能会被调用多次。\n     - end ：当请求体数据传输完成时，该事件被触发，此后将不会再有数据到来。\n     - close： 用户当前请求结束时，该事件被触发。不同于 end，如果用户强制终止了传输，也还是调用close。\n\n  4. **ServerRequest** 的属性表\n\n     | 名称        | 含义                                                        |\n     | ----------- | ----------------------------------------------------------- |\n     | complete    | 客户端请求是否已经发送完成                                  |\n     | httpVersion | HTTP 协议版本，通常是 1.0 或 1.1                            |\n     | method      | HTTP 请求方法，如 GET、POST、PUT、DELETE 等                 |\n     | url         | 原始的请求路径，例如/static/image/x.jpg 或/user?name=byvoid |\n     | headers     | HTTP 请求头                                                 |\n     | trailers    | HTTP 请求尾（不常见）                                       |\n     | connection  | 当前 HTTP 连接套接字，为 net.Socket 的实例                  |\n     | socket      | connection 属性的别名                                       |\n     | client      | client 属性的别名                                           |\n\n  5. 获取 GET 请求内容\n\n     由于 GET 请求直接被嵌入在路径 中，URL是完整的请求路径，包括了 ? 后面的部分，因此你可以手动解析后面的内容作为 GET 请求的参数\n\n     ```javascript\n     var http = require('http');\n     var url = require('url');\n     var util = require('util');\n     \n     http.createServer(function (req, res) {\n        res.writeHead(200, {\n           'Content-Type': 'text/plain'\n        });\n        res.end(util.inspect(url.parse(req.url, true)));\n     }).listen(3000);\n     \n     //浏览器中输入：http://127.0.0.1:3000/user?name=byvoid&email=byvoid@byvoid.com\n     //展示：\n     Url {\n       protocol: null,\n       slashes: null,\n       auth: null,\n       host: null,\n       port: null,\n       hostname: null,\n       hash: null,\n       search: '?name=byvoid&email=byvoid@byvoid.com',\n       query:\n        [Object: null prototype] { name: 'byvoid', email: 'byvoid@byvoid.com' },\n       pathname: '/user',\n       path: '/user?name=byvoid&email=byvoid@byvoid.com',\n       href: '/user?name=byvoid&email=byvoid@byvoid.com' }\n     \n     ```\n\n     \n\n  6. 获取 POST 请求内容\n\n     HTTP 协议 1.1 版本提供了8种标准的请求方法，其中最常见的就是 GET 和 POST。相比 GET 请求把所有的内容编码到访问路径中， POST 请求的内容全部都在请求体中。 http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作，譬如上传文件。而很多时候我们可能并不需要理会请求体的内容，恶意的POST 请求会大大消耗服务器的资源。所以 Node.js 默认是不会解析请求体的，当你需要的时候， 需要手动来做\n\n     ```javascript\n     var http = require('http');\n     var url = require('url');\n     var util = require('util');\n     \n     var querystring = require('querystring');\n     http.createServer(function(req, res) {\n        var post = '';\n        req.on('end', function(){\n           post = querystring.parse(post);\n           res.end(util.inspect(post));\n        });\n     }).listen(3000);\n     \n     ```\n\n     上面代码并没有在请求响应函数中向客户端返回信息，而是定义了一个 post 变量。通过 req 的 data 事件监听函数，每当接受到请求体的数据， 就累加到 post 变量中。在 end 事件触发后，通过 querystring.parse 将 post 解析为真正的 POST 请求格式，然后向客户端返回\n\n     **注意：**不要在真正的生产应用中使用上面这种简单的方法来获取 POST 请求，因为它有严重的效率和安全问题\n\n     \n\n  7. **http.ServerResponse**\n     http.ServerResponse 是返回给客户端的信息，决定了用户最终能看到的结果。它 也是由 http.Server 的 request 事件发送的， 作为第二个参数传递， 一般简称为 response 或 res。\n\n     > http.ServerResponse 有三个重要的成员函数，用于返回响应头、响应内容以及结束 请求。\n     >\n     > - response.writeHead(statusCode, [headers])：向请求的客户端发送响应头。\n     >   statusCode 是 HTTP 状态码，如 200 （请求成功）、404 （未找到）等。headers\n     >   是一个类似关联数组的对象，表示响应头的每个属性。该函数在一个请求内最多只\n     >   能调用一次，如果不调用，则会自动生成一个响应头。\n     > - response.write(data, [encoding])：向请求的客户端发送响应内容。data 是\n     >   一个 Buffer 或字符串，表示要发送的内容。如果 data 是字符串，那么需要指定\n     >   encoding 来说明它的编码方式，默认是 utf-8。在 response.end 调用之前，\n     >   response.write 可以被多次调用。\n     > - response.end([data], [encoding])：结束响应，告知客户端所有发送已经完\n     >   成。当所有要返回的内容发送完毕的时候，该函数 必须 被调用一次。它接受两个可\n     >   选参数，意义和 response.write 相同。如果不调用该函数，客户端将永远处于\n     >   等待状态。\n\n#### HTTP 客户端\n\n> http 模块提供了两个函数 http.request 和 http.get，功能是作为客户端向 HTTP 服务器发起请求。\n>\n> http.request(options, callback) 发起 HTTP 请求。接受两个参数，option 是\n> 一个类似关联数组的对象，表示请求的参数，callback 是请求的回调函数。option\n> 常用的参数如下所示。\n>\n> - host ：请求网站的域名或 IP 地址。\n> - port ：请求网站的端口，默认 80。\n> - method ：请求方法，默认是 GET。\n> - path ：请求的相对于根的路径，默认是“/”。QueryString 应该包含在其中。例如 /search?query=byvoid。\n> - headers ：一个关联数组对象，为请求头的内容。\n> - callback 传递一个参数，为 http.ClientResponse 的实例。\n>   http.request 返回一个 http.ClientRequest 的实例。\n\n下面是一个通过 http.request 发送 POST 请求的代码：\n\n```javascript\n//httprequest.js\nvar http = require('http');\nvar querystring = require('querystring');\nvar contents = querystring.stringify({\n   name: 'byvoid',\n   email: 'byvoid@byvoid.com',\n   address: 'Zijing 2#, Tsinghua University',\n});\nvar options = {\n   host: 'www.byvoid.com',\n   path: '/application/node/post.php',\n   method: 'POST',\n   headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'Content-Length': contents.length\n   }\n};\nvar req = http.request(options, function (res) {\n   res.setEncoding('utf8');\n   res.on('data', function (data) {\n      console.log(data);\n   });\n});\nreq.write(contents);\nreq.end();\n\n```\n\n- http.get(options, callback) http 模块还提供了一个更加简便的方法用于处理GET请求：http.get。它是 http.request 的简化版，唯一的区别在于：http.get自动将请求方法设为了 GET 请求，同时不需要手动调用 req.end()。\n\n```javascript\n//httprequest.js\nvar http = require('http');\nhttp.get({\n   host: 'www.byvoid.com'\n}, function (res) {\n   res.setEncoding('utf8');\n   res.on('data', function (data) {\n      console.log(data);\n   });\n});\n\n```\n\n- http.ClientRequest 是由 http.request 或 http.get 返回产生的对象，表示一 个已经产生而且正在进行中的 HTTP 请求，它提供一个 response 事件，即 http.request 或 http.get 第二个参数指定的回调函数的绑定对象。我们也可以显式地绑定这个事件的监听函数：\n\n```javascript\n//httpresponse.js\nvar http = require('http');\nvar req = http.get({host: 'www.byvoid.com'});\nreq.on('response', function(res) {\n \tres.setEncoding('utf8');\n \tres.on('data', function (data) {\n \tconsole.log(data);\n });\n});\n\n```\n\n> http.ClientRequest 像 http.ServerResponse 一样也提供了 write 和 end 函 数，用于向服务器发送请求体，通常用于 POST、PUT 等操作。所有写结束以后必须调用 end 函数以通知服务器，否则请求无效。相关函数：\n>\n> - request.abort()：终止正在发送的请求。\n> - request.setTimeout(timeout, [callback])：设置请求超时时间，timeout 为毫秒数。当请求超时以后，callback 将会被调用\n\n- http.clientResponse\n\n  http.ClientResponse 与 http.ServerRequest 相似，提供了三个事件 data、end 和 close，分别在数据到达、传输结束和连接结束时触发，其中 data 事件传递一个参数 chunk，表示接收到的数据。\n\n  http.ClientResponse 也提供了一些属性，用于表示请求的结果状态:\n\n  > statusCode : HTTP 状态码，如 200、404、500 \n  >\n  > httpVersion : HTTP 协议版本，通常是 1.0 或 1.1 \n  >\n  > headers : HTTP 请求头\n  >\n  > trailers : HTTP 请求尾（不常见）\n  >\n  > \n  >\n  > **http.ClientResponse 还提供了以下几个特殊的函数**\n  >\n  > response.setEncoding([encoding])：设置默认的编码，当 data 事件被触发\n  > 时，数据将会以 encoding 编码。默认值是 null，即不编码，以 Buffer 的形式存\n  > 储。常用编码为 utf8。\n  > response.pause()：暂停接收数据和发送事件，方便实现下载功能。\n  > response.resume()：从暂停的状态中恢复。\n  >\n  > 参考资料：http://nodejs.org/api/index.html\n\n## 第五章 Node.js Web开发实战\n\n### Node.js 工作原理\n\nNode.js 实现网站的工作原理。Node.js 和 PHP、 Perl、ASP、JSP 一样，目的都是实现动态网页，也就是说由服务器动态生成 HTML 页面。 之所以要这么做，是因为静态 HTML 的可扩展性非常有限，无法与用户有效交互。同时如 果有大量相似的内容，例如产品介绍页面，那么1000个产品就要1000个静态的 HTML 页面， 维护这1000个页面简直是一场灾难，因此动态生成 HTML 页面的技术应运而生。是在以 HTML 为主的模板中插入程序代码。这种方 式在2002年前后非常流行，但它的问题是页面和程序逻辑紧密耦合，任何一个网站规模变大 以后，都会遇到结构混乱，难以处理的问题。为了解决这种问题，以 MVC 架构为基础的平台逐渐兴起；Node.js 本质上和 Perl 或 C++ 一样，都可以作为 CGI 扩展被调用，但它还可以跳过 HTTP 服务器，因为它本身就是。传统的架构中 HTTP 服务器的角色会由 Apache、Nginx、IIS 之类 的软件来担任，而 Node.js 不需要。Node.js 提供了 http 模块，它是由 C++ 实现的，性能可靠，可以直接应用到生产环境。\n\n> MVC （Model-View-Controller，模型视图控制器）是一种软件的设计模式，它最早是 由 20 世纪 70 年代的 Smalltalk 语言提出的，即把一个复杂的软件工程分解为三个层面：模 型、视图和控制器。\n>\n> - 模型是对象及其数据结构的实现，通常包含数据库操作。\n> - 视图表示用户界面，在网站中通常就是 HTML 的组织结构。\n> - 控制器用于处理用户请求和数据流、复杂模型，将输出传递给视图。\n\n#### 了解 **http** 模块\n\nNode.js 由于不需要另外的 HTTP 服务器，因此减少了一层抽象，给性能带来不少提升， 但同时也因此而提高了开发难度。举例来说，下面是一个简单的HTTP服务，提交时以 POST 的方式将请求发送，然后将发送过来内容原封不动的返回给用户\n\n```javascript\nvar http = require('http');\nvar querystring = require('querystring');\nvar server = http.createServer(function (req, res) {\n   var post = '';\n   // req.headers;\n   // req.method;\n   // req.url;\n   // req.client;\n\n   req.on('data', function (chunk) {\n      post += chunk;\n   });\n   req.on('end', function () {\n      post = querystring.parse(post);\n      //以流的方式持续回给发送端\n      res.write(post.title);\n      res.write(post.text);\n      res.statusCode(200);\n      res.end();\n   });\n}).listen(3000);\n\n```\n\n### Express框架\n\n#### 简介\n\n> npm 提供了大量的第三方模块，其中不乏许多 Web 框架，我们没有必要重复发明轮子， 因而选择使用 Express 作为开发框架，因为它是目前最稳定、使用最广泛，而且 Node.js 官 方推荐的唯一一个 Web 开发框架。\n> Express （ http://expressjs.com/ ） 除了为 http 模块提供了更高层的接口外，还实现了 许多功能，其中包括：\n>\n> - 路由控制；\n> - 模板解析支持；\n> - 动态视图；\n> - 用户会话；\n> - CSRF 保护；\n> - 静态文件服务；\n> - 错误控制器；\n> - 访问日志；\n> - 缓存；\n> - 插件支持。\n>\n> 需要指出的是，Express 不是一个无所不包的全能框架，像 Rails 或 Django 那样实现了 模板引擎甚至 ORM （Object Relation Model，对象关系模型）。它只是一个轻量级的 Web 框架，多数功能只是对 HTTP 协议中常用操作的封装，更多的功能需要插件或者整合其他模块 来完成。\n\n#### 安装\n\n- 安装`$ npm install -g express`\n\n- 查看帮助：$ express --help\n\n- Express 例子(重新实现前面)\n\n  ```javascript\n  var express = require('express');\n  var app = express.createServer();\n  app.use(express.bodyParser());\n  app.all('/', function (req, res) {\n     res.send(req.body.title + req.body.text);\n  });\n  app.listen(3000);\n  \n  ```\n\n#### 创建工程\n\n> Express 在初始化一个项目的时候需要指定模板引擎，默认支持Jade和ejs，为了降低学\n> 习难度我们推荐使用 ejs ，同时暂时不添加 CSS 引擎和会话支持。\n\n1. 建立网站：\n\n   1. 新起一个文件目录\n\n      `$ mkdir nodetest && cd nodetest`\n\n   2. express创建ejs模板，如下右图\n\n      `$ npm install -g express && npm install -g express-generator`\n\n      `$ express -e nodeblog(-e 是ejs模板)`  \n\n      //`$express -t nodeblog(-t 是jade模板引擎)`\n\n      // express3之前 不需要另外install ，可直接创建ejs模板：$ express -t ejs nodeblog\n\n      //原因：express3+已经把创建一个APP的功能分离出来为express-generator，没它你创建不了应用程序\n\n   3. 进入生成的文件夹，打开package.json文件查看模板引擎，如下左图\n\n   4. 进入nodeblog文件夹\n\n      `$ cd nodeblog/`\n\n   5. 安装相关依赖模块\n\n      `$ npm install`\n\n   6. 启动服务\n\n      `$ npm start`\n\n      执行npm start其实是执行package.json中的script对应的对象中的start属性所对应的命令行\n\n   7. 可以用浏览器打开：http://localhost:3000 看到 Welcome to Express\n\n   **注：**ejs（Embedded JavaScript）是一个标签替换引擎，其语法与 ASP、PHP 相似，易于学习，目前被广泛应用。Express 默认提供的引擎是 jade，它颠覆了传统的模板引擎，制定了一套完整的语法用来生成 HTML 的每个标签结构，功能强大但不易学习。\n\n   | 左图                                                         | 右图                                                         |\n   | ------------------------------------------------------------ | ------------------------------------------------------------ |\n   | ![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222110947.png) | ![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222112735.png) |\n\n2. 基本结构\n\n   - 首先我们导入了 Express 模块，前面已经通过 npm 安装到了本地，在这里可以直接通过 require 获取\n\n   - app.js文件结构说明：\n\n     app.set 是 Express 的参数设置工具，接受一个键（key）和一个值（value），可用的参数如下所示。\n\n     - basepath：基础地址，通常用于 res.redirect() 跳转。\n     - views：视图文件的目录，存放模板文件。\n     - view engine：视图模板引擎。\n     - view options：全局视图参数对象。\n     - view cache：启用视图缓存。\n     - case sensitive routes：路径区分大小写。\n     - strict routing：严格路径，启用后不会忽略路径末尾的“ / ”。\n     - jsonp callback：开启透明的 JSONP 支持。\n\n   - routes/index.js 是路由文件，相当于控制器，用于组织展示的内容;\n\n   - index.ejs 是模板文件，即 routes/index.js 中调用的模板;\n\n3. 工作原理\n\n   - 当通过浏览器访问 app.js 建立的服务器时， 会看到一个简单的页面， 实际上它已经完成了许多透明的工作， 现在就让我们来解释一下它的工作机制， 以帮助理解网站的整 体架构。访问 http://localhost:3000，浏览器会向服务器发送以下请求：\n\n   ```\n   GET / HTTP/1.1\n   Host: localhost:3000\n   Connection: keep-alive\n   Cache-Control: max-age=0\n   User-Agent: Mozilla/5.0 AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.142\n    Safari/535.19\n   Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\n   Accept-Encoding: gzip,deflate,sdch\n   Accept-Language: zh;q=0.8,en-US;q=0.6,en;q=0.4\n   Accept-Charset: UTF-8,*;q=0.5\n   \n   ```\n\n   - app 会 解析请求的路径，调用相应的逻辑。app.js 中有一行内容是 app.get('/', routes.index)， 它的作用是规定路径为“/”的 GET 请求由 routes.index 函数处理。routes.index 通 过 res.render('index', { title: 'Express' }) 调用视图模板 index，传递 title 变量。最终视图模板生成 HTML 页面，返回给浏览器\n\n   - 浏览器在接收到内容以后，经过分析发现要获取 /stylesheets/style.css，因此会再次向服 务器发起请求。 app.js 中并没有一个路由规则指派到 /stylesheets/style.css， 但 app 通过 app.use(express.static(__dirname + '/public')) 配置了静态文件服务器，因此 /stylesheets/style.css 会定向到 app.js 所在目录的子目录中的文件 public/stylesheets/style.css；由 Express 创建的网站架构如下图所示。\n\n     ![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222124034.png)\n\n4. 创建路由规则\n\n   > 我们在浏览器中访问譬如 http://localhost:3000/abc 这样不存在的页面时，服务器会在 响应头中返回 404 Not Found 错误，这是因为 /abc 是一个不存在的路由规则，而且它也不是一个 public 目录下的文件，所以 Express返回了404 Not Found的错误\n\n   - 路径匹配\n\n     Express 还支持更高级的路径匹配模式。例 如我们想要展示一个用户的个人页面，路径为 /user/[username]，可以用下面的方法定义路由 规则：\n\n     将routes/index.js文件改成如下：\n\n     ```javascript\n     var express = require('express');\n     var router = express.Router();\n     \n     /* GET home page. */\n     router.get('/', function(req, res, next) {\n       res.render('index', { title: 'Express' });\n     });\n     //增加的代码\n     router.get('/user/:username', function(req, res, next) {\n       res.render('index', { title: 'Express'+ \" \" + req.params.username });\n     });\n     \n     module.exports = router;\n     \n     ```\n\n     然后重启app.js，访问：http://localhost:3000/user/nenhall\n\n     ![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222140808.png)\n\n     路径规则 /user/:username 会被自动编译为正则表达式，类似于`\\/user\\/(\\[^\\/]+)\\/?` 这样的形式。路径参数可以在响应函数中通过 req.params 的属性访问。\n\n5. 控制权转移\n\n   - Express 支持同一路径绑定多个路由响应函数，例如：\n\n     ```javascript\n     //router/index.js\n     \n     router.all('/user/:username', function(req, res, next) {\n       res.send('all methods captured');\n     });\n     \n     router.get('/user/:username', function(req, res, next) {\n       res.render('index', { title: 'Express'+ \" \" + req.params.username });\n     });\n     \n     ```\n\n     当你访问任何被两条同样的规则匹配到的路径时，会发现请求总是被前一条路由规则捕获，后面的规则会被忽略，原因是Express在处理路由规则时，会优先匹配定义的路由规则，因此后面相同的规则被屏蔽。\n\n   - Express 提供了路由控制权转移的方法， 通过调用 next()，会将路由控制权转移给后面的规则\n\n     ```javascript\n     //router/index.js\n     router.all('/user/:username', function(req, res, next) {\n       console.log('all methods captured');\n       next();\n         //这个路由规则实际上起到了中间件的作用，我们还可以改成下面这样，在这进行检查用户名的合法性，eg.\n         if (req.params.username == xxxxx) {\n             //do something\n             next();\n         } else {\n             //do something\n         }\n     });\n     \n     router.get('/user/:username', function(req, res, next) {\n       res.render('index', { title: 'Express'+ \" \" + req.params.username });\n     });\n     \n     ```\n\n     当访问被匹配到的路径时，如 http://localhost:3000/user/nenhall，会发现终端中打印了 all methods captured，而且浏览器中显示了 user: nenall。说明请求先被第一条路由规则捕获，完成 console.log 使用 next() 转移控制权，又被第二条规则捕获，向浏览器返回了信息。\n\n### 模板引擎\n\n#### 简介\n\n> 模板引擎（Template Engine）是一个从页面模板根据一定的规则生成 HTML 的工具\n\n模板引擎以数据和页面模板为输入，生成 HTML 页面，然后返回给控制器， 由控制器交回客户端。下图是模板引擎在 MVC 架构中的示意图\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222142954.png)   \n\n#### 使用模板引擎\n\n> 基于 JavaScript 的模板引擎有许多种实现，我们推荐使用 ejs （Embedded JavaScript）， 因为它十分简单，而且与 Express 集成良好。由于它是标准 JavaScript 实现的，因此它不仅 可以运行在服务器端，还可以运行在浏览器中\n>\n> ejs 的标签系统非常简单，它只有以下3种标签:\n>\n> - <% code %>：JavaScript 代码。\n> - <%= code %>：显示替换过 HTML 特殊字符的内容。\n> - <%- code %>：显示原始 HTML 内容。\n\n- 我们在 app.js 中通过以下两个语句设置了模板引擎和页面模板的位置：\n\n  ```javascript\n  // app.js\n  // view engine setup\n  app.set('views', path.join(__dirname, 'views'));\n  app.set('view engine', 'ejs');\n  // 表明要使用的模板引擎是 ejs， 页面模板在 views 子目录下。 在 routes/index.js 的 exports.index 函数中通过如下语句调用模板引擎：\n  \n  ```\n\n  ```javascript\n  // router/index.js\n  router.get('/', function(req, res, next) {\n    res.render('index', { title: 'Express' });\n  });\n  // res.render 的功能是调用模板引擎，并将其产生的页面直接返回给客户端。它接受 两个参数，第一个是模板的名称，即 views 目录下的模板文件名，不包含文件的扩展名；第二个参数是传递给模板的数据，用于模板翻译\n  // res.render('index', { title: 'Express' }); 这句代码的意思：引用了views目录下名为index.ejs文件，并把` { title: 'Express' }`这一个参数过去\n  \n  ```\n\n#### 页面布局\n\n> Express3+之后页面布局一起文件放在了/views/index.ejs文件中，在之前是有单独的layout.ejs文件\n\n#### 片段视图\n\n> Express 的视图系统还支持片段视图 （partials），它就是一个页面的片段，通常是重复的 内容，用于迭代显示。通过它你可以将相对独立的页面块分割出去\n\n```javascript\n// 1. 在router/index.js 增加如下代码\nrouter.get('/list', function(req, res) {\n  res.render('list', {\n  title: 'List',\n  items: [1991, 'byvoid', 'express', 'Node.js']\n  });\n });\n\n// 2. 在 views 目录下新建 list.ejs，内容是：\n<ul><%- partial('listitem', items) %></ul>\n// 3. 同时新建 listitem.ejs，内容是：\n<li><%= listitem %></li>\n// 4.访问 http://localhost:3000/list，可以在源代码中看到刚才的内容：\n\n```\n\npartial 是一个可以在视图中使用函数，它接受两个参数，第一个是片段视图的名称， 第二个可以是一个对象或一个数组，如果是一个对象，那么片段视图中上下文变量引用的就 是这个对象；如果是一个数组，那么其中每个元素依次被迭代应用到片段视图。片段视图中 上下文变量名就是视图文件名，例如上面的'listitem'。\n\n#### 视图助手\n\n> Express 提供了一种叫做视图助手的工具，它的功能是允许在视图中访问一个全局的函数 或对象，不用每次调用视图解析的时候单独传入。前面提到的 partial 就是一个视图助手。\n>\n> 视图助手有两类：静态视图助手和动态视图助手。\n>\n> - 静态视图助手：可以是任何类型的对象，包括接受任意参数的函数，但访问到的对象必须是与用户请求无关的，可以通过 app.helpers() 函数注册，它接受一个对象，对象的每个属性名称为视图助手的名称，属性值对应视图助手的值。\n> - 动态视图助手：只能是一个函数，这个函数不能接受参数，但可以访问 req 和 res 对象；通过 app.dynamicHelpers() 注册，方法与静态视图助手相同，但每个属性的值必须为一个函数，该函数提供 req 和 res\n\n### 建立微博网站\n\n- 功能点分析：一个完整的微博系统应该支持信息的评论、转发、圈 点用户等功能，但出于演示目的，我们不能一一实现所有功能，只是实现一个微博社交网站 的雏形。\n- 路由规划：整个网站的骨架部分，因为它处于整个架构的枢纽位置，相当于各个接口之间的粘合剂， 所以应该优先考虑。根据功能设计，我们把路由按照以下方案规划。\n  - 首页\n  - 用户的主页\n  - 发表信息\n  - 用户注册\n  - 用户登录\n  - 用户登出\n  - 用户状态细分：\n    - 发表信息以及用户登出页面必须是已登录用户才能操作的功能\n    - 用户注册和用户登入所面向的对象必须是未登入的用户\n    - 首页和用户主页则 针对已登入和未登入的用户显示不同的内容。\n- 具体实现省略，主要是用到第三方库\n- 关键点：app.post(‘/...', **function**(req, res) {})\n  - req.body 就是 POST 请求信息解析过后的对象， 例如我们要访问用户传递的\n    password 域的值，只需访问 req.body['password'] 即可。\n  - req.flash 是 Express 提供的一个奇妙的工具，通过它保存的变量只会在用户当前\n    和下一次的请求中被访问，之后会被清除，通过它我们可以很方便地实现页面的通知\n    和错误信息显示功能。\n  - res.redirect 是重定向功能，通过它会向用户返回一个 303 See Other 状态，通知\n    浏览器转向相应页面。\n  - crypto 是 Node.js 的一个核心模块，功能是加密并生成各种散列，使用它之前首先\n    要声明 var crypto = require('crypto')。我们代码中使用它计算了密码的散\n    列值。\n  - 通过 req.session.user = newUser 向会话对象写入了当前用户的信息，在后面\n    我们会通过它判断用户是否已经登录。","source":"_posts/Nodejs-入门篇.md","raw":"---\ntitle: Nodejs 入门篇\ncatalog: true\ndate: 2019-02-22 22:57:26\nsubtitle:\nheader-img: note_head_img.jpg\ncatagories:\n  - Objective-C\ntags:\n  - NSObject\n  - 底层原理\n---\n\nNode.js 学习笔记\n\n[TOC]\n\n## 前言\n\n> 本书首先简要介绍 Node.js，然后通过示例讲解 Node.js 的基本特性，再用案例式教学的方式讲述 如何用 Node.js 进行 Web 开发，接着探讨一些 Node.js 进阶话题，最后展示如何将一个 Node.js 应用部署到 生产环境中。\n\n## 简介\n\n> 本书共6章，分别讨论了 Node.js的背景、安装和配置方法、基本特性、核心模块以及一 些进阶话题。除此之外，还有2个附录，分别介绍了JavaScript 的高级特性和 Node.js 编程规 范。\n>\n> - Node.js 简介\n> - 安装和配置Node.js\n> - Node.js 快速入门\n> - Node.js 核心模块\n> - 使用 Node.js 进行 Web 开发\n> - Node.js 进阶话题\n> - 附录A JavaScript 的高级特性\n> - 附录B Node.js 编程规范\n\n## 第一章 Node.js 简介\n\n### Node.js是什么\n\n> Node.js， 或者 Node， 是一个可以让 JavaScript 运行在服务器端的平台。 它可以让 JavaScript 脱离浏览器的束缚运行在一般的服务器环境下，就像运行 Python、Perl、PHP、Ruby 程序一样。你可以用 Node.js 轻松地进行服务器端应用开发，Python、Perl、PHP、Ruby 能 做的事情 Node.js 几乎都能做，而且可以做得更好。\n>\n> Node.js 是一个为实时Web（Real-time Web）应用开发而诞生的平台，它从诞生之初就充分 考虑了在实时响应、超大规模数据要求下架构的可扩展性。这使得它摒弃了传统平台依靠多线 程来实现高并发的设计思路，而采用了单线程、异步式I/O、事件驱动式的程序设计模型。这些 特性不仅带来了巨大的性能提升，还减少了多线程程序设计的复杂性，进而提高了开发效率。\n>\n> Node.js 不是一种独立的语言，与 PHP、Python、Perl、Ruby 的“既是语言也是平台” 不同。Node.js 也不是一个 JavaScript 框架，不同于 CakePHP、Django、Rails。Node.js 更不 是浏览器端的库，不能与 jQuery、ExtJS 相提并论。Node.js 是一个让 JavaScript 运行在服务 端的开发平台，它让 JavaScript 成为脚本语言世界的一等公民，在服务端堪与 PHP、Python、 Perl、Ruby 平起平坐。\n\n### Node.js能做什么\n\n```\n>  正如 JavaScript 为客户端而生，Node.js 为网络而生。Node.js 能做的远不止开发一个网 站那么简单，使用 Node.js，你可以轻松地开发：\n> * 具有复杂逻辑的网站；\n> *  基于社交网络的大规模 Web 应用；\n> *  Web Socket 服务器；\n> *  TCP/UDP 套接字应用程序；\n> * 命令行工具；\n> * 交互式终端程序；\n> *  带有图形用户界面的本地应用程序；\n> * 单元测试工具；\n> * 客户端 JavaScript 编译器。\n>   Node.js 内建了 HTTP 服务器支持，也就是说你可以轻而易举地实现一个网站和服务器 的组合。这和 PHP、Perl 不一样，因为在使用 PHP 的时候，必须先搭建一个 Apache 之类的\n```\n\n### JavaScript 简史\n\n> 作为 Node.js 的基础，JavaScript 是一个完全为网络而诞生的语言。在今天看来，JavaScript\n> 具有其他诸多语言不具备的优势，例如速度快、开销小、容易学习等，但在一开始它却并不\n> 是这样。多年以来，JavaScript 因为其低效和兼容性差而广受诟病，一直是一个被人嘲笑的 “丑小鸭”，它在成熟之前经历了无数困难和坎坷，个中究竟，还要从它的诞生讲起。\n>\n> JavaScript 首次出现在1995年，正如现在的 Node.js 一样，当年 JavaScript 的诞生决不是 偶然的。在1992年，一个叫 Nombas 的公司开发了“C减减”（C minus minus，Cmm）语言， 后来改名为 ScriptEase。ScriptEase 最初的设计是将一种微型脚本语言与一个叫做 Espresso Page 的工具配合，使脚本能够在浏览器中运行，因此 ScriptEase 成为了第一个客户端脚本语言。\n>\n> 2000年左右，也就是 ASP 蒸蒸日上的年代，很多开发者开始学习 JScript。然而 JScript 在 当时并不是很受欢迎。随着后来 LAMP 的兴起，以及Web 2.0 时代的到来，Ajax 等一系列概念的提出，JavaScript 成了前端开发的代名词，同时服务端 JavaScript 也逐渐被人 遗忘。\n>\n> Node.js 是目前 CommonJS 规范最热门的一个实现，它基于 CommonJS 的 Modules/1.0 规 范实现了 Node.js 的模块，同时随着 CommonJS 规范的更新，Node.js 也在不断跟进。\n>\n> CommonJS 规范包括了模块（modules）、包（packages）、系统（system）、二进制（binary）、 控制台（console）、编码（encodings）、文件系统（filesystems）、套接字（sockets）、单元测 试（unit testing）等部分。\n\n- 官方 API 文档http://nodejs.org/api/。 \n- CNodeJS 社区看看http://cnodejs.org/\n\n## 第二章 安装和配置Node.js\n\n### Mac OS X 上安装Node.js\n\n> 在官方链接： http://nodejs.org 找到Download 链接，然后选择Macintosh Installer，下载安装包。下载完成后运行安装包， 根据提示完成安装；\n>\n> Node.js 和 npm 会被安装到 /usr/local/bin 目录下，在macos下源码编译那么需要安装 Xcode\n>\n> 安装成功后在终端执行命令，确认是正确安装：`$ node -v` //查看版本号\n\n### Windows 上安装Node.js\n\n> 大同小异，或者自行百度\n>\n> 安装程序不会询问你安装路径， Node.js 会被自动安装到 C:\\Program Files\\nodejs 或 C:\\Program Files (x86)\\nodejs（64位系统）目录下，并且会在系统的 PATH 环境变量中增加该\n>\n> 源码编译：Node.js 在 Windows 下只能通过 Microsoft Visual Studio 编译\n\n### Linux 上安装Node.js\n\n> 大同小异，或者自行百度\n>\n> 源码编译：Linux上需要使用 g++ 来编译 Node.js。在 Debian/Ubuntu 中，你可以 通过 apt-get install g++ 命令安装g++。在 Fedora/Redhat/CentOS 中，你可以使用 yum install gcc-c++ 安装\n\n### 安装多版本管理器\n\n> 迄今为止Node.js 更新速度还很快，有时候新版本还会将旧版本的一些 API 废除，以至 于写好的代码不能向下兼容。有时候你可能想要尝试一下新版本有趣的特性，但又想要保持 一个相对稳定的环境。基于这种需求，Node.js 的社区开发了多版本管理器，用于在一台机 器上维护多个版本的 Node.js 实例， 方便按需切换。\n>\n> Node 多版本管理器（Node Version Manager，nvm）是一个通用的叫法，它目前有许多不同的实现。通常我们说的 nvm 是指 或者n\n\n- nvm\n\n  https://github.com/creationix/nvm\n\n  如果你已经安装好了 Node.js 和 npm 环境，就可以直接使用 `$ npm install -g nvm`\n\n- n\n\n  https://github.com/visionmedia/n\n\n  如果你已经安装好了 Node.js 和 npm 环境，就可以直接使用 `$ npm install -g n` n不支持Windows\n\n  安装完 n 以后，在终端中运行 n --help 即可看到它的使用说明\n\n## 第三章 Node.js 快速入门\n\n### Hello World\n\n```javascript\n//打开终端\n$ vim hello.js\n\n//在hello.js文件中写代码\nconsole.log('Hello World');\n\n//运行hello.js文件\n$ node hello.js\n\n//输出\nHello World\n\n//我们可以把要执行的语句作为 node -e 的参数直接执行。\n$ node -e \"console.log('Hello World');\" \n//输出\nHello World\n```\n\n### 使用 **node** 的 REPL 模式\n\n> REPL （Read-eval-print loop），即输入—求值—输出循环，可以进入一个即 时求值的运行环境。运行无参数的 node 将会启动一个 JavaScript 的交互式 shell：\n\n```javascript\n$ node\n> console.log('Hello World'); Hello World\nundefined\n> consol.log('Hello World');\n```\n\n### 建立 HTTP 服务器\n\n> Node.js 是为网络而诞生的平台，但又与 ASP、PHP 有很大的不同，究竟不同在哪里呢？ 如果你有 PHP 开发经验，会知道在成功运行 PHP 之前先要配置一个功能强大而复杂的 HTTP 服务器，譬如 Apache、IIS 或 Nginx，还需要将 PHP 配置为 HTTP 服务器的模块，或者使用 FastCGI 协议调用 PHP 解释器。这种架构是“浏览器  HTTP 服务器  PHP 解释器”的组织 方式，而Node.js采用了一种不同的组织方式，如下图所示：\n>\n> Node.js 将“HTTP服务器”这一层抽离，直接面向浏览器用户。这种架构 从某种意义上来说是颠覆性的， 因而会让人心存疑虑：Node.js作为HTTP服务器的效率足够吗？会不会提高耦合程度？不在这里讨论这种架构的利弊\n\n​\t![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/Node.js与PHP的架构.png)\n\n- 建立一个名为 app.js 的文件，内容为：\n\n  ```javascript\n  //app.js\n  var http = require('http');\n  http.createServer(function(req, res) {\n   res.writeHead(200, {'Content-Type': 'text/html'});\n   res.write('<h1>Node.js</h1>');\n   res.end('<p>Hello World</p>');\n  }).listen(3000);\n  console.log(\"HTTP server is listening at port 3000.\");\n  ```\n\n- 接下来运行 node app.js命令，打开浏览器访问 http://127.0.0.1:3000，即可看到如下图所示的内容。\n\n- supervisor\n\n  > supervisor 可以帮助你实现这个功能，它会监视你对代码的改动，并自动重启 Node.js。 使用方法很简单，首先使用 npm 安装 supervisor：\n  >\n  > `$ npm install -g supervisor`\n  >\n  > 接下来，使用 supervisor 命令启动 app.js：\n  >\n  > `$ supervisor app.js`\n  >\n  > 当代码被改动时，运行的脚本会被终止，然后重新启动。\n\n### 异、同步读取文件\n\n- 异步\n\n  ```javascript\n  // 让我们看看在 Node.js 中如何用异步的方式读取一个文件，下面是一个例子：\n  //readfile.js\n  var fs = require('fs');\n  fs.readFile('file.txt', 'utf-8', function (err, data) {\n     if (err) {\n        console.error(err);\n     } else {\n        console.log(data);\n     }\n  });\n  console.log('end.');\n  // 运行的结果如下：\n  end.\n  Contents of the file.\n  ```\n\n  > fs.readFile 调用时所做的工作只是将异步式 I/O 请求发送给了操作系统，然后立即 返回并执行后面的语句，执行完以后进入事件循环监听事件。当 fs 接收到 I/O 请求完成的 事件时，事件循环会主动调用回调函数以完成后续工作\n  >\n  > Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。在开发者看来，事 件由 EventEmitter 对象提供。前面提到的 fs.readFile 和 http.createServer 的回 调函数都是通过 EventEmitter 来实现的\n\n  \n\n- 同步\n\n  ```javascript\n  //readfilesync.js\n  var fs = require('fs');\n  var data = fs.readFileSync('file.txt', 'utf-8');\n  console.log(data);\n  console.log('end.');\n  //运行的结果与前面不同， 如下所示：\n  $ node readfilesync.js Contents of the file.\n  end.\n  ```\n\n### Node.js 的事件循环机制\n\n> Node.js 在什么时候会进入事件循环呢？答案是 Node.js 程序由事件循环开始，到事件循 环结束，所有的逻辑都是事件的回调函数，所以 Node.js 始终在事件循环中，程序入口就是 事件循环第一个事件的回调函数。事件的回调函数在执行的过程中，可能会发出 I/O 请求或 直接发射（emit）事件，执行完毕后再返回事件循环，事件循环会检查事件队列中有没有未 处理的事件，直到程序结束。图3-5说明了事件循环的原理。\n\n​\t![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/node_event_runloop.png)\n\n### 模块和包\n\n> 模块（Module）和包（Package）是 Node.js 最重要的支柱。开发一个具有一定规模的程 序不可能只用一个文件，通常需要把各个功能拆分、封装，然后组合起来，模块正是为了实 现这种方式而诞生的。在浏览器 JavaScript 中，脚本模块的拆分和组合通常使用 HTML 的 script 标签来实现。Node.js 提供了 require 函数来调用其他模块，而且模块都是基于文件的，机制十分简单。Node.js 的模块和包机制的实现参照了 CommonJS 的标准， 但并未完全遵循\n\n#### 什么是模块\n\n> 模块是 Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是 JavaScript 代码、JSON 或者编译过的 C/C++ 扩展。\n>\n> 在前面的例子中，我们曾经用到了 var http = require('http')，其中 http 是 Node.js 的一个核心模块\n\n1. 创建模块\n   在 Node.js 中，创建一个模块非常简单，因为一个文件就是一个模块，我们要关注的问 题仅仅在于如何在其他文件中获取这个模块。Node.js 提供了 exports 和 require 两个对 象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获 取模块的 exports 对象。\n\n   - 让我们以一个例子来了解模块。创建一个 module.js 的文件，内容是：\n\n     ```javascript\n     //module.js\n     var name;\n     exports.setName = function (thyName) {\n        name = thyName;\n     };\n     exports.sayHello = function () {\n        console.log('Hello ' + name);\n     };\n     //在同一目录下创建 getmodule.js， 内容是：\n     //getmodule.js\n     var myModule = require('./module');\n     myModule.setName('mynodetest'); \n     myModule.sayHello();\n     //-------------------------------------------------//\n     //运行\n     $ node getmodule.js，\n     //结果：\n     Hello mynodetest\n     ```\n\n     在以上示例中，module.js 通过 exports 对象把 setName 和 sayHello 作为模块的访 问接口，在 getmodule.js 中通过 require('./module') 加载这个模块，然后就可以直接访 问 module.js 中 exports 对象的成员函数了。\n\n2. 覆盖 exports\n\n   - 有时候我们只是想把一个对象封装到模块中，例如：\n\n     ```javascript\n     //hello.js\n     function Hello() {\n        var name;\n        this.setName = function (thyName) {\n           name = thyName;\n        };\n        this.sayHello = function () {\n           console.log('Hello ' + name);\n        };\n     };\n     \n     module.exports = Hello;\n     \n     //gethello.js\n     //这样就可以直接获得这个对象了：\n     var Hello = require('./hello');\n     hello = new Hello();\n     hello.setName('BYVoid');\n     hello.sayHello();\n     ```\n\n     注意，模块接口的唯一变化是使用 module.exports = Hello 代替了 exports.Hello= Hello。在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。事实上，exports 本身仅仅是一个普通的空对象，即 {}，它专门用来声明接口，本 质上是通过它为模块闭包的内部建立了一个有限的访问接口\n\n#### 什么是包\n\n> 包是在模块基础上更深一步的抽象，Node.js 的包类似于 C/C++ 的函数库或者 Java/.Net 的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。Node.js 根 据 CommonJS 规范实现了包机制，开发了 npm来解决包的发布和获取需求。\n> Node.js 的包是一个目录，其中包含一个 JSON 格式的包说明文件 package.json。严格符 合 CommonJS 规范的包应该具备以下特征：\n>\n> - package.json 必须在包的顶层目录下；\n> - 二进制文件应该在 bin 目录下；\n> - JavaScript 代码应该在 lib 目录下；\n> - 文档应该在 doc 目录下；\n> - 单元测试应该在 test 目录下。\n>\n> Node.js 对包的要求并没有这么严格，只要顶层目录下有 package.json，并符合一些规范 即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 CommonJS 规范。\n\n- 以文件夹作为模块\n\n  > 模块与文件是一一对应的。文件不仅可以是 JavaScript 代码或二进制代码，还可以是一 个文件夹。最简单的包，就是一个作为文件夹的模块。\n\n  ```javascript\n  //somepackage/index.js exports.hello = function() {\n   console.log('Hello.');\n  };\n  //然后在 somepackage 之外建立 getpackage.js，内容如下：\n  //getpackage.js\n  var somePackage = require('./somepackage'); \n  somePackage.hello();\n  //运行 \n  $ node getpackage.js，\n  //控制台将输出结果 Hello.。\n  \n  ```\n\n- package.json\n\n  在前面的例子中的somepackage文件夹下，创建一个叫package.json的文件，内容如下：\n\n  **还可以进入somepackage目录，使用命令来生成一个package.json:`$ npm init -f `**\n\n  ```javascript\n  {\n  \t\"main\" : \"./lib/interface.js\"\n  }\n  \n  ```\n\n  然后将 index.js 重命名为 interface.js 并放入 lib 子文件夹下。以同样的方式再次调用这个 包，依然可以正常使用。\n\n  因为Node.js 在调用某个包时，会首先检查包中 package.json 文件的 main 字段，将其作为 包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作 为包的接口。\n\n  > package.json 是 CommonJS 规定的用来描述包的文件，完全符合规范的 package.json 文 件应该含有以下字段。\n  >\n  > - name：包的名称，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含\n  >   空格。\n  > - description：包的简要说明。\n  > - version：符合语义化版本识别 规范的版本字符串。\n  > - keywords：关键字数组，通常用于搜索。\n  > - maintainers：维护者数组，每个元素要包含 name、email （可选）、web （可选）\n  >   字段。\n  > - contributors：贡献者数组，格式与maintainers相同。包的作者应该是贡献者\n  >   数组的第一个元素。\n  > - bugs：提交bug的地址，可以是网址或者电子邮件地址。\n  > - licenses：许可证数组，每个元素要包含 type （许可证的名称）和 url （链接到\n  >   许可证文本的地址）字段。\n  > - repositories：仓库托管地址数组，每个元素要包含 type（仓库的类型，如 git ）、url （仓库的地址）和 path （相对于仓库的路径，可选）字段。\n  > - dependencies：包的依赖，一个关联数组，由包名称和版本号组成。\n\n#### Node.js 包管理器\n\n> Node.js包管理器，即npm是 Node.js 官方提供的包管理工具①，它已经成了 Node.js 包的 标准发布平台，用于 Node.js 包的发布、传播、依赖控制。npm 提供了命令行工具，使你可 以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。\n\n- 获取一个包\n\n  ```\n  //使用 npm 安装包的命令格式为：\n  npm [install/i] [package_name]\n  //例如你要安装 express，可以在命令行运行：\n  $ npm install express\n  或者：$ npm i express\n  //安装成功后，放置在当前目录的 node_modules 子目录下\n  \n  ```\n\n- 本地模式和全局模式\n\n  > npm在默认情况下会从http://npmjs.org搜索或下载包，将包安装到当前目录的node_modules 子目录下。\n  >\n  > npm 还有另一种不同的安装模式被成为全局模式，使用方法为：\n  >\n  > $ npm [install/i] -g [package_name]\n  >\n  > eg.: $ npm install -g supervisor 命令，就是以全局模式安装 supervisor。\n\n  \n\n  - 当我们使用全局模 式安装时，npm 会将包安装到系统目录，如 /usr/local/lib/node_modules/，同时 package.json 文 件中 bin 字段包含的文件会被链接到 /usr/local/bin/\n\n  - 使用全局模式安装的包并不能直接在 JavaScript 文件中用 require 获得，因为 require 不会搜索 /usr/local/lib/node_modules/。\n\n    ​\t\t\t\t**表 - 本地模式与全局模式**\n\n    | 模式     | 可通过 require 使用 | 注册PATH |\n    | -------- | ------------------- | -------- |\n    | 本地模式 | 是                  | 否       |\n    | 全局模式 | 否                  | 是       |\n\n- 创建全局链接\n\n  > npm 提供了一个链接命令 npm link，它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 require 使用，但通过 npm link命令 可以打破这一限制。\n\n  例子：\n\n  我们已经通过 npm install -g express 安装了 express， 这时在工程的目录下运行命令：\n\n  ```\n  $ npm link express\n  ./node_modules/express -> /usr/local/lib/node_modules/express\n  \n  ```\n\n  我们可以在 node_modules 子目录中发现一个指向安装到全局的包的符号链接。通过这 种方法，我们就可以把全局包当本地包来使用了。\n\n#### 调试\n\n- 命令行调试：在命令行下执行 node debug debug.js，将会启动调试工具\n\n```\n$ node debug debug.js\n< debugger listening on port 5858 connecting... ok\nbreak in /home/byvoid/debug.js:1\n1 var a = 1;\n2 var b = 'world';\n3 var c = function(x) { debug>\n\n```\n\n​\t**Node.js 调试命令**\n\n| 命令                                    | 功能                                  |\n| --------------------------------------- | ------------------------------------- |\n| run                                     | 执行脚本，在第一行暂停                |\n| restart                                 | 重新执行脚本                          |\n| cont, c                                 | 继续执行，直到遇到下一个断点 单步执行 |\n| next, n                                 | 单步执行                              |\n| step, s                                 | 单步执行并进入函数                    |\n| out, o                                  | 从函数中步出                          |\n| setBreakpoint(), sb()                   | 在当前行设置断点                      |\n| setBreakpoint(‘f()’), sb(...)           | 在函数f的第一行设置断点               |\n| setBreakpoint(‘script.js’, 20), sb(...) | 在script.js 的第20行设置断点          |\n| clearBreakpoint, cb(…)                  | 清除所有断点                          |\n| backtrace, bt                           | 显示当前的调用栈                      |\n| list(5)                                 | 显示当前执行到的前后5行代码           |\n| watch(expr)                             | 把表达式 expr 加入监视列表            |\n| unwatch(expr)                           | 把表达式 expr 加入监视列表            |\n| watchers                                | 显示监视列表中所有的表达式和值        |\n| repl                                    | 在当前上下文打开即时求值环境          |\n| kill                                    | 终止当前执行的脚本                    |\n| scripts                                 | 显示当前已加载的所有脚本              |\n| version                                 | 显示 V8 的版本                        |\n\n- 远程调试：V8 提供的调试功能是基于 TCP 协议的，因此 Node.js 可以轻松地实现远程调试。在命令行下使用以下两个语句之一可以打开调试服务器：\n\n  - 打开调试服务器\n\n    ```\n    node --debug[=port] script.js \n    node --debug-brk[=port] script.js\n    \n    ```\n\n  - 当调试服务器启动以后，可以用命令行调试工具作为调试客户端连接，例如：\n\n    ```\n    //在一个终端中\n    $ node --debug-brk debug.js debugger listening on port 5858\n    //在另一个终端中\n    $ node debug 127.0.0.1:5858\n    connecting... ok\n    debug> n\n    break in /home/byvoid/debug.js:2\n    1 var a = 1;\n    2 var b = 'world';\n    3 var c = function (x) {\n    4 console.log('hello ' + x + a); debug>\n    \n    ```\n\n- 使用 node-inspector 调试 Node.js\n\n  > 大部分基于 Node.js 的应用都是运行在浏览器中的，例如强大的调试工具 node-inspector。 node-inspector 是一个完全基于 Node.js 的开源在线调试工具，提供了强大的调试功能和友好 的用户界面，它的使用方法十分简便。\n\n  - 首先，使用 npm install -g node-inspector 命令安装 node-inspector，然后在终 端中通过 node --debug-brk=5858 debug.js 命令连接你要除错的脚本的调试服务器， 启动 node-inspector：\n  - $ node-inspector\n  - 在浏览器中打开 http://127.0.0.1:8080/debug?port=5858，即可显示出优雅的 Web 调试工 具\n\n- 使用 Eclipse 调试 Node.js(这里不做介绍)\n\n  \n\n## 第四章 Node.js 核心模块\n\n> 核心模块是 Node.js 的心脏，它由一些精简而高效的库组成，为 Node.js 提供了基本的 API。本章中，我们挑选了一部分最常用的核心模块加以详细介绍，主要内容包括：\n>\n> - 全局对象； \n> - 常用工具；\n> - 事件机制；\n> - 文件系统访问；\n> - HTTP 服务器与客户端。\n\n### 全局对象\n\n#### 全局对象\n\n> JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可 以在程序的任何地方访问，即全局变量。在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。\n\n#### 全局变量\n\n> global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：\n>\n> - 在最外层定义的变量；\n> - 全局对象的属性；\n> - 隐式定义的变量（未定义直接赋值的变量）。\n\n### 常用工具 util\n\n> util 是一个 Node.js 核心模块，提供常用函数的集合，用于弥补核心 JavaScript 的功能 过于精简的不足。\n\n#### util.inherits\n\n> util.inherits(constructor, superConstructor) 是一个实现对象间原型继承 的函数。JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的，具体细节我们在附录A中讨论， 在这里我们只介绍 util.inherits 的用法，示例如下：\n\n```javascript\nvar util = require('util');\n\nfunction Base(){\n    this.name = 'base',\n    this.base = 1991,\n    this.sayHello = function(){\n        console.log('hello :'+ this.name);\n    };\n};\n\nBase.prototype.showName = function(){\n    console.log('this.name :', this.name);\n};\n\nfunction Sub(){\n    this.name = 'sub'\n};\n\nutil.inherits(Sub, Base);\n\nvar objBase = new Base();\nobjBase.showName();\nobjBase.sayHello();\nconsole.log(objBase);\n\nvar objSub = new Sub();\nobjSub.showName();\n// objSub.sayHello();\nconsole.log('objSub :', objSub);\nconsole.log('util.inspect(obj) :', util.inspect(objBase,true,2,true));\n\n//输入结果：\n➜  http0test node module.js\nthis.name : base\nhello :base\nBase { name: 'base', base: 1991, sayHello: [Function] }\nthis.name : sub\nobjSub : Sub { name: 'sub' }\nutil.inspect(obj) : Base {\n  name: 'base',\n  base: 1991,\n  sayHello:\n   { [Function]\n     [length]: 0,\n     [name]: '',\n     [arguments]: null,\n     [caller]: null,\n     [prototype]: { [constructor]: [Circular] } } }\n\n```\n\n\n\n#### util.inspect\n\n> util.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。\n>\n> - showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。\n> - depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 \n> - color 值如果为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。\n\n### 事件驱动 events\n\n> events 是 Node.js 最重要的模块，没有“之一”，原因是 Node.js 本身架构就是事件式 的，而它提供了唯一的接口，所以堪称 Node.js 事件编程的基石。events 模块不仅用于用户代码与 Node.js 下层事件循环的交互，还几乎被所有的模块依赖。\n\n#### 事件发射器（events.EventEmitter）\n\n> events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就 是事件发射与事件监听器功能的封装\n\n- 常规事件\n\n  ```javascript\n  //我们介绍一下EventEmitter常用的API。\n  //为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数 listener。\n  EventEmitter.on(event, listener) \n  //发射 event 事件，传递若干可选参数到事件监听器的参数表。\n  EventEmitter.emit(event, [arg1], [arg2], [...]) \n  //为指定事件注册一个单次监听器， 即监听器最多只会触发一次，触发后立刻解除该监听器。\n  EventEmitter.once(event, listener) \n  //移除指定事件的某个监听器，listener 必须是该事件已经注册过的监听器。\n  EventEmitter.removeListener(event, listener) \n  //移除所有事件的所有监听器，如果指定 event，则移除指定事件的所有监听器。\n  EventEmitter.removeAllListeners([event]) \n  //更详细的 API 文档参见 http://nodejs.org/api/events.html。\n  \n  ```\n\n  ```javascript\n  var events = require('events');\n  var emitter = new event.EventEmitter();\n  \n  emitter.on('someEvent', function (arg1, arg2) {\n    console.log('listener1', arg1, arg2);\n  });\n  \n  emitter.on('someEvent', function (arg1, arg2) {\n    console.log('listener2', arg1, arg2);\n  });\n  \n  emitter.emit('someEvent', 'byvoid', 1991);\n  // 运行的结果是：\n  // listener1 byvoid 1991 \n  // listener2 byvoid 1991\n  \n  ```\n\n- error事件\n\n  > EventEmitter 定义了一个特殊的事件 error，它包含了“错误”的语义，我们在遇到 异常的时候通常会发射 error 事件。当 error 被发射时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并打印调用栈\n\n  ```javascript\n  var events = require('events');\n  var emitter = new events.EventEmitter();\n  emitter.emit('error');\n  \n  ```\n\n### 文件系统 fs\n\n> fs 模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接等 POSIX 文件系统操作\n\n- fs.readFile: \n\n  fs.readFile(filename,[encoding],[callback(err,data)]) 是最简单的读取 文件的函数。它接受一个必选参数 filename，表示要读取的文件名。第二个参数 encoding 是可选的，表示文件的字符编码（不指定编码格式，则data形式输出）。callback 是回调函数，用于接收文件的内容。\n\n  ```javascript\n  // app.js\n  var fs = require('fs');\n  fs.readFile('output.txt', 'utf-8', function (err, data) {\n     if (err) {\n        console.error(err);\n     } else {\n        console.log('fileData: :', data);\n     }\n  });\n  //输出\n  ➜  nodejs_note node app.js\n  fileData: : nenhall 学习node.js 笔记\n  \n  ```\n\n- fs.readFileSync\n\n  fs.readFileSync(filename, [encoding])是 fs.readFile 同步的版本。它接受 的参数和 fs.readFile 相同，而读取到的文件内容会以函数返回值的形式返回。如果有错 误发生，fs 将会抛出异常，你需要使用 try 和 catch 捕捉并处理异常。\n\n- fs.open\n\n  fs.open(path, flags, [mode], [callback(err, fd)])是 POSIX open 函数的 封装，与 C 语言标准库中的 fopen 函数类似。它接受两个必选参数，path 为文件的路径， flags 可以是以下值:\n\n  ```\n  r ：以读取模式打开文件。\n  r+ ：以读写模式打开文件。\n  w ：以写入模式打开文件，如果文件不存在则创建。\n  w+ ：以读写模式打开文件，如果文件不存在则创建。\n  a ：以追加模式打开文件，如果文件不存在则创建。\n  a+ ：以读取追加模式打开文件，如果文件不存在则创建。\n  mode 参数用于创建文件时给文件指定权限，默认是 0666\n  callback：回调函数将会传递一个文 件描述符 fd\n  \n  注意：文件权限指的是 POSIX 操作系统中对文件读取和访问权限的规范，通常用一个八进制数来表示。例如 0754 表示文件所有者的权限是 7 （读、写、执行），同组的用户权限是 5 （读、执行），其他用户的权限是 4（读）， 写成字符表示就是 -rwxr-xr--。\n  \n  ```\n\n- fs.read \n\n  fs.read(fd, buffer, offset, length, position, [callback(err, bytesRead, buffer)])是 POSIX read 函数的封装，相比 fs.readFile 提供了更底层的接口。fs.read 的功能是从指定的文件描述符:\n\n  ```\n  fd 中读取数据并写入 \n  buffer 指向的缓冲区对象。\n  offset 是 buffer 的写入偏移量。\n  length 是要从文件中读取的字节数。\n  position 是文件读取的起始 位置， 如果 position 的值为 null ， 则会从当前文件指针的位置读取。\n  回调函数传递 bytesRead 和 buffer，分别表示读取的字节数和缓冲区对象。\n  \n  ```\n\n  相关函数：\n\n  fs.openSync(path, flags, [mode]) 对 fs.closeSync(fd)\n\n  fs.read(fd, buffer, offset, length, position, callback()])  对 fs.close(fd, [callback(err)])\n\n### HTTP 服务器与客户端\n\n> Node.js 标准库提供了 http 模块，其中封装了一个高效的 HTTP 服务器和一个简易的 HTTP 客户端。http.Server 是一个基于事件的 HTTP 服务器，它的核心由 Node.js 下层 C++ 部分实现，而接口由 JavaScript 封装，兼顾了高性能与简易性。http.request 则是一个 HTTP 客户端工具，用于向 HTTP 服务器发起请求\n\n#### HTTP 服务\n\n> http.Server 是 http 模块中的 HTTP 服务器对象，用 Node.js 做的所有基于 HTTP 协 议的系统，如网站、社交应用甚至代理服务器，都是基于 http.Server 实现的。它提供了 一套封装级别很低的 API，仅仅是流控制和简单的消息解析，所有的高层功能都要通过它的 接口来实现。\n\n- 实现一个服务器\n\n  ```javascript\n  //app.js\n  var http = require('http');\n  // 创建了一个 http.Server 的实例\n  // 将一个函数作为 HTTP 请求处理函数,这个函数接受两个参数，分别是请求对象(req)和响应对象(res)\n  http.createServer(function (req, res) {\n      //响应代码200（表示请求成功）,指定响应头为'Content-Type': 'text/html'\n     res.writeHead(200, {\n        'Content-Type': 'text/html'\n     });\n     // 写入响应体 '<h1>Node.js</h1>'\n     res.write('<h1>Node.js</h1>');\n     // 通过 res.end 结束并发送\n     res.end('<p>Hello World</p>');\n  }).listen(3000);//listen 函数，启动服务器并监听 3000 端口\n  \n  console.log(\"HTTP server is listening at port 3000.\");\n  \n  ```\n\n- **http.Server** 的事件\n\n  http.Server 是一个基于事件的 HTTP 服务器，所有的请求都被封装为独立的事件， 开发者只需要对它的事件编写响应函数即可实现 HTTP 服务器的所有功能。它继承自 EventEmitter\n\n  - request：当客户端请求到来时，该事件被触发，提供两个参数 req 和res，分别是http.ServerRequest 和 http.ServerResponse 的实例，表示请求和响应信息。\n  - connection ：当 TCP 连接建立时， 该事件被触发， 提供一个参数 socket ， 为net.Socket 的实例。connection 事件的粒度要大于 request ， 因为客户端在Keep-Alive 模式下可能会在同一个连接内发送多次请求。\n  - close ：当服务器关闭时，该事件被触发。注意不是在用户连接断开时。\n\n- **http.ServerRequest**\n\n  1. http.ServerRequest 是 HTTP 请求的信息，是后端开发者最关注的内容。它一般由 http.Server 的 request 事件发送，作为第一个参数传递，通常简称 request 或 req\n\n  2. HTTP 请求一般可以分为两部分：请求头（Request Header）和请求体（Requset Body）。 以上内容由于长度较短都可以在请求头解析完成后立即读取。\n\n  3. 请求体可能相对较长， 需要一定的时间传输，因此 http.ServerRequest 提供了以下3个事件用于控制请求体 传输。\n\n     - data ：当请求体数据到来时，该事件被触发。该事件提供一个参数 chunk，表示接收到的数据。如果该事件没有被监听，那么请求体将会被抛弃。该事件可能会被调用多次。\n     - end ：当请求体数据传输完成时，该事件被触发，此后将不会再有数据到来。\n     - close： 用户当前请求结束时，该事件被触发。不同于 end，如果用户强制终止了传输，也还是调用close。\n\n  4. **ServerRequest** 的属性表\n\n     | 名称        | 含义                                                        |\n     | ----------- | ----------------------------------------------------------- |\n     | complete    | 客户端请求是否已经发送完成                                  |\n     | httpVersion | HTTP 协议版本，通常是 1.0 或 1.1                            |\n     | method      | HTTP 请求方法，如 GET、POST、PUT、DELETE 等                 |\n     | url         | 原始的请求路径，例如/static/image/x.jpg 或/user?name=byvoid |\n     | headers     | HTTP 请求头                                                 |\n     | trailers    | HTTP 请求尾（不常见）                                       |\n     | connection  | 当前 HTTP 连接套接字，为 net.Socket 的实例                  |\n     | socket      | connection 属性的别名                                       |\n     | client      | client 属性的别名                                           |\n\n  5. 获取 GET 请求内容\n\n     由于 GET 请求直接被嵌入在路径 中，URL是完整的请求路径，包括了 ? 后面的部分，因此你可以手动解析后面的内容作为 GET 请求的参数\n\n     ```javascript\n     var http = require('http');\n     var url = require('url');\n     var util = require('util');\n     \n     http.createServer(function (req, res) {\n        res.writeHead(200, {\n           'Content-Type': 'text/plain'\n        });\n        res.end(util.inspect(url.parse(req.url, true)));\n     }).listen(3000);\n     \n     //浏览器中输入：http://127.0.0.1:3000/user?name=byvoid&email=byvoid@byvoid.com\n     //展示：\n     Url {\n       protocol: null,\n       slashes: null,\n       auth: null,\n       host: null,\n       port: null,\n       hostname: null,\n       hash: null,\n       search: '?name=byvoid&email=byvoid@byvoid.com',\n       query:\n        [Object: null prototype] { name: 'byvoid', email: 'byvoid@byvoid.com' },\n       pathname: '/user',\n       path: '/user?name=byvoid&email=byvoid@byvoid.com',\n       href: '/user?name=byvoid&email=byvoid@byvoid.com' }\n     \n     ```\n\n     \n\n  6. 获取 POST 请求内容\n\n     HTTP 协议 1.1 版本提供了8种标准的请求方法，其中最常见的就是 GET 和 POST。相比 GET 请求把所有的内容编码到访问路径中， POST 请求的内容全部都在请求体中。 http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作，譬如上传文件。而很多时候我们可能并不需要理会请求体的内容，恶意的POST 请求会大大消耗服务器的资源。所以 Node.js 默认是不会解析请求体的，当你需要的时候， 需要手动来做\n\n     ```javascript\n     var http = require('http');\n     var url = require('url');\n     var util = require('util');\n     \n     var querystring = require('querystring');\n     http.createServer(function(req, res) {\n        var post = '';\n        req.on('end', function(){\n           post = querystring.parse(post);\n           res.end(util.inspect(post));\n        });\n     }).listen(3000);\n     \n     ```\n\n     上面代码并没有在请求响应函数中向客户端返回信息，而是定义了一个 post 变量。通过 req 的 data 事件监听函数，每当接受到请求体的数据， 就累加到 post 变量中。在 end 事件触发后，通过 querystring.parse 将 post 解析为真正的 POST 请求格式，然后向客户端返回\n\n     **注意：**不要在真正的生产应用中使用上面这种简单的方法来获取 POST 请求，因为它有严重的效率和安全问题\n\n     \n\n  7. **http.ServerResponse**\n     http.ServerResponse 是返回给客户端的信息，决定了用户最终能看到的结果。它 也是由 http.Server 的 request 事件发送的， 作为第二个参数传递， 一般简称为 response 或 res。\n\n     > http.ServerResponse 有三个重要的成员函数，用于返回响应头、响应内容以及结束 请求。\n     >\n     > - response.writeHead(statusCode, [headers])：向请求的客户端发送响应头。\n     >   statusCode 是 HTTP 状态码，如 200 （请求成功）、404 （未找到）等。headers\n     >   是一个类似关联数组的对象，表示响应头的每个属性。该函数在一个请求内最多只\n     >   能调用一次，如果不调用，则会自动生成一个响应头。\n     > - response.write(data, [encoding])：向请求的客户端发送响应内容。data 是\n     >   一个 Buffer 或字符串，表示要发送的内容。如果 data 是字符串，那么需要指定\n     >   encoding 来说明它的编码方式，默认是 utf-8。在 response.end 调用之前，\n     >   response.write 可以被多次调用。\n     > - response.end([data], [encoding])：结束响应，告知客户端所有发送已经完\n     >   成。当所有要返回的内容发送完毕的时候，该函数 必须 被调用一次。它接受两个可\n     >   选参数，意义和 response.write 相同。如果不调用该函数，客户端将永远处于\n     >   等待状态。\n\n#### HTTP 客户端\n\n> http 模块提供了两个函数 http.request 和 http.get，功能是作为客户端向 HTTP 服务器发起请求。\n>\n> http.request(options, callback) 发起 HTTP 请求。接受两个参数，option 是\n> 一个类似关联数组的对象，表示请求的参数，callback 是请求的回调函数。option\n> 常用的参数如下所示。\n>\n> - host ：请求网站的域名或 IP 地址。\n> - port ：请求网站的端口，默认 80。\n> - method ：请求方法，默认是 GET。\n> - path ：请求的相对于根的路径，默认是“/”。QueryString 应该包含在其中。例如 /search?query=byvoid。\n> - headers ：一个关联数组对象，为请求头的内容。\n> - callback 传递一个参数，为 http.ClientResponse 的实例。\n>   http.request 返回一个 http.ClientRequest 的实例。\n\n下面是一个通过 http.request 发送 POST 请求的代码：\n\n```javascript\n//httprequest.js\nvar http = require('http');\nvar querystring = require('querystring');\nvar contents = querystring.stringify({\n   name: 'byvoid',\n   email: 'byvoid@byvoid.com',\n   address: 'Zijing 2#, Tsinghua University',\n});\nvar options = {\n   host: 'www.byvoid.com',\n   path: '/application/node/post.php',\n   method: 'POST',\n   headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'Content-Length': contents.length\n   }\n};\nvar req = http.request(options, function (res) {\n   res.setEncoding('utf8');\n   res.on('data', function (data) {\n      console.log(data);\n   });\n});\nreq.write(contents);\nreq.end();\n\n```\n\n- http.get(options, callback) http 模块还提供了一个更加简便的方法用于处理GET请求：http.get。它是 http.request 的简化版，唯一的区别在于：http.get自动将请求方法设为了 GET 请求，同时不需要手动调用 req.end()。\n\n```javascript\n//httprequest.js\nvar http = require('http');\nhttp.get({\n   host: 'www.byvoid.com'\n}, function (res) {\n   res.setEncoding('utf8');\n   res.on('data', function (data) {\n      console.log(data);\n   });\n});\n\n```\n\n- http.ClientRequest 是由 http.request 或 http.get 返回产生的对象，表示一 个已经产生而且正在进行中的 HTTP 请求，它提供一个 response 事件，即 http.request 或 http.get 第二个参数指定的回调函数的绑定对象。我们也可以显式地绑定这个事件的监听函数：\n\n```javascript\n//httpresponse.js\nvar http = require('http');\nvar req = http.get({host: 'www.byvoid.com'});\nreq.on('response', function(res) {\n \tres.setEncoding('utf8');\n \tres.on('data', function (data) {\n \tconsole.log(data);\n });\n});\n\n```\n\n> http.ClientRequest 像 http.ServerResponse 一样也提供了 write 和 end 函 数，用于向服务器发送请求体，通常用于 POST、PUT 等操作。所有写结束以后必须调用 end 函数以通知服务器，否则请求无效。相关函数：\n>\n> - request.abort()：终止正在发送的请求。\n> - request.setTimeout(timeout, [callback])：设置请求超时时间，timeout 为毫秒数。当请求超时以后，callback 将会被调用\n\n- http.clientResponse\n\n  http.ClientResponse 与 http.ServerRequest 相似，提供了三个事件 data、end 和 close，分别在数据到达、传输结束和连接结束时触发，其中 data 事件传递一个参数 chunk，表示接收到的数据。\n\n  http.ClientResponse 也提供了一些属性，用于表示请求的结果状态:\n\n  > statusCode : HTTP 状态码，如 200、404、500 \n  >\n  > httpVersion : HTTP 协议版本，通常是 1.0 或 1.1 \n  >\n  > headers : HTTP 请求头\n  >\n  > trailers : HTTP 请求尾（不常见）\n  >\n  > \n  >\n  > **http.ClientResponse 还提供了以下几个特殊的函数**\n  >\n  > response.setEncoding([encoding])：设置默认的编码，当 data 事件被触发\n  > 时，数据将会以 encoding 编码。默认值是 null，即不编码，以 Buffer 的形式存\n  > 储。常用编码为 utf8。\n  > response.pause()：暂停接收数据和发送事件，方便实现下载功能。\n  > response.resume()：从暂停的状态中恢复。\n  >\n  > 参考资料：http://nodejs.org/api/index.html\n\n## 第五章 Node.js Web开发实战\n\n### Node.js 工作原理\n\nNode.js 实现网站的工作原理。Node.js 和 PHP、 Perl、ASP、JSP 一样，目的都是实现动态网页，也就是说由服务器动态生成 HTML 页面。 之所以要这么做，是因为静态 HTML 的可扩展性非常有限，无法与用户有效交互。同时如 果有大量相似的内容，例如产品介绍页面，那么1000个产品就要1000个静态的 HTML 页面， 维护这1000个页面简直是一场灾难，因此动态生成 HTML 页面的技术应运而生。是在以 HTML 为主的模板中插入程序代码。这种方 式在2002年前后非常流行，但它的问题是页面和程序逻辑紧密耦合，任何一个网站规模变大 以后，都会遇到结构混乱，难以处理的问题。为了解决这种问题，以 MVC 架构为基础的平台逐渐兴起；Node.js 本质上和 Perl 或 C++ 一样，都可以作为 CGI 扩展被调用，但它还可以跳过 HTTP 服务器，因为它本身就是。传统的架构中 HTTP 服务器的角色会由 Apache、Nginx、IIS 之类 的软件来担任，而 Node.js 不需要。Node.js 提供了 http 模块，它是由 C++ 实现的，性能可靠，可以直接应用到生产环境。\n\n> MVC （Model-View-Controller，模型视图控制器）是一种软件的设计模式，它最早是 由 20 世纪 70 年代的 Smalltalk 语言提出的，即把一个复杂的软件工程分解为三个层面：模 型、视图和控制器。\n>\n> - 模型是对象及其数据结构的实现，通常包含数据库操作。\n> - 视图表示用户界面，在网站中通常就是 HTML 的组织结构。\n> - 控制器用于处理用户请求和数据流、复杂模型，将输出传递给视图。\n\n#### 了解 **http** 模块\n\nNode.js 由于不需要另外的 HTTP 服务器，因此减少了一层抽象，给性能带来不少提升， 但同时也因此而提高了开发难度。举例来说，下面是一个简单的HTTP服务，提交时以 POST 的方式将请求发送，然后将发送过来内容原封不动的返回给用户\n\n```javascript\nvar http = require('http');\nvar querystring = require('querystring');\nvar server = http.createServer(function (req, res) {\n   var post = '';\n   // req.headers;\n   // req.method;\n   // req.url;\n   // req.client;\n\n   req.on('data', function (chunk) {\n      post += chunk;\n   });\n   req.on('end', function () {\n      post = querystring.parse(post);\n      //以流的方式持续回给发送端\n      res.write(post.title);\n      res.write(post.text);\n      res.statusCode(200);\n      res.end();\n   });\n}).listen(3000);\n\n```\n\n### Express框架\n\n#### 简介\n\n> npm 提供了大量的第三方模块，其中不乏许多 Web 框架，我们没有必要重复发明轮子， 因而选择使用 Express 作为开发框架，因为它是目前最稳定、使用最广泛，而且 Node.js 官 方推荐的唯一一个 Web 开发框架。\n> Express （ http://expressjs.com/ ） 除了为 http 模块提供了更高层的接口外，还实现了 许多功能，其中包括：\n>\n> - 路由控制；\n> - 模板解析支持；\n> - 动态视图；\n> - 用户会话；\n> - CSRF 保护；\n> - 静态文件服务；\n> - 错误控制器；\n> - 访问日志；\n> - 缓存；\n> - 插件支持。\n>\n> 需要指出的是，Express 不是一个无所不包的全能框架，像 Rails 或 Django 那样实现了 模板引擎甚至 ORM （Object Relation Model，对象关系模型）。它只是一个轻量级的 Web 框架，多数功能只是对 HTTP 协议中常用操作的封装，更多的功能需要插件或者整合其他模块 来完成。\n\n#### 安装\n\n- 安装`$ npm install -g express`\n\n- 查看帮助：$ express --help\n\n- Express 例子(重新实现前面)\n\n  ```javascript\n  var express = require('express');\n  var app = express.createServer();\n  app.use(express.bodyParser());\n  app.all('/', function (req, res) {\n     res.send(req.body.title + req.body.text);\n  });\n  app.listen(3000);\n  \n  ```\n\n#### 创建工程\n\n> Express 在初始化一个项目的时候需要指定模板引擎，默认支持Jade和ejs，为了降低学\n> 习难度我们推荐使用 ejs ，同时暂时不添加 CSS 引擎和会话支持。\n\n1. 建立网站：\n\n   1. 新起一个文件目录\n\n      `$ mkdir nodetest && cd nodetest`\n\n   2. express创建ejs模板，如下右图\n\n      `$ npm install -g express && npm install -g express-generator`\n\n      `$ express -e nodeblog(-e 是ejs模板)`  \n\n      //`$express -t nodeblog(-t 是jade模板引擎)`\n\n      // express3之前 不需要另外install ，可直接创建ejs模板：$ express -t ejs nodeblog\n\n      //原因：express3+已经把创建一个APP的功能分离出来为express-generator，没它你创建不了应用程序\n\n   3. 进入生成的文件夹，打开package.json文件查看模板引擎，如下左图\n\n   4. 进入nodeblog文件夹\n\n      `$ cd nodeblog/`\n\n   5. 安装相关依赖模块\n\n      `$ npm install`\n\n   6. 启动服务\n\n      `$ npm start`\n\n      执行npm start其实是执行package.json中的script对应的对象中的start属性所对应的命令行\n\n   7. 可以用浏览器打开：http://localhost:3000 看到 Welcome to Express\n\n   **注：**ejs（Embedded JavaScript）是一个标签替换引擎，其语法与 ASP、PHP 相似，易于学习，目前被广泛应用。Express 默认提供的引擎是 jade，它颠覆了传统的模板引擎，制定了一套完整的语法用来生成 HTML 的每个标签结构，功能强大但不易学习。\n\n   | 左图                                                         | 右图                                                         |\n   | ------------------------------------------------------------ | ------------------------------------------------------------ |\n   | ![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222110947.png) | ![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222112735.png) |\n\n2. 基本结构\n\n   - 首先我们导入了 Express 模块，前面已经通过 npm 安装到了本地，在这里可以直接通过 require 获取\n\n   - app.js文件结构说明：\n\n     app.set 是 Express 的参数设置工具，接受一个键（key）和一个值（value），可用的参数如下所示。\n\n     - basepath：基础地址，通常用于 res.redirect() 跳转。\n     - views：视图文件的目录，存放模板文件。\n     - view engine：视图模板引擎。\n     - view options：全局视图参数对象。\n     - view cache：启用视图缓存。\n     - case sensitive routes：路径区分大小写。\n     - strict routing：严格路径，启用后不会忽略路径末尾的“ / ”。\n     - jsonp callback：开启透明的 JSONP 支持。\n\n   - routes/index.js 是路由文件，相当于控制器，用于组织展示的内容;\n\n   - index.ejs 是模板文件，即 routes/index.js 中调用的模板;\n\n3. 工作原理\n\n   - 当通过浏览器访问 app.js 建立的服务器时， 会看到一个简单的页面， 实际上它已经完成了许多透明的工作， 现在就让我们来解释一下它的工作机制， 以帮助理解网站的整 体架构。访问 http://localhost:3000，浏览器会向服务器发送以下请求：\n\n   ```\n   GET / HTTP/1.1\n   Host: localhost:3000\n   Connection: keep-alive\n   Cache-Control: max-age=0\n   User-Agent: Mozilla/5.0 AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.142\n    Safari/535.19\n   Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\n   Accept-Encoding: gzip,deflate,sdch\n   Accept-Language: zh;q=0.8,en-US;q=0.6,en;q=0.4\n   Accept-Charset: UTF-8,*;q=0.5\n   \n   ```\n\n   - app 会 解析请求的路径，调用相应的逻辑。app.js 中有一行内容是 app.get('/', routes.index)， 它的作用是规定路径为“/”的 GET 请求由 routes.index 函数处理。routes.index 通 过 res.render('index', { title: 'Express' }) 调用视图模板 index，传递 title 变量。最终视图模板生成 HTML 页面，返回给浏览器\n\n   - 浏览器在接收到内容以后，经过分析发现要获取 /stylesheets/style.css，因此会再次向服 务器发起请求。 app.js 中并没有一个路由规则指派到 /stylesheets/style.css， 但 app 通过 app.use(express.static(__dirname + '/public')) 配置了静态文件服务器，因此 /stylesheets/style.css 会定向到 app.js 所在目录的子目录中的文件 public/stylesheets/style.css；由 Express 创建的网站架构如下图所示。\n\n     ![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222124034.png)\n\n4. 创建路由规则\n\n   > 我们在浏览器中访问譬如 http://localhost:3000/abc 这样不存在的页面时，服务器会在 响应头中返回 404 Not Found 错误，这是因为 /abc 是一个不存在的路由规则，而且它也不是一个 public 目录下的文件，所以 Express返回了404 Not Found的错误\n\n   - 路径匹配\n\n     Express 还支持更高级的路径匹配模式。例 如我们想要展示一个用户的个人页面，路径为 /user/[username]，可以用下面的方法定义路由 规则：\n\n     将routes/index.js文件改成如下：\n\n     ```javascript\n     var express = require('express');\n     var router = express.Router();\n     \n     /* GET home page. */\n     router.get('/', function(req, res, next) {\n       res.render('index', { title: 'Express' });\n     });\n     //增加的代码\n     router.get('/user/:username', function(req, res, next) {\n       res.render('index', { title: 'Express'+ \" \" + req.params.username });\n     });\n     \n     module.exports = router;\n     \n     ```\n\n     然后重启app.js，访问：http://localhost:3000/user/nenhall\n\n     ![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222140808.png)\n\n     路径规则 /user/:username 会被自动编译为正则表达式，类似于`\\/user\\/(\\[^\\/]+)\\/?` 这样的形式。路径参数可以在响应函数中通过 req.params 的属性访问。\n\n5. 控制权转移\n\n   - Express 支持同一路径绑定多个路由响应函数，例如：\n\n     ```javascript\n     //router/index.js\n     \n     router.all('/user/:username', function(req, res, next) {\n       res.send('all methods captured');\n     });\n     \n     router.get('/user/:username', function(req, res, next) {\n       res.render('index', { title: 'Express'+ \" \" + req.params.username });\n     });\n     \n     ```\n\n     当你访问任何被两条同样的规则匹配到的路径时，会发现请求总是被前一条路由规则捕获，后面的规则会被忽略，原因是Express在处理路由规则时，会优先匹配定义的路由规则，因此后面相同的规则被屏蔽。\n\n   - Express 提供了路由控制权转移的方法， 通过调用 next()，会将路由控制权转移给后面的规则\n\n     ```javascript\n     //router/index.js\n     router.all('/user/:username', function(req, res, next) {\n       console.log('all methods captured');\n       next();\n         //这个路由规则实际上起到了中间件的作用，我们还可以改成下面这样，在这进行检查用户名的合法性，eg.\n         if (req.params.username == xxxxx) {\n             //do something\n             next();\n         } else {\n             //do something\n         }\n     });\n     \n     router.get('/user/:username', function(req, res, next) {\n       res.render('index', { title: 'Express'+ \" \" + req.params.username });\n     });\n     \n     ```\n\n     当访问被匹配到的路径时，如 http://localhost:3000/user/nenhall，会发现终端中打印了 all methods captured，而且浏览器中显示了 user: nenall。说明请求先被第一条路由规则捕获，完成 console.log 使用 next() 转移控制权，又被第二条规则捕获，向浏览器返回了信息。\n\n### 模板引擎\n\n#### 简介\n\n> 模板引擎（Template Engine）是一个从页面模板根据一定的规则生成 HTML 的工具\n\n模板引擎以数据和页面模板为输入，生成 HTML 页面，然后返回给控制器， 由控制器交回客户端。下图是模板引擎在 MVC 架构中的示意图\n\n![](https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222142954.png)   \n\n#### 使用模板引擎\n\n> 基于 JavaScript 的模板引擎有许多种实现，我们推荐使用 ejs （Embedded JavaScript）， 因为它十分简单，而且与 Express 集成良好。由于它是标准 JavaScript 实现的，因此它不仅 可以运行在服务器端，还可以运行在浏览器中\n>\n> ejs 的标签系统非常简单，它只有以下3种标签:\n>\n> - <% code %>：JavaScript 代码。\n> - <%= code %>：显示替换过 HTML 特殊字符的内容。\n> - <%- code %>：显示原始 HTML 内容。\n\n- 我们在 app.js 中通过以下两个语句设置了模板引擎和页面模板的位置：\n\n  ```javascript\n  // app.js\n  // view engine setup\n  app.set('views', path.join(__dirname, 'views'));\n  app.set('view engine', 'ejs');\n  // 表明要使用的模板引擎是 ejs， 页面模板在 views 子目录下。 在 routes/index.js 的 exports.index 函数中通过如下语句调用模板引擎：\n  \n  ```\n\n  ```javascript\n  // router/index.js\n  router.get('/', function(req, res, next) {\n    res.render('index', { title: 'Express' });\n  });\n  // res.render 的功能是调用模板引擎，并将其产生的页面直接返回给客户端。它接受 两个参数，第一个是模板的名称，即 views 目录下的模板文件名，不包含文件的扩展名；第二个参数是传递给模板的数据，用于模板翻译\n  // res.render('index', { title: 'Express' }); 这句代码的意思：引用了views目录下名为index.ejs文件，并把` { title: 'Express' }`这一个参数过去\n  \n  ```\n\n#### 页面布局\n\n> Express3+之后页面布局一起文件放在了/views/index.ejs文件中，在之前是有单独的layout.ejs文件\n\n#### 片段视图\n\n> Express 的视图系统还支持片段视图 （partials），它就是一个页面的片段，通常是重复的 内容，用于迭代显示。通过它你可以将相对独立的页面块分割出去\n\n```javascript\n// 1. 在router/index.js 增加如下代码\nrouter.get('/list', function(req, res) {\n  res.render('list', {\n  title: 'List',\n  items: [1991, 'byvoid', 'express', 'Node.js']\n  });\n });\n\n// 2. 在 views 目录下新建 list.ejs，内容是：\n<ul><%- partial('listitem', items) %></ul>\n// 3. 同时新建 listitem.ejs，内容是：\n<li><%= listitem %></li>\n// 4.访问 http://localhost:3000/list，可以在源代码中看到刚才的内容：\n\n```\n\npartial 是一个可以在视图中使用函数，它接受两个参数，第一个是片段视图的名称， 第二个可以是一个对象或一个数组，如果是一个对象，那么片段视图中上下文变量引用的就 是这个对象；如果是一个数组，那么其中每个元素依次被迭代应用到片段视图。片段视图中 上下文变量名就是视图文件名，例如上面的'listitem'。\n\n#### 视图助手\n\n> Express 提供了一种叫做视图助手的工具，它的功能是允许在视图中访问一个全局的函数 或对象，不用每次调用视图解析的时候单独传入。前面提到的 partial 就是一个视图助手。\n>\n> 视图助手有两类：静态视图助手和动态视图助手。\n>\n> - 静态视图助手：可以是任何类型的对象，包括接受任意参数的函数，但访问到的对象必须是与用户请求无关的，可以通过 app.helpers() 函数注册，它接受一个对象，对象的每个属性名称为视图助手的名称，属性值对应视图助手的值。\n> - 动态视图助手：只能是一个函数，这个函数不能接受参数，但可以访问 req 和 res 对象；通过 app.dynamicHelpers() 注册，方法与静态视图助手相同，但每个属性的值必须为一个函数，该函数提供 req 和 res\n\n### 建立微博网站\n\n- 功能点分析：一个完整的微博系统应该支持信息的评论、转发、圈 点用户等功能，但出于演示目的，我们不能一一实现所有功能，只是实现一个微博社交网站 的雏形。\n- 路由规划：整个网站的骨架部分，因为它处于整个架构的枢纽位置，相当于各个接口之间的粘合剂， 所以应该优先考虑。根据功能设计，我们把路由按照以下方案规划。\n  - 首页\n  - 用户的主页\n  - 发表信息\n  - 用户注册\n  - 用户登录\n  - 用户登出\n  - 用户状态细分：\n    - 发表信息以及用户登出页面必须是已登录用户才能操作的功能\n    - 用户注册和用户登入所面向的对象必须是未登入的用户\n    - 首页和用户主页则 针对已登入和未登入的用户显示不同的内容。\n- 具体实现省略，主要是用到第三方库\n- 关键点：app.post(‘/...', **function**(req, res) {})\n  - req.body 就是 POST 请求信息解析过后的对象， 例如我们要访问用户传递的\n    password 域的值，只需访问 req.body['password'] 即可。\n  - req.flash 是 Express 提供的一个奇妙的工具，通过它保存的变量只会在用户当前\n    和下一次的请求中被访问，之后会被清除，通过它我们可以很方便地实现页面的通知\n    和错误信息显示功能。\n  - res.redirect 是重定向功能，通过它会向用户返回一个 303 See Other 状态，通知\n    浏览器转向相应页面。\n  - crypto 是 Node.js 的一个核心模块，功能是加密并生成各种散列，使用它之前首先\n    要声明 var crypto = require('crypto')。我们代码中使用它计算了密码的散\n    列值。\n  - 通过 req.session.user = newUser 向会话对象写入了当前用户的信息，在后面\n    我们会通过它判断用户是否已经登录。","slug":"Nodejs-入门篇","published":1,"updated":"2019-02-23T05:39:18.412Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsh3gt73001jncezrv4upza3","content":"<p>Node.js 学习笔记</p>\n<p>[TOC]</p>\n<h2><span id=\"前言\">前言</span></h2>\n<blockquote>\n<p>本书首先简要介绍 Node.js，然后通过示例讲解 Node.js 的基本特性，再用案例式教学的方式讲述 如何用 Node.js 进行 Web 开发，接着探讨一些 Node.js 进阶话题，最后展示如何将一个 Node.js 应用部署到 生产环境中。</p>\n</blockquote>\n<h2><span id=\"简介\">简介</span></h2>\n<blockquote>\n<p>本书共6章，分别讨论了 Node.js的背景、安装和配置方法、基本特性、核心模块以及一 些进阶话题。除此之外，还有2个附录，分别介绍了JavaScript 的高级特性和 Node.js 编程规 范。</p>\n<ul>\n<li>Node.js 简介</li>\n<li>安装和配置Node.js</li>\n<li>Node.js 快速入门</li>\n<li>Node.js 核心模块</li>\n<li>使用 Node.js 进行 Web 开发</li>\n<li>Node.js 进阶话题</li>\n<li>附录A JavaScript 的高级特性</li>\n<li>附录B Node.js 编程规范</li>\n</ul>\n</blockquote>\n<h2><span id=\"第一章-nodejs-简介\">第一章 Node.js 简介</span></h2>\n<h3><span id=\"nodejs是什么\">Node.js是什么</span></h3>\n<blockquote>\n<p>Node.js， 或者 Node， 是一个可以让 JavaScript 运行在服务器端的平台。 它可以让 JavaScript 脱离浏览器的束缚运行在一般的服务器环境下，就像运行 Python、Perl、PHP、Ruby 程序一样。你可以用 Node.js 轻松地进行服务器端应用开发，Python、Perl、PHP、Ruby 能 做的事情 Node.js 几乎都能做，而且可以做得更好。</p>\n<p>Node.js 是一个为实时Web（Real-time Web）应用开发而诞生的平台，它从诞生之初就充分 考虑了在实时响应、超大规模数据要求下架构的可扩展性。这使得它摒弃了传统平台依靠多线 程来实现高并发的设计思路，而采用了单线程、异步式I/O、事件驱动式的程序设计模型。这些 特性不仅带来了巨大的性能提升，还减少了多线程程序设计的复杂性，进而提高了开发效率。</p>\n<p>Node.js 不是一种独立的语言，与 PHP、Python、Perl、Ruby 的“既是语言也是平台” 不同。Node.js 也不是一个 JavaScript 框架，不同于 CakePHP、Django、Rails。Node.js 更不 是浏览器端的库，不能与 jQuery、ExtJS 相提并论。Node.js 是一个让 JavaScript 运行在服务 端的开发平台，它让 JavaScript 成为脚本语言世界的一等公民，在服务端堪与 PHP、Python、 Perl、Ruby 平起平坐。</p>\n</blockquote>\n<h3><span id=\"nodejs能做什么\">Node.js能做什么</span></h3>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  正如 JavaScript 为客户端而生，<span class=\"keyword\">Node</span>.<span class=\"title\">js</span> 为网络而生。<span class=\"keyword\">Node</span>.<span class=\"title\">js</span> 能做的远不止开发一个网 站那么简单，使用 <span class=\"keyword\">Node</span>.<span class=\"title\">js</span>，你可以轻松地开发：</span><br><span class=\"line\">&gt; * 具有复杂逻辑的网站；</span><br><span class=\"line\">&gt; *  基于社交网络的大规模 Web 应用；</span><br><span class=\"line\">&gt; *  Web Socket 服务器；</span><br><span class=\"line\">&gt; *  TCP/UDP 套接字应用程序；</span><br><span class=\"line\">&gt; * 命令行工具；</span><br><span class=\"line\">&gt; * 交互式终端程序；</span><br><span class=\"line\">&gt; *  带有图形用户界面的本地应用程序；</span><br><span class=\"line\">&gt; * 单元测试工具；</span><br><span class=\"line\">&gt; * 客户端 JavaScript 编译器。</span><br><span class=\"line\">&gt;   <span class=\"keyword\">Node</span>.<span class=\"title\">js</span> 内建了 HTTP 服务器支持，也就是说你可以轻而易举地实现一个网站和服务器 的组合。这和 PHP、Perl 不一样，因为在使用 PHP 的时候，必须先搭建一个 Apache 之类的</span><br></pre></td></tr></table></figure>\n<h3><span id=\"javascript-简史\">JavaScript 简史</span></h3>\n<blockquote>\n<p>作为 Node.js 的基础，JavaScript 是一个完全为网络而诞生的语言。在今天看来，JavaScript<br>\n具有其他诸多语言不具备的优势，例如速度快、开销小、容易学习等，但在一开始它却并不<br>\n是这样。多年以来，JavaScript 因为其低效和兼容性差而广受诟病，一直是一个被人嘲笑的 “丑小鸭”，它在成熟之前经历了无数困难和坎坷，个中究竟，还要从它的诞生讲起。</p>\n<p>JavaScript 首次出现在1995年，正如现在的 Node.js 一样，当年 JavaScript 的诞生决不是 偶然的。在1992年，一个叫 Nombas 的公司开发了“C减减”（C minus minus，Cmm）语言， 后来改名为 ScriptEase。ScriptEase 最初的设计是将一种微型脚本语言与一个叫做 Espresso Page 的工具配合，使脚本能够在浏览器中运行，因此 ScriptEase 成为了第一个客户端脚本语言。</p>\n<p>2000年左右，也就是 ASP 蒸蒸日上的年代，很多开发者开始学习 JScript。然而 JScript 在 当时并不是很受欢迎。随着后来 LAMP 的兴起，以及Web 2.0 时代的到来，Ajax 等一系列概念的提出，JavaScript 成了前端开发的代名词，同时服务端 JavaScript 也逐渐被人 遗忘。</p>\n<p>Node.js 是目前 CommonJS 规范最热门的一个实现，它基于 CommonJS 的 Modules/1.0 规 范实现了 Node.js 的模块，同时随着 CommonJS 规范的更新，Node.js 也在不断跟进。</p>\n<p>CommonJS 规范包括了模块（modules）、包（packages）、系统（system）、二进制（binary）、 控制台（console）、编码（encodings）、文件系统（filesystems）、套接字（sockets）、单元测 试（unit testing）等部分。</p>\n</blockquote>\n<ul>\n<li>官方 API 文档http://nodejs.org/api/。</li>\n<li>CNodeJS 社区看看http://cnodejs.org/</li>\n</ul>\n<h2><span id=\"第二章-安装和配置nodejs\">第二章 安装和配置Node.js</span></h2>\n<h3><span id=\"mac-os-x-上安装nodejs\">Mac OS X 上安装Node.js</span></h3>\n<blockquote>\n<p>在官方链接： <a href=\"http://nodejs.org\" target=\"_blank\" rel=\"noopener\">http://nodejs.org</a> 找到Download 链接，然后选择Macintosh Installer，下载安装包。下载完成后运行安装包， 根据提示完成安装；</p>\n<p>Node.js 和 npm 会被安装到 /usr/local/bin 目录下，在macos下源码编译那么需要安装 Xcode</p>\n<p>安装成功后在终端执行命令，确认是正确安装：<code>$ node -v</code> //查看版本号</p>\n</blockquote>\n<h3><span id=\"windows-上安装nodejs\">Windows 上安装Node.js</span></h3>\n<blockquote>\n<p>大同小异，或者自行百度</p>\n<p>安装程序不会询问你安装路径， Node.js 会被自动安装到 C:\\Program Files\\nodejs 或 C:\\Program Files (x86)\\nodejs（64位系统）目录下，并且会在系统的 PATH 环境变量中增加该</p>\n<p>源码编译：Node.js 在 Windows 下只能通过 Microsoft Visual Studio 编译</p>\n</blockquote>\n<h3><span id=\"linux-上安装nodejs\">Linux 上安装Node.js</span></h3>\n<blockquote>\n<p>大同小异，或者自行百度</p>\n<p>源码编译：Linux上需要使用 g++ 来编译 Node.js。在 Debian/Ubuntu 中，你可以 通过 apt-get install g++ 命令安装g++。在 Fedora/Redhat/CentOS 中，你可以使用 yum install gcc-c++ 安装</p>\n</blockquote>\n<h3><span id=\"安装多版本管理器\">安装多版本管理器</span></h3>\n<blockquote>\n<p>迄今为止Node.js 更新速度还很快，有时候新版本还会将旧版本的一些 API 废除，以至 于写好的代码不能向下兼容。有时候你可能想要尝试一下新版本有趣的特性，但又想要保持 一个相对稳定的环境。基于这种需求，Node.js 的社区开发了多版本管理器，用于在一台机 器上维护多个版本的 Node.js 实例， 方便按需切换。</p>\n<p>Node 多版本管理器（Node Version Manager，nvm）是一个通用的叫法，它目前有许多不同的实现。通常我们说的 nvm 是指 或者n</p>\n</blockquote>\n<ul>\n<li>\n<p>nvm</p>\n<p><a href=\"https://github.com/creationix/nvm\" target=\"_blank\" rel=\"noopener\">https://github.com/creationix/nvm</a></p>\n<p>如果你已经安装好了 Node.js 和 npm 环境，就可以直接使用 <code>$ npm install -g nvm</code></p>\n</li>\n<li>\n<p>n</p>\n<p><a href=\"https://github.com/visionmedia/n\" target=\"_blank\" rel=\"noopener\">https://github.com/visionmedia/n</a></p>\n<p>如果你已经安装好了 Node.js 和 npm 环境，就可以直接使用 <code>$ npm install -g n</code> n不支持Windows</p>\n<p>安装完 n 以后，在终端中运行 n --help 即可看到它的使用说明</p>\n</li>\n</ul>\n<h2><span id=\"第三章-nodejs-快速入门\">第三章 Node.js 快速入门</span></h2>\n<h3><span id=\"hello-world\">Hello World</span></h3>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//打开终端</span></span><br><span class=\"line\">$ vim hello.js</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在hello.js文件中写代码</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello World'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行hello.js文件</span></span><br><span class=\"line\">$ node hello.js</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\">Hello World</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//我们可以把要执行的语句作为 node -e 的参数直接执行。</span></span><br><span class=\"line\">$ node -e <span class=\"string\">\"console.log('Hello World');\"</span> </span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\">Hello World</span><br></pre></td></tr></table></figure>\n<h3><span id=\"使用-node-的-repl-模式\">使用 <strong>node</strong> 的 REPL 模式</span></h3>\n<blockquote>\n<p>REPL （Read-eval-print loop），即输入—求值—输出循环，可以进入一个即 时求值的运行环境。运行无参数的 node 将会启动一个 JavaScript 的交互式 shell：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node</span><br><span class=\"line\">&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello World'</span>); Hello World</span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\">&gt; consol.log(<span class=\"string\">'Hello World'</span>);</span><br></pre></td></tr></table></figure>\n<h3><span id=\"建立-http-服务器\">建立 HTTP 服务器</span></h3>\n<blockquote>\n<p>Node.js 是为网络而诞生的平台，但又与 ASP、PHP 有很大的不同，究竟不同在哪里呢？ 如果你有 PHP 开发经验，会知道在成功运行 PHP 之前先要配置一个功能强大而复杂的 HTTP 服务器，譬如 Apache、IIS 或 Nginx，还需要将 PHP 配置为 HTTP 服务器的模块，或者使用 FastCGI 协议调用 PHP 解释器。这种架构是“浏览器  HTTP 服务器  PHP 解释器”的组织 方式，而Node.js采用了一种不同的组织方式，如下图所示：</p>\n<p>Node.js 将“HTTP服务器”这一层抽离，直接面向浏览器用户。这种架构 从某种意义上来说是颠覆性的， 因而会让人心存疑虑：Node.js作为HTTP服务器的效率足够吗？会不会提高耦合程度？不在这里讨论这种架构的利弊</p>\n</blockquote>\n<p>​\t<img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/Node.js%E4%B8%8EPHP%E7%9A%84%E6%9E%B6%E6%9E%84.png\" alt></p>\n<ul>\n<li>\n<p>建立一个名为 app.js 的文件，内容为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//app.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\"> res.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'text/html'</span>&#125;);</span><br><span class=\"line\"> res.write(<span class=\"string\">'&lt;h1&gt;Node.js&lt;/h1&gt;'</span>);</span><br><span class=\"line\"> res.end(<span class=\"string\">'&lt;p&gt;Hello World&lt;/p&gt;'</span>);</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">3000</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"HTTP server is listening at port 3000.\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>接下来运行 node app.js命令，打开浏览器访问 <a href=\"http://127.0.0.1:3000\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3000</a>，即可看到如下图所示的内容。</p>\n</li>\n<li>\n<p>supervisor</p>\n<blockquote>\n<p>supervisor 可以帮助你实现这个功能，它会监视你对代码的改动，并自动重启 Node.js。 使用方法很简单，首先使用 npm 安装 supervisor：</p>\n<p><code>$ npm install -g supervisor</code></p>\n<p>接下来，使用 supervisor 命令启动 app.js：</p>\n<p><code>$ supervisor app.js</code></p>\n<p>当代码被改动时，运行的脚本会被终止，然后重新启动。</p>\n</blockquote>\n</li>\n</ul>\n<h3><span id=\"异-同步读取文件\">异、同步读取文件</span></h3>\n<ul>\n<li>\n<p>异步</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 让我们看看在 Node.js 中如何用异步的方式读取一个文件，下面是一个例子：</span></span><br><span class=\"line\"><span class=\"comment\">//readfile.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\">fs.readFile(<span class=\"string\">'file.txt'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'end.'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 运行的结果如下：</span></span><br><span class=\"line\">end.</span><br><span class=\"line\">Contents <span class=\"keyword\">of</span> the file.</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>fs.readFile 调用时所做的工作只是将异步式 I/O 请求发送给了操作系统，然后立即 返回并执行后面的语句，执行完以后进入事件循环监听事件。当 fs 接收到 I/O 请求完成的 事件时，事件循环会主动调用回调函数以完成后续工作</p>\n<p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。在开发者看来，事 件由 EventEmitter 对象提供。前面提到的 fs.readFile 和 http.createServer 的回 调函数都是通过 EventEmitter 来实现的</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>\n<p>同步</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//readfilesync.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = fs.readFileSync(<span class=\"string\">'file.txt'</span>, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'end.'</span>);</span><br><span class=\"line\"><span class=\"comment\">//运行的结果与前面不同， 如下所示：</span></span><br><span class=\"line\">$ node readfilesync.js Contents <span class=\"keyword\">of</span> the file.</span><br><span class=\"line\">end.</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3><span id=\"nodejs-的事件循环机制\">Node.js 的事件循环机制</span></h3>\n<blockquote>\n<p>Node.js 在什么时候会进入事件循环呢？答案是 Node.js 程序由事件循环开始，到事件循 环结束，所有的逻辑都是事件的回调函数，所以 Node.js 始终在事件循环中，程序入口就是 事件循环第一个事件的回调函数。事件的回调函数在执行的过程中，可能会发出 I/O 请求或 直接发射（emit）事件，执行完毕后再返回事件循环，事件循环会检查事件队列中有没有未 处理的事件，直到程序结束。图3-5说明了事件循环的原理。</p>\n</blockquote>\n<p>​\t<img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/node_event_runloop.png\" alt></p>\n<h3><span id=\"模块和包\">模块和包</span></h3>\n<blockquote>\n<p>模块（Module）和包（Package）是 Node.js 最重要的支柱。开发一个具有一定规模的程 序不可能只用一个文件，通常需要把各个功能拆分、封装，然后组合起来，模块正是为了实 现这种方式而诞生的。在浏览器 JavaScript 中，脚本模块的拆分和组合通常使用 HTML 的 script 标签来实现。Node.js 提供了 require 函数来调用其他模块，而且模块都是基于文件的，机制十分简单。Node.js 的模块和包机制的实现参照了 CommonJS 的标准， 但并未完全遵循</p>\n</blockquote>\n<h4><span id=\"什么是模块\">什么是模块</span></h4>\n<blockquote>\n<p>模块是 Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是 JavaScript 代码、JSON 或者编译过的 C/C++ 扩展。</p>\n<p>在前面的例子中，我们曾经用到了 var http = require(‘http’)，其中 http 是 Node.js 的一个核心模块</p>\n</blockquote>\n<ol>\n<li>\n<p>创建模块<br>\n在 Node.js 中，创建一个模块非常简单，因为一个文件就是一个模块，我们要关注的问 题仅仅在于如何在其他文件中获取这个模块。Node.js 提供了 exports 和 require 两个对 象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获 取模块的 exports 对象。</p>\n<ul>\n<li>\n<p>让我们以一个例子来了解模块。创建一个 module.js 的文件，内容是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//module.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name;</span><br><span class=\"line\">exports.setName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">thyName</span>) </span>&#123;</span><br><span class=\"line\">   name = thyName;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">exports.sayHello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello '</span> + name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//在同一目录下创建 getmodule.js， 内容是：</span></span><br><span class=\"line\"><span class=\"comment\">//getmodule.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myModule = <span class=\"built_in\">require</span>(<span class=\"string\">'./module'</span>);</span><br><span class=\"line\">myModule.setName(<span class=\"string\">'mynodetest'</span>); </span><br><span class=\"line\">myModule.sayHello();</span><br><span class=\"line\"><span class=\"comment\">//-------------------------------------------------//</span></span><br><span class=\"line\"><span class=\"comment\">//运行</span></span><br><span class=\"line\">$ node getmodule.js，</span><br><span class=\"line\"><span class=\"comment\">//结果：</span></span><br><span class=\"line\">Hello mynodetest</span><br></pre></td></tr></table></figure>\n<p>在以上示例中，module.js 通过 exports 对象把 setName 和 sayHello 作为模块的访 问接口，在 getmodule.js 中通过 require(’./module’) 加载这个模块，然后就可以直接访 问 module.js 中 exports 对象的成员函数了。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>覆盖 exports</p>\n<ul>\n<li>\n<p>有时候我们只是想把一个对象封装到模块中，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//hello.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Hello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> name;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">thyName</span>) </span>&#123;</span><br><span class=\"line\">      name = thyName;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.sayHello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello '</span> + name);</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = Hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//gethello.js</span></span><br><span class=\"line\"><span class=\"comment\">//这样就可以直接获得这个对象了：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Hello = <span class=\"built_in\">require</span>(<span class=\"string\">'./hello'</span>);</span><br><span class=\"line\">hello = <span class=\"keyword\">new</span> Hello();</span><br><span class=\"line\">hello.setName(<span class=\"string\">'BYVoid'</span>);</span><br><span class=\"line\">hello.sayHello();</span><br></pre></td></tr></table></figure>\n<p>注意，模块接口的唯一变化是使用 module.exports = Hello 代替了 exports.Hello= Hello。在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。事实上，exports 本身仅仅是一个普通的空对象，即 {}，它专门用来声明接口，本 质上是通过它为模块闭包的内部建立了一个有限的访问接口</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4><span id=\"什么是包\">什么是包</span></h4>\n<blockquote>\n<p>包是在模块基础上更深一步的抽象，Node.js 的包类似于 C/C++ 的函数库或者 Java/.Net 的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。Node.js 根 据 CommonJS 规范实现了包机制，开发了 npm来解决包的发布和获取需求。<br>\nNode.js 的包是一个目录，其中包含一个 JSON 格式的包说明文件 package.json。严格符 合 CommonJS 规范的包应该具备以下特征：</p>\n<ul>\n<li>package.json 必须在包的顶层目录下；</li>\n<li>二进制文件应该在 bin 目录下；</li>\n<li>JavaScript 代码应该在 lib 目录下；</li>\n<li>文档应该在 doc 目录下；</li>\n<li>单元测试应该在 test 目录下。</li>\n</ul>\n<p>Node.js 对包的要求并没有这么严格，只要顶层目录下有 package.json，并符合一些规范 即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 CommonJS 规范。</p>\n</blockquote>\n<ul>\n<li>\n<p>以文件夹作为模块</p>\n<blockquote>\n<p>模块与文件是一一对应的。文件不仅可以是 JavaScript 代码或二进制代码，还可以是一 个文件夹。最简单的包，就是一个作为文件夹的模块。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//somepackage/index.js exports.hello = function() &#123;</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello.'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//然后在 somepackage 之外建立 getpackage.js，内容如下：</span></span><br><span class=\"line\"><span class=\"comment\">//getpackage.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> somePackage = <span class=\"built_in\">require</span>(<span class=\"string\">'./somepackage'</span>); </span><br><span class=\"line\">somePackage.hello();</span><br><span class=\"line\"><span class=\"comment\">//运行 </span></span><br><span class=\"line\">$ node getpackage.js，</span><br><span class=\"line\"><span class=\"comment\">//控制台将输出结果 Hello.。</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>package.json</p>\n<p>在前面的例子中的somepackage文件夹下，创建一个叫package.json的文件，内容如下：</p>\n<p><strong>还可以进入somepackage目录，使用命令来生成一个package.json:<code>$ npm init -f</code></strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"string\">\"main\"</span> : <span class=\"string\">\"./lib/interface.js\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后将 index.js 重命名为 interface.js 并放入 lib 子文件夹下。以同样的方式再次调用这个 包，依然可以正常使用。</p>\n<p>因为Node.js 在调用某个包时，会首先检查包中 package.json 文件的 main 字段，将其作为 包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作 为包的接口。</p>\n<blockquote>\n<p>package.json 是 CommonJS 规定的用来描述包的文件，完全符合规范的 package.json 文 件应该含有以下字段。</p>\n<ul>\n<li>name：包的名称，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含<br>\n空格。</li>\n<li>description：包的简要说明。</li>\n<li>version：符合语义化版本识别 规范的版本字符串。</li>\n<li>keywords：关键字数组，通常用于搜索。</li>\n<li>maintainers：维护者数组，每个元素要包含 name、email （可选）、web （可选）<br>\n字段。</li>\n<li>contributors：贡献者数组，格式与maintainers相同。包的作者应该是贡献者<br>\n数组的第一个元素。</li>\n<li>bugs：提交bug的地址，可以是网址或者电子邮件地址。</li>\n<li>licenses：许可证数组，每个元素要包含 type （许可证的名称）和 url （链接到<br>\n许可证文本的地址）字段。</li>\n<li>repositories：仓库托管地址数组，每个元素要包含 type（仓库的类型，如 git ）、url （仓库的地址）和 path （相对于仓库的路径，可选）字段。</li>\n<li>dependencies：包的依赖，一个关联数组，由包名称和版本号组成。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h4><span id=\"nodejs-包管理器\">Node.js 包管理器</span></h4>\n<blockquote>\n<p>Node.js包管理器，即npm是 Node.js 官方提供的包管理工具①，它已经成了 Node.js 包的 标准发布平台，用于 Node.js 包的发布、传播、依赖控制。npm 提供了命令行工具，使你可 以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。</p>\n</blockquote>\n<ul>\n<li>\n<p>获取一个包</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用 npm 安装包的命令格式为：</span></span><br><span class=\"line\">npm [install/i] [package_name]</span><br><span class=\"line\"><span class=\"comment\">//例如你要安装 express，可以在命令行运行：</span></span><br><span class=\"line\"><span class=\"symbol\">$</span> npm install express</span><br><span class=\"line\">或者：<span class=\"symbol\">$</span> npm i express</span><br><span class=\"line\"><span class=\"comment\">//安装成功后，放置在当前目录的 node_modules 子目录下</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>本地模式和全局模式</p>\n<blockquote>\n<p>npm在默认情况下会从http://npmjs.org搜索或下载包，将包安装到当前目录的node_modules 子目录下。</p>\n<p>npm 还有另一种不同的安装模式被成为全局模式，使用方法为：</p>\n<p>$ npm [install/i] -g [package_name]</p>\n<p>eg.: $ npm install -g supervisor 命令，就是以全局模式安装 supervisor。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>\n<p>当我们使用全局模 式安装时，npm 会将包安装到系统目录，如 /usr/local/lib/node_modules/，同时 package.json 文 件中 bin 字段包含的文件会被链接到 /usr/local/bin/</p>\n</li>\n<li>\n<p>使用全局模式安装的包并不能直接在 JavaScript 文件中用 require 获得，因为 require 不会搜索 /usr/local/lib/node_modules/。</p>\n<p>​\t\t\t\t<strong>表 - 本地模式与全局模式</strong></p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>可通过 require 使用</th>\n<th>注册PATH</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>本地模式</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>全局模式</td>\n<td>否</td>\n<td>是</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>创建全局链接</p>\n<blockquote>\n<p>npm 提供了一个链接命令 npm link，它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 require 使用，但通过 npm link命令 可以打破这一限制。</p>\n</blockquote>\n<p>例子：</p>\n<p>我们已经通过 npm install -g express 安装了 express， 这时在工程的目录下运行命令：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm link <span class=\"built_in\">express</span></span><br><span class=\"line\">./node_modules/<span class=\"built_in\">express</span> -&gt; /usr/<span class=\"built_in\">local</span>/lib/node_modules/<span class=\"built_in\">express</span></span><br></pre></td></tr></table></figure>\n<p>我们可以在 node_modules 子目录中发现一个指向安装到全局的包的符号链接。通过这 种方法，我们就可以把全局包当本地包来使用了。</p>\n</li>\n</ul>\n<h4><span id=\"调试\">调试</span></h4>\n<ul>\n<li>命令行调试：在命令行下执行 node debug debug.js，将会启动调试工具</li>\n</ul>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node debug debug.js</span><br><span class=\"line\">&lt; <span class=\"keyword\">debugger</span> listening <span class=\"keyword\">on</span> port <span class=\"number\">5858</span> connecting... ok</span><br><span class=\"line\"><span class=\"keyword\">break</span> <span class=\"keyword\">in</span> /home/byvoid/<span class=\"attribute\">debug.js</span>:<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"keyword\">var</span> b = <span class=\"string\">'world'</span>;</span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"keyword\">var</span> c = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; debug&gt;</span><br></pre></td></tr></table></figure>\n<p>​\t<strong>Node.js 调试命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>run</td>\n<td>执行脚本，在第一行暂停</td>\n</tr>\n<tr>\n<td>restart</td>\n<td>重新执行脚本</td>\n</tr>\n<tr>\n<td>cont, c</td>\n<td>继续执行，直到遇到下一个断点 单步执行</td>\n</tr>\n<tr>\n<td>next, n</td>\n<td>单步执行</td>\n</tr>\n<tr>\n<td>step, s</td>\n<td>单步执行并进入函数</td>\n</tr>\n<tr>\n<td>out, o</td>\n<td>从函数中步出</td>\n</tr>\n<tr>\n<td>setBreakpoint(), sb()</td>\n<td>在当前行设置断点</td>\n</tr>\n<tr>\n<td>setBreakpoint(‘f()’), sb(…)</td>\n<td>在函数f的第一行设置断点</td>\n</tr>\n<tr>\n<td>setBreakpoint(‘script.js’, 20), sb(…)</td>\n<td>在script.js 的第20行设置断点</td>\n</tr>\n<tr>\n<td>clearBreakpoint, cb(…)</td>\n<td>清除所有断点</td>\n</tr>\n<tr>\n<td>backtrace, bt</td>\n<td>显示当前的调用栈</td>\n</tr>\n<tr>\n<td>list(5)</td>\n<td>显示当前执行到的前后5行代码</td>\n</tr>\n<tr>\n<td>watch(expr)</td>\n<td>把表达式 expr 加入监视列表</td>\n</tr>\n<tr>\n<td>unwatch(expr)</td>\n<td>把表达式 expr 加入监视列表</td>\n</tr>\n<tr>\n<td>watchers</td>\n<td>显示监视列表中所有的表达式和值</td>\n</tr>\n<tr>\n<td>repl</td>\n<td>在当前上下文打开即时求值环境</td>\n</tr>\n<tr>\n<td>kill</td>\n<td>终止当前执行的脚本</td>\n</tr>\n<tr>\n<td>scripts</td>\n<td>显示当前已加载的所有脚本</td>\n</tr>\n<tr>\n<td>version</td>\n<td>显示 V8 的版本</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>远程调试：V8 提供的调试功能是基于 TCP 协议的，因此 Node.js 可以轻松地实现远程调试。在命令行下使用以下两个语句之一可以打开调试服务器：</p>\n<ul>\n<li>\n<p>打开调试服务器</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">node</span> <span class=\"title\">--debug</span>[=port] script.js </span><br><span class=\"line\"><span class=\"keyword\">node</span> <span class=\"title\">--debug-brk</span>[=port] script.js</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>当调试服务器启动以后，可以用命令行调试工具作为调试客户端连接，例如：</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在一个终端中</span></span><br><span class=\"line\">$ node --debug-brk debug.js <span class=\"keyword\">debugger</span> listening <span class=\"keyword\">on</span> port <span class=\"number\">5858</span></span><br><span class=\"line\"><span class=\"comment\">//在另一个终端中</span></span><br><span class=\"line\">$ node debug <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">5858</span></span><br><span class=\"line\">connecting... ok</span><br><span class=\"line\">debug&gt; n</span><br><span class=\"line\"><span class=\"keyword\">break</span> <span class=\"keyword\">in</span> /home/byvoid/<span class=\"attribute\">debug.js</span>:<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"keyword\">var</span> b = <span class=\"string\">'world'</span>;</span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"keyword\">var</span> c = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello '</span> + x + a); debug&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>使用 node-inspector 调试 Node.js</p>\n<blockquote>\n<p>大部分基于 Node.js 的应用都是运行在浏览器中的，例如强大的调试工具 node-inspector。 node-inspector 是一个完全基于 Node.js 的开源在线调试工具，提供了强大的调试功能和友好 的用户界面，它的使用方法十分简便。</p>\n</blockquote>\n<ul>\n<li>首先，使用 npm install -g node-inspector 命令安装 node-inspector，然后在终 端中通过 node --debug-brk=5858 debug.js 命令连接你要除错的脚本的调试服务器， 启动 node-inspector：</li>\n<li>$ node-inspector</li>\n<li>在浏览器中打开 <a href=\"http://127.0.0.1:8080/debug?port=5858%EF%BC%8C%E5%8D%B3%E5%8F%AF%E6%98%BE%E7%A4%BA%E5%87%BA%E4%BC%98%E9%9B%85%E7%9A%84\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080/debug?port=5858，即可显示出优雅的</a> Web 调试工 具</li>\n</ul>\n</li>\n<li>\n<p>使用 Eclipse 调试 Node.js(这里不做介绍)</p>\n</li>\n</ul>\n<h2><span id=\"第四章-nodejs-核心模块\">第四章 Node.js 核心模块</span></h2>\n<blockquote>\n<p>核心模块是 Node.js 的心脏，它由一些精简而高效的库组成，为 Node.js 提供了基本的 API。本章中，我们挑选了一部分最常用的核心模块加以详细介绍，主要内容包括：</p>\n<ul>\n<li>全局对象；</li>\n<li>常用工具；</li>\n<li>事件机制；</li>\n<li>文件系统访问；</li>\n<li>HTTP 服务器与客户端。</li>\n</ul>\n</blockquote>\n<h3><span id=\"全局对象\">全局对象</span></h3>\n<h4><span id=\"全局对象\">全局对象</span></h4>\n<blockquote>\n<p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可 以在程序的任何地方访问，即全局变量。在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p>\n</blockquote>\n<h4><span id=\"全局变量\">全局变量</span></h4>\n<blockquote>\n<p>global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：</p>\n<ul>\n<li>在最外层定义的变量；</li>\n<li>全局对象的属性；</li>\n<li>隐式定义的变量（未定义直接赋值的变量）。</li>\n</ul>\n</blockquote>\n<h3><span id=\"常用工具-util\">常用工具 util</span></h3>\n<blockquote>\n<p>util 是一个 Node.js 核心模块，提供常用函数的集合，用于弥补核心 JavaScript 的功能 过于精简的不足。</p>\n</blockquote>\n<h4><span id=\"utilinherits\">util.inherits</span></h4>\n<blockquote>\n<p>util.inherits(constructor, superConstructor) 是一个实现对象间原型继承 的函数。JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的，具体细节我们在附录A中讨论， 在这里我们只介绍 util.inherits 的用法，示例如下：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Base</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'base'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.base = <span class=\"number\">1991</span>,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello :'</span>+ <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Base.prototype.showName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'this.name :'</span>, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sub</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'sub'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">util.inherits(Sub, Base);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> objBase = <span class=\"keyword\">new</span> Base();</span><br><span class=\"line\">objBase.showName();</span><br><span class=\"line\">objBase.sayHello();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(objBase);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> objSub = <span class=\"keyword\">new</span> Sub();</span><br><span class=\"line\">objSub.showName();</span><br><span class=\"line\"><span class=\"comment\">// objSub.sayHello();</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'objSub :'</span>, objSub);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'util.inspect(obj) :'</span>, util.inspect(objBase,<span class=\"literal\">true</span>,<span class=\"number\">2</span>,<span class=\"literal\">true</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输入结果：</span></span><br><span class=\"line\">➜  http0test node <span class=\"built_in\">module</span>.js</span><br><span class=\"line\"><span class=\"keyword\">this</span>.name : base</span><br><span class=\"line\">hello :base</span><br><span class=\"line\">Base &#123; <span class=\"attr\">name</span>: <span class=\"string\">'base'</span>, <span class=\"attr\">base</span>: <span class=\"number\">1991</span>, <span class=\"attr\">sayHello</span>: [<span class=\"built_in\">Function</span>] &#125;</span><br><span class=\"line\"><span class=\"keyword\">this</span>.name : sub</span><br><span class=\"line\">objSub : Sub &#123; <span class=\"attr\">name</span>: <span class=\"string\">'sub'</span> &#125;</span><br><span class=\"line\">util.inspect(obj) : Base &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'base'</span>,</span><br><span class=\"line\">  base: <span class=\"number\">1991</span>,</span><br><span class=\"line\">  sayHello:</span><br><span class=\"line\">   &#123; [<span class=\"built_in\">Function</span>]</span><br><span class=\"line\">     [length]: <span class=\"number\">0</span>,</span><br><span class=\"line\">     [name]: <span class=\"string\">''</span>,</span><br><span class=\"line\">     [<span class=\"built_in\">arguments</span>]: <span class=\"literal\">null</span>,</span><br><span class=\"line\">     [caller]: <span class=\"literal\">null</span>,</span><br><span class=\"line\">     [prototype]: &#123; [<span class=\"keyword\">constructor</span>]: [Circular] &#125; &#125; &#125;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"utilinspect\">util.inspect</span></h4>\n<blockquote>\n<p>util.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。</p>\n<ul>\n<li>showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。</li>\n<li>depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。</li>\n<li>color 值如果为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。</li>\n</ul>\n</blockquote>\n<h3><span id=\"事件驱动-events\">事件驱动 events</span></h3>\n<blockquote>\n<p>events 是 Node.js 最重要的模块，没有“之一”，原因是 Node.js 本身架构就是事件式 的，而它提供了唯一的接口，所以堪称 Node.js 事件编程的基石。events 模块不仅用于用户代码与 Node.js 下层事件循环的交互，还几乎被所有的模块依赖。</p>\n</blockquote>\n<h4><span id=\"事件发射器eventseventemitter\">事件发射器（events.EventEmitter）</span></h4>\n<blockquote>\n<p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就 是事件发射与事件监听器功能的封装</p>\n</blockquote>\n<ul>\n<li>\n<p>常规事件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//我们介绍一下EventEmitter常用的API。</span></span><br><span class=\"line\"><span class=\"comment\">//为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数 listener。</span></span><br><span class=\"line\">EventEmitter.on(event, listener) </span><br><span class=\"line\"><span class=\"comment\">//发射 event 事件，传递若干可选参数到事件监听器的参数表。</span></span><br><span class=\"line\">EventEmitter.emit(event, [arg1], [arg2], [...]) </span><br><span class=\"line\"><span class=\"comment\">//为指定事件注册一个单次监听器， 即监听器最多只会触发一次，触发后立刻解除该监听器。</span></span><br><span class=\"line\">EventEmitter.once(event, listener) </span><br><span class=\"line\"><span class=\"comment\">//移除指定事件的某个监听器，listener 必须是该事件已经注册过的监听器。</span></span><br><span class=\"line\">EventEmitter.removeListener(event, listener) </span><br><span class=\"line\"><span class=\"comment\">//移除所有事件的所有监听器，如果指定 event，则移除指定事件的所有监听器。</span></span><br><span class=\"line\">EventEmitter.removeAllListeners([event]) </span><br><span class=\"line\"><span class=\"comment\">//更详细的 API 文档参见 http://nodejs.org/api/events.html。</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> events = <span class=\"built_in\">require</span>(<span class=\"string\">'events'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> emitter = <span class=\"keyword\">new</span> event.EventEmitter();</span><br><span class=\"line\"></span><br><span class=\"line\">emitter.on(<span class=\"string\">'someEvent'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arg1, arg2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listener1'</span>, arg1, arg2);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">emitter.on(<span class=\"string\">'someEvent'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arg1, arg2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listener2'</span>, arg1, arg2);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">emitter.emit(<span class=\"string\">'someEvent'</span>, <span class=\"string\">'byvoid'</span>, <span class=\"number\">1991</span>);</span><br><span class=\"line\"><span class=\"comment\">// 运行的结果是：</span></span><br><span class=\"line\"><span class=\"comment\">// listener1 byvoid 1991 </span></span><br><span class=\"line\"><span class=\"comment\">// listener2 byvoid 1991</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>error事件</p>\n<blockquote>\n<p>EventEmitter 定义了一个特殊的事件 error，它包含了“错误”的语义，我们在遇到 异常的时候通常会发射 error 事件。当 error 被发射时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并打印调用栈</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> events = <span class=\"built_in\">require</span>(<span class=\"string\">'events'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> emitter = <span class=\"keyword\">new</span> events.EventEmitter();</span><br><span class=\"line\">emitter.emit(<span class=\"string\">'error'</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3><span id=\"文件系统-fs\">文件系统 fs</span></h3>\n<blockquote>\n<p>fs 模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接等 POSIX 文件系统操作</p>\n</blockquote>\n<ul>\n<li>\n<p>fs.readFile:</p>\n<p>fs.readFile(filename,[encoding],[callback(err,data)]) 是最简单的读取 文件的函数。它接受一个必选参数 filename，表示要读取的文件名。第二个参数 encoding 是可选的，表示文件的字符编码（不指定编码格式，则data形式输出）。callback 是回调函数，用于接收文件的内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\">fs.readFile(<span class=\"string\">'output.txt'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'fileData: :'</span>, data);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\">➜  nodejs_note node app.js</span><br><span class=\"line\">fileData: : nenhall 学习node.js 笔记</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>fs.readFileSync</p>\n<p>fs.readFileSync(filename, [encoding])是 fs.readFile 同步的版本。它接受 的参数和 fs.readFile 相同，而读取到的文件内容会以函数返回值的形式返回。如果有错 误发生，fs 将会抛出异常，你需要使用 try 和 catch 捕捉并处理异常。</p>\n</li>\n<li>\n<p>fs.open</p>\n<p>fs.open(path, flags, [mode], [callback(err, fd)])是 POSIX open 函数的 封装，与 C 语言标准库中的 fopen 函数类似。它接受两个必选参数，path 为文件的路径， flags 可以是以下值:</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r ：以读取模式打开文件。</span><br><span class=\"line\">r+ ：以读写模式打开文件。</span><br><span class=\"line\">w ：以写入模式打开文件，如果文件不存在则创建。</span><br><span class=\"line\">w+ ：以读写模式打开文件，如果文件不存在则创建。</span><br><span class=\"line\">a ：以追加模式打开文件，如果文件不存在则创建。</span><br><span class=\"line\">a+ ：以读取追加模式打开文件，如果文件不存在则创建。</span><br><span class=\"line\">mode 参数用于创建文件时给文件指定权限，默认是 <span class=\"number\">0666</span></span><br><span class=\"line\">callback：回调函数将会传递一个文 件描述符 fd</span><br><span class=\"line\"></span><br><span class=\"line\">注意：文件权限指的是 POSIX 操作系统中对文件读取和访问权限的规范，通常用一个八进制数来表示。例如 <span class=\"number\">0754</span> 表示文件所有者的权限是 <span class=\"number\">7</span> （读、写、执行），同组的用户权限是 <span class=\"number\">5</span> （读、执行），其他用户的权限是 <span class=\"number\">4</span>（读）， 写成字符表示就是 -rwxr-xr--。</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>fs.read</p>\n<p>fs.read(fd, buffer, offset, length, position, [callback(err, bytesRead, buffer)])是 POSIX read 函数的封装，相比 fs.readFile 提供了更底层的接口。fs.read 的功能是从指定的文件描述符:</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fd 中读取数据并写入 </span><br><span class=\"line\"><span class=\"built_in\">buffer</span> 指向的缓冲区对象。</span><br><span class=\"line\">offset 是 <span class=\"built_in\">buffer</span> 的写入偏移量。</span><br><span class=\"line\">length 是要从文件中读取的字节数。</span><br><span class=\"line\"><span class=\"built_in\">position</span> 是文件读取的起始 位置， 如果 <span class=\"built_in\">position</span> 的值为 null ， 则会从当前文件指针的位置读取。</span><br><span class=\"line\">回调函数传递 bytesRead 和 <span class=\"built_in\">buffer</span>，分别表示读取的字节数和缓冲区对象。</span><br></pre></td></tr></table></figure>\n<p>相关函数：</p>\n<p>fs.openSync(path, flags, [mode]) 对 fs.closeSync(fd)</p>\n<p>fs.read(fd, buffer, offset, length, position, callback()])  对 fs.close(fd, [callback(err)])</p>\n</li>\n</ul>\n<h3><span id=\"http-服务器与客户端\">HTTP 服务器与客户端</span></h3>\n<blockquote>\n<p>Node.js 标准库提供了 http 模块，其中封装了一个高效的 HTTP 服务器和一个简易的 HTTP 客户端。http.Server 是一个基于事件的 HTTP 服务器，它的核心由 Node.js 下层 C++ 部分实现，而接口由 JavaScript 封装，兼顾了高性能与简易性。http.request 则是一个 HTTP 客户端工具，用于向 HTTP 服务器发起请求</p>\n</blockquote>\n<h4><span id=\"http-服务\">HTTP 服务</span></h4>\n<blockquote>\n<p>http.Server 是 http 模块中的 HTTP 服务器对象，用 Node.js 做的所有基于 HTTP 协 议的系统，如网站、社交应用甚至代理服务器，都是基于 http.Server 实现的。它提供了 一套封装级别很低的 API，仅仅是流控制和简单的消息解析，所有的高层功能都要通过它的 接口来实现。</p>\n</blockquote>\n<ul>\n<li>\n<p>实现一个服务器</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//app.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 创建了一个 http.Server 的实例</span></span><br><span class=\"line\"><span class=\"comment\">// 将一个函数作为 HTTP 请求处理函数,这个函数接受两个参数，分别是请求对象(req)和响应对象(res)</span></span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//响应代码200（表示请求成功）,指定响应头为'Content-Type': 'text/html'</span></span><br><span class=\"line\">   res.writeHead(<span class=\"number\">200</span>, &#123;</span><br><span class=\"line\">      <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'text/html'</span></span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">   <span class=\"comment\">// 写入响应体 '&lt;h1&gt;Node.js&lt;/h1&gt;'</span></span><br><span class=\"line\">   res.write(<span class=\"string\">'&lt;h1&gt;Node.js&lt;/h1&gt;'</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 通过 res.end 结束并发送</span></span><br><span class=\"line\">   res.end(<span class=\"string\">'&lt;p&gt;Hello World&lt;/p&gt;'</span>);</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">3000</span>);<span class=\"comment\">//listen 函数，启动服务器并监听 3000 端口</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"HTTP server is listening at port 3000.\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong>http.Server</strong> 的事件</p>\n<p>http.Server 是一个基于事件的 HTTP 服务器，所有的请求都被封装为独立的事件， 开发者只需要对它的事件编写响应函数即可实现 HTTP 服务器的所有功能。它继承自 EventEmitter</p>\n<ul>\n<li>request：当客户端请求到来时，该事件被触发，提供两个参数 req 和res，分别是http.ServerRequest 和 http.ServerResponse 的实例，表示请求和响应信息。</li>\n<li>connection ：当 TCP 连接建立时， 该事件被触发， 提供一个参数 socket ， 为net.Socket 的实例。connection 事件的粒度要大于 request ， 因为客户端在Keep-Alive 模式下可能会在同一个连接内发送多次请求。</li>\n<li>close ：当服务器关闭时，该事件被触发。注意不是在用户连接断开时。</li>\n</ul>\n</li>\n<li>\n<p><strong>http.ServerRequest</strong></p>\n<ol>\n<li>\n<p>http.ServerRequest 是 HTTP 请求的信息，是后端开发者最关注的内容。它一般由 http.Server 的 request 事件发送，作为第一个参数传递，通常简称 request 或 req</p>\n</li>\n<li>\n<p>HTTP 请求一般可以分为两部分：请求头（Request Header）和请求体（Requset Body）。 以上内容由于长度较短都可以在请求头解析完成后立即读取。</p>\n</li>\n<li>\n<p>请求体可能相对较长， 需要一定的时间传输，因此 http.ServerRequest 提供了以下3个事件用于控制请求体 传输。</p>\n<ul>\n<li>data ：当请求体数据到来时，该事件被触发。该事件提供一个参数 chunk，表示接收到的数据。如果该事件没有被监听，那么请求体将会被抛弃。该事件可能会被调用多次。</li>\n<li>end ：当请求体数据传输完成时，该事件被触发，此后将不会再有数据到来。</li>\n<li>close： 用户当前请求结束时，该事件被触发。不同于 end，如果用户强制终止了传输，也还是调用close。</li>\n</ul>\n</li>\n<li>\n<p><strong>ServerRequest</strong> 的属性表</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>complete</td>\n<td>客户端请求是否已经发送完成</td>\n</tr>\n<tr>\n<td>httpVersion</td>\n<td>HTTP 协议版本，通常是 1.0 或 1.1</td>\n</tr>\n<tr>\n<td>method</td>\n<td>HTTP 请求方法，如 GET、POST、PUT、DELETE 等</td>\n</tr>\n<tr>\n<td>url</td>\n<td>原始的请求路径，例如/static/image/x.jpg 或/user?name=byvoid</td>\n</tr>\n<tr>\n<td>headers</td>\n<td>HTTP 请求头</td>\n</tr>\n<tr>\n<td>trailers</td>\n<td>HTTP 请求尾（不常见）</td>\n</tr>\n<tr>\n<td>connection</td>\n<td>当前 HTTP 连接套接字，为 net.Socket 的实例</td>\n</tr>\n<tr>\n<td>socket</td>\n<td>connection 属性的别名</td>\n</tr>\n<tr>\n<td>client</td>\n<td>client 属性的别名</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>获取 GET 请求内容</p>\n<p>由于 GET 请求直接被嵌入在路径 中，URL是完整的请求路径，包括了 ? 后面的部分，因此你可以手动解析后面的内容作为 GET 请求的参数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">   res.writeHead(<span class=\"number\">200</span>, &#123;</span><br><span class=\"line\">      <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'text/plain'</span></span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">   res.end(util.inspect(url.parse(req.url, <span class=\"literal\">true</span>)));</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">3000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//浏览器中输入：http://127.0.0.1:3000/user?name=byvoid&amp;email=byvoid@byvoid.com</span></span><br><span class=\"line\"><span class=\"comment\">//展示：</span></span><br><span class=\"line\">Url &#123;</span><br><span class=\"line\">  protocol: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  slashes: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  auth: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  host: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  port: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  hostname: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  hash: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  search: <span class=\"string\">'?name=byvoid&amp;email=byvoid@byvoid.com'</span>,</span><br><span class=\"line\">  query:</span><br><span class=\"line\">   [<span class=\"built_in\">Object</span>: <span class=\"literal\">null</span> prototype] &#123; <span class=\"attr\">name</span>: <span class=\"string\">'byvoid'</span>, <span class=\"attr\">email</span>: <span class=\"string\">'byvoid@byvoid.com'</span> &#125;,</span><br><span class=\"line\">  pathname: <span class=\"string\">'/user'</span>,</span><br><span class=\"line\">  path: <span class=\"string\">'/user?name=byvoid&amp;email=byvoid@byvoid.com'</span>,</span><br><span class=\"line\">  href: <span class=\"string\">'/user?name=byvoid&amp;email=byvoid@byvoid.com'</span> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<ol start=\"6\">\n<li>\n<p>获取 POST 请求内容</p>\n<p>HTTP 协议 1.1 版本提供了8种标准的请求方法，其中最常见的就是 GET 和 POST。相比 GET 请求把所有的内容编码到访问路径中， POST 请求的内容全部都在请求体中。 http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作，譬如上传文件。而很多时候我们可能并不需要理会请求体的内容，恶意的POST 请求会大大消耗服务器的资源。所以 Node.js 默认是不会解析请求体的，当你需要的时候， 需要手动来做</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> post = <span class=\"string\">''</span>;</span><br><span class=\"line\">   req.on(<span class=\"string\">'end'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      post = querystring.parse(post);</span><br><span class=\"line\">      res.end(util.inspect(post));</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<p>上面代码并没有在请求响应函数中向客户端返回信息，而是定义了一个 post 变量。通过 req 的 data 事件监听函数，每当接受到请求体的数据， 就累加到 post 变量中。在 end 事件触发后，通过 querystring.parse 将 post 解析为真正的 POST 请求格式，然后向客户端返回</p>\n<p>**注意：**不要在真正的生产应用中使用上面这种简单的方法来获取 POST 请求，因为它有严重的效率和安全问题</p>\n</li>\n</ol>\n<ol start=\"7\">\n<li>\n<p><strong>http.ServerResponse</strong><br>\nhttp.ServerResponse 是返回给客户端的信息，决定了用户最终能看到的结果。它 也是由 http.Server 的 request 事件发送的， 作为第二个参数传递， 一般简称为 response 或 res。</p>\n<blockquote>\n<p>http.ServerResponse 有三个重要的成员函数，用于返回响应头、响应内容以及结束 请求。</p>\n<ul>\n<li>response.writeHead(statusCode, [headers])：向请求的客户端发送响应头。<br>\nstatusCode 是 HTTP 状态码，如 200 （请求成功）、404 （未找到）等。headers<br>\n是一个类似关联数组的对象，表示响应头的每个属性。该函数在一个请求内最多只<br>\n能调用一次，如果不调用，则会自动生成一个响应头。</li>\n<li>response.write(data, [encoding])：向请求的客户端发送响应内容。data 是<br>\n一个 Buffer 或字符串，表示要发送的内容。如果 data 是字符串，那么需要指定<br>\nencoding 来说明它的编码方式，默认是 utf-8。在 response.end 调用之前，<br>\nresponse.write 可以被多次调用。</li>\n<li>response.end([data], [encoding])：结束响应，告知客户端所有发送已经完<br>\n成。当所有要返回的内容发送完毕的时候，该函数 必须 被调用一次。它接受两个可<br>\n选参数，意义和 response.write 相同。如果不调用该函数，客户端将永远处于<br>\n等待状态。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h4><span id=\"http-客户端\">HTTP 客户端</span></h4>\n<blockquote>\n<p>http 模块提供了两个函数 http.request 和 http.get，功能是作为客户端向 HTTP 服务器发起请求。</p>\n<p>http.request(options, callback) 发起 HTTP 请求。接受两个参数，option 是<br>\n一个类似关联数组的对象，表示请求的参数，callback 是请求的回调函数。option<br>\n常用的参数如下所示。</p>\n<ul>\n<li>host ：请求网站的域名或 IP 地址。</li>\n<li>port ：请求网站的端口，默认 80。</li>\n<li>method ：请求方法，默认是 GET。</li>\n<li>path ：请求的相对于根的路径，默认是“/”。QueryString 应该包含在其中。例如 /search?query=byvoid。</li>\n<li>headers ：一个关联数组对象，为请求头的内容。</li>\n<li>callback 传递一个参数，为 http.ClientResponse 的实例。<br>\nhttp.request 返回一个 http.ClientRequest 的实例。</li>\n</ul>\n</blockquote>\n<p>下面是一个通过 http.request 发送 POST 请求的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//httprequest.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> contents = querystring.stringify(&#123;</span><br><span class=\"line\">   name: <span class=\"string\">'byvoid'</span>,</span><br><span class=\"line\">   email: <span class=\"string\">'byvoid@byvoid.com'</span>,</span><br><span class=\"line\">   address: <span class=\"string\">'Zijing 2#, Tsinghua University'</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> options = &#123;</span><br><span class=\"line\">   host: <span class=\"string\">'www.byvoid.com'</span>,</span><br><span class=\"line\">   path: <span class=\"string\">'/application/node/post.php'</span>,</span><br><span class=\"line\">   method: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">   headers: &#123;</span><br><span class=\"line\">      <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/x-www-form-urlencoded'</span>,</span><br><span class=\"line\">      <span class=\"string\">'Content-Length'</span>: contents.length</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> req = http.request(options, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">   res.setEncoding(<span class=\"string\">'utf8'</span>);</span><br><span class=\"line\">   res.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">req.write(contents);</span><br><span class=\"line\">req.end();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>http.get(options, callback) http 模块还提供了一个更加简便的方法用于处理GET请求：http.get。它是 http.request 的简化版，唯一的区别在于：http.get自动将请求方法设为了 GET 请求，同时不需要手动调用 req.end()。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//httprequest.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\">http.get(&#123;</span><br><span class=\"line\">   host: <span class=\"string\">'www.byvoid.com'</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">   res.setEncoding(<span class=\"string\">'utf8'</span>);</span><br><span class=\"line\">   res.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>http.ClientRequest 是由 http.request 或 http.get 返回产生的对象，表示一 个已经产生而且正在进行中的 HTTP 请求，它提供一个 response 事件，即 http.request 或 http.get 第二个参数指定的回调函数的绑定对象。我们也可以显式地绑定这个事件的监听函数：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//httpresponse.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> req = http.get(&#123;<span class=\"attr\">host</span>: <span class=\"string\">'www.byvoid.com'</span>&#125;);</span><br><span class=\"line\">req.on(<span class=\"string\">'response'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\"> \tres.setEncoding(<span class=\"string\">'utf8'</span>);</span><br><span class=\"line\"> \tres.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\"> \t<span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>http.ClientRequest 像 http.ServerResponse 一样也提供了 write 和 end 函 数，用于向服务器发送请求体，通常用于 POST、PUT 等操作。所有写结束以后必须调用 end 函数以通知服务器，否则请求无效。相关函数：</p>\n<ul>\n<li>request.abort()：终止正在发送的请求。</li>\n<li>request.setTimeout(timeout, [callback])：设置请求超时时间，timeout 为毫秒数。当请求超时以后，callback 将会被调用</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p>http.clientResponse</p>\n<p>http.ClientResponse 与 http.ServerRequest 相似，提供了三个事件 data、end 和 close，分别在数据到达、传输结束和连接结束时触发，其中 data 事件传递一个参数 chunk，表示接收到的数据。</p>\n<p>http.ClientResponse 也提供了一些属性，用于表示请求的结果状态:</p>\n<blockquote>\n<p>statusCode : HTTP 状态码，如 200、404、500</p>\n<p>httpVersion : HTTP 协议版本，通常是 1.0 或 1.1</p>\n<p>headers : HTTP 请求头</p>\n<p>trailers : HTTP 请求尾（不常见）</p>\n<p><strong>http.ClientResponse 还提供了以下几个特殊的函数</strong></p>\n<p>response.setEncoding([encoding])：设置默认的编码，当 data 事件被触发<br>\n时，数据将会以 encoding 编码。默认值是 null，即不编码，以 Buffer 的形式存<br>\n储。常用编码为 utf8。<br>\nresponse.pause()：暂停接收数据和发送事件，方便实现下载功能。<br>\nresponse.resume()：从暂停的状态中恢复。</p>\n<p>参考资料：<a href=\"http://nodejs.org/api/index.html\" target=\"_blank\" rel=\"noopener\">http://nodejs.org/api/index.html</a></p>\n</blockquote>\n</li>\n</ul>\n<h2><span id=\"第五章-nodejs-web开发实战\">第五章 Node.js Web开发实战</span></h2>\n<h3><span id=\"nodejs-工作原理\">Node.js 工作原理</span></h3>\n<p>Node.js 实现网站的工作原理。Node.js 和 PHP、 Perl、ASP、JSP 一样，目的都是实现动态网页，也就是说由服务器动态生成 HTML 页面。 之所以要这么做，是因为静态 HTML 的可扩展性非常有限，无法与用户有效交互。同时如 果有大量相似的内容，例如产品介绍页面，那么1000个产品就要1000个静态的 HTML 页面， 维护这1000个页面简直是一场灾难，因此动态生成 HTML 页面的技术应运而生。是在以 HTML 为主的模板中插入程序代码。这种方 式在2002年前后非常流行，但它的问题是页面和程序逻辑紧密耦合，任何一个网站规模变大 以后，都会遇到结构混乱，难以处理的问题。为了解决这种问题，以 MVC 架构为基础的平台逐渐兴起；Node.js 本质上和 Perl 或 C++ 一样，都可以作为 CGI 扩展被调用，但它还可以跳过 HTTP 服务器，因为它本身就是。传统的架构中 HTTP 服务器的角色会由 Apache、Nginx、IIS 之类 的软件来担任，而 Node.js 不需要。Node.js 提供了 http 模块，它是由 C++ 实现的，性能可靠，可以直接应用到生产环境。</p>\n<blockquote>\n<p>MVC （Model-View-Controller，模型视图控制器）是一种软件的设计模式，它最早是 由 20 世纪 70 年代的 Smalltalk 语言提出的，即把一个复杂的软件工程分解为三个层面：模 型、视图和控制器。</p>\n<ul>\n<li>模型是对象及其数据结构的实现，通常包含数据库操作。</li>\n<li>视图表示用户界面，在网站中通常就是 HTML 的组织结构。</li>\n<li>控制器用于处理用户请求和数据流、复杂模型，将输出传递给视图。</li>\n</ul>\n</blockquote>\n<h4><span id=\"了解-http-模块\">了解 <strong>http</strong> 模块</span></h4>\n<p>Node.js 由于不需要另外的 HTTP 服务器，因此减少了一层抽象，给性能带来不少提升， 但同时也因此而提高了开发难度。举例来说，下面是一个简单的HTTP服务，提交时以 POST 的方式将请求发送，然后将发送过来内容原封不动的返回给用户</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> server = http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> post = <span class=\"string\">''</span>;</span><br><span class=\"line\">   <span class=\"comment\">// req.headers;</span></span><br><span class=\"line\">   <span class=\"comment\">// req.method;</span></span><br><span class=\"line\">   <span class=\"comment\">// req.url;</span></span><br><span class=\"line\">   <span class=\"comment\">// req.client;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   req.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">chunk</span>) </span>&#123;</span><br><span class=\"line\">      post += chunk;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">   req.on(<span class=\"string\">'end'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      post = querystring.parse(post);</span><br><span class=\"line\">      <span class=\"comment\">//以流的方式持续回给发送端</span></span><br><span class=\"line\">      res.write(post.title);</span><br><span class=\"line\">      res.write(post.text);</span><br><span class=\"line\">      res.statusCode(<span class=\"number\">200</span>);</span><br><span class=\"line\">      res.end();</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<h3><span id=\"express框架\">Express框架</span></h3>\n<h4><span id=\"简介\">简介</span></h4>\n<blockquote>\n<p>npm 提供了大量的第三方模块，其中不乏许多 Web 框架，我们没有必要重复发明轮子， 因而选择使用 Express 作为开发框架，因为它是目前最稳定、使用最广泛，而且 Node.js 官 方推荐的唯一一个 Web 开发框架。<br>\nExpress （ <a href=\"http://expressjs.com/\" target=\"_blank\" rel=\"noopener\">http://expressjs.com/</a> ） 除了为 http 模块提供了更高层的接口外，还实现了 许多功能，其中包括：</p>\n<ul>\n<li>路由控制；</li>\n<li>模板解析支持；</li>\n<li>动态视图；</li>\n<li>用户会话；</li>\n<li>CSRF 保护；</li>\n<li>静态文件服务；</li>\n<li>错误控制器；</li>\n<li>访问日志；</li>\n<li>缓存；</li>\n<li>插件支持。</li>\n</ul>\n<p>需要指出的是，Express 不是一个无所不包的全能框架，像 Rails 或 Django 那样实现了 模板引擎甚至 ORM （Object Relation Model，对象关系模型）。它只是一个轻量级的 Web 框架，多数功能只是对 HTTP 协议中常用操作的封装，更多的功能需要插件或者整合其他模块 来完成。</p>\n</blockquote>\n<h4><span id=\"安装\">安装</span></h4>\n<ul>\n<li>\n<p>安装<code>$ npm install -g express</code></p>\n</li>\n<li>\n<p>查看帮助：$ express --help</p>\n</li>\n<li>\n<p>Express 例子(重新实现前面)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express.createServer();</span><br><span class=\"line\">app.use(express.bodyParser());</span><br><span class=\"line\">app.all(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">   res.send(req.body.title + req.body.text);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4><span id=\"创建工程\">创建工程</span></h4>\n<blockquote>\n<p>Express 在初始化一个项目的时候需要指定模板引擎，默认支持Jade和ejs，为了降低学<br>\n习难度我们推荐使用 ejs ，同时暂时不添加 CSS 引擎和会话支持。</p>\n</blockquote>\n<ol>\n<li>\n<p>建立网站：</p>\n<ol>\n<li>\n<p>新起一个文件目录</p>\n<p><code>$ mkdir nodetest &amp;&amp; cd nodetest</code></p>\n</li>\n<li>\n<p>express创建ejs模板，如下右图</p>\n<p><code>$ npm install -g express &amp;&amp; npm install -g express-generator</code></p>\n<p><code>$ express -e nodeblog(-e 是ejs模板)</code></p>\n<p>//<code>$express -t nodeblog(-t 是jade模板引擎)</code></p>\n<p>// express3之前 不需要另外install ，可直接创建ejs模板：$ express -t ejs nodeblog</p>\n<p>//原因：express3+已经把创建一个APP的功能分离出来为express-generator，没它你创建不了应用程序</p>\n</li>\n<li>\n<p>进入生成的文件夹，打开package.json文件查看模板引擎，如下左图</p>\n</li>\n<li>\n<p>进入nodeblog文件夹</p>\n<p><code>$ cd nodeblog/</code></p>\n</li>\n<li>\n<p>安装相关依赖模块</p>\n<p><code>$ npm install</code></p>\n</li>\n<li>\n<p>启动服务</p>\n<p><code>$ npm start</code></p>\n<p>执行npm start其实是执行package.json中的script对应的对象中的start属性所对应的命令行</p>\n</li>\n<li>\n<p>可以用浏览器打开：<a href=\"http://localhost:3000\" target=\"_blank\" rel=\"noopener\">http://localhost:3000</a> 看到 Welcome to Express</p>\n</li>\n</ol>\n<p>**注：**ejs（Embedded JavaScript）是一个标签替换引擎，其语法与 ASP、PHP 相似，易于学习，目前被广泛应用。Express 默认提供的引擎是 jade，它颠覆了传统的模板引擎，制定了一套完整的语法用来生成 HTML 的每个标签结构，功能强大但不易学习。</p>\n<table>\n<thead>\n<tr>\n<th>左图</th>\n<th>右图</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222110947.png\" alt></td>\n<td><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222112735.png\" alt></td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>基本结构</p>\n<ul>\n<li>\n<p>首先我们导入了 Express 模块，前面已经通过 npm 安装到了本地，在这里可以直接通过 require 获取</p>\n</li>\n<li>\n<p>app.js文件结构说明：</p>\n<p>app.set 是 Express 的参数设置工具，接受一个键（key）和一个值（value），可用的参数如下所示。</p>\n<ul>\n<li>basepath：基础地址，通常用于 res.redirect() 跳转。</li>\n<li>views：视图文件的目录，存放模板文件。</li>\n<li>view engine：视图模板引擎。</li>\n<li>view options：全局视图参数对象。</li>\n<li>view cache：启用视图缓存。</li>\n<li>case sensitive routes：路径区分大小写。</li>\n<li>strict routing：严格路径，启用后不会忽略路径末尾的“ / ”。</li>\n<li>jsonp callback：开启透明的 JSONP 支持。</li>\n</ul>\n</li>\n<li>\n<p>routes/index.js 是路由文件，相当于控制器，用于组织展示的内容;</p>\n</li>\n<li>\n<p>index.ejs 是模板文件，即 routes/index.js 中调用的模板;</p>\n</li>\n</ul>\n</li>\n<li>\n<p>工作原理</p>\n<ul>\n<li>当通过浏览器访问 app.js 建立的服务器时， 会看到一个简单的页面， 实际上它已经完成了许多透明的工作， 现在就让我们来解释一下它的工作机制， 以帮助理解网站的整 体架构。访问 <a href=\"http://localhost:3000\" target=\"_blank\" rel=\"noopener\">http://localhost:3000</a>，浏览器会向服务器发送以下请求：</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET <span class=\"regexp\">/ HTTP/</span><span class=\"number\">1.1</span></span><br><span class=\"line\"><span class=\"string\">Host:</span> <span class=\"string\">localhost:</span><span class=\"number\">3000</span></span><br><span class=\"line\"><span class=\"string\">Connection:</span> keep-alive</span><br><span class=\"line\">Cache-<span class=\"string\">Control:</span> max-age=<span class=\"number\">0</span></span><br><span class=\"line\">User-<span class=\"string\">Agent:</span> Mozilla<span class=\"regexp\">/5.0 AppleWebKit/</span><span class=\"number\">535.19</span> (KHTML, like Gecko) Chrome/<span class=\"number\">18.0</span><span class=\"number\">.1025</span><span class=\"number\">.142</span></span><br><span class=\"line\"> Safari/<span class=\"number\">535.19</span></span><br><span class=\"line\"><span class=\"string\">Accept:</span> text<span class=\"regexp\">/html,application/</span>xhtml+xml,application<span class=\"regexp\">/xml;q=0.9,*/</span>*;q=<span class=\"number\">0.8</span></span><br><span class=\"line\">Accept-<span class=\"string\">Encoding:</span> gzip,deflate,sdch</span><br><span class=\"line\">Accept-<span class=\"string\">Language:</span> zh;q=<span class=\"number\">0.8</span>,en-US;q=<span class=\"number\">0.6</span>,en;q=<span class=\"number\">0.4</span></span><br><span class=\"line\">Accept-<span class=\"string\">Charset:</span> UTF<span class=\"number\">-8</span>,*;q=<span class=\"number\">0.5</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>app 会 解析请求的路径，调用相应的逻辑。app.js 中有一行内容是 app.get(’/’, routes.index)， 它的作用是规定路径为“/”的 GET 请求由 routes.index 函数处理。routes.index 通 过 res.render(‘index’, { title: ‘Express’ }) 调用视图模板 index，传递 title 变量。最终视图模板生成 HTML 页面，返回给浏览器</p>\n</li>\n<li>\n<p>浏览器在接收到内容以后，经过分析发现要获取 /stylesheets/style.css，因此会再次向服 务器发起请求。 app.js 中并没有一个路由规则指派到 /stylesheets/style.css， 但 app 通过 app.use(express.static(__dirname + ‘/public’)) 配置了静态文件服务器，因此 /stylesheets/style.css 会定向到 app.js 所在目录的子目录中的文件 public/stylesheets/style.css；由 Express 创建的网站架构如下图所示。</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222124034.png\" alt></p>\n</li>\n</ul>\n</li>\n<li>\n<p>创建路由规则</p>\n<blockquote>\n<p>我们在浏览器中访问譬如 <a href=\"http://localhost:3000/abc\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/abc</a> 这样不存在的页面时，服务器会在 响应头中返回 404 Not Found 错误，这是因为 /abc 是一个不存在的路由规则，而且它也不是一个 public 目录下的文件，所以 Express返回了404 Not Found的错误</p>\n</blockquote>\n<ul>\n<li>\n<p>路径匹配</p>\n<p>Express 还支持更高级的路径匹配模式。例 如我们想要展示一个用户的个人页面，路径为 /user/[username]，可以用下面的方法定义路由 规则：</p>\n<p>将routes/index.js文件改成如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* GET home page. */</span></span><br><span class=\"line\">router.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  res.render(<span class=\"string\">'index'</span>, &#123; <span class=\"attr\">title</span>: <span class=\"string\">'Express'</span> &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//增加的代码</span></span><br><span class=\"line\">router.get(<span class=\"string\">'/user/:username'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  res.render(<span class=\"string\">'index'</span>, &#123; <span class=\"attr\">title</span>: <span class=\"string\">'Express'</span>+ <span class=\"string\">\" \"</span> + req.params.username &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = router;</span><br></pre></td></tr></table></figure>\n<p>然后重启app.js，访问：<a href=\"http://localhost:3000/user/nenhall\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/user/nenhall</a></p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222140808.png\" alt></p>\n<p>路径规则 /user/:username 会被自动编译为正则表达式，类似于<code>\\/user\\/(\\[^\\/]+)\\/?</code> 这样的形式。路径参数可以在响应函数中通过 req.params 的属性访问。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>控制权转移</p>\n<ul>\n<li>\n<p>Express 支持同一路径绑定多个路由响应函数，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//router/index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">router.all(<span class=\"string\">'/user/:username'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  res.send(<span class=\"string\">'all methods captured'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(<span class=\"string\">'/user/:username'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  res.render(<span class=\"string\">'index'</span>, &#123; <span class=\"attr\">title</span>: <span class=\"string\">'Express'</span>+ <span class=\"string\">\" \"</span> + req.params.username &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>当你访问任何被两条同样的规则匹配到的路径时，会发现请求总是被前一条路由规则捕获，后面的规则会被忽略，原因是Express在处理路由规则时，会优先匹配定义的路由规则，因此后面相同的规则被屏蔽。</p>\n</li>\n<li>\n<p>Express 提供了路由控制权转移的方法， 通过调用 next()，会将路由控制权转移给后面的规则</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//router/index.js</span></span><br><span class=\"line\">router.all(<span class=\"string\">'/user/:username'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'all methods captured'</span>);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">    <span class=\"comment\">//这个路由规则实际上起到了中间件的作用，我们还可以改成下面这样，在这进行检查用户名的合法性，eg.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (req.params.username == xxxxx) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//do something</span></span><br><span class=\"line\">        next();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(<span class=\"string\">'/user/:username'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  res.render(<span class=\"string\">'index'</span>, &#123; <span class=\"attr\">title</span>: <span class=\"string\">'Express'</span>+ <span class=\"string\">\" \"</span> + req.params.username &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>当访问被匹配到的路径时，如 <a href=\"http://localhost:3000/user/nenhall%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%8E%B0%E7%BB%88%E7%AB%AF%E4%B8%AD%E6%89%93%E5%8D%B0%E4%BA%86\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/user/nenhall，会发现终端中打印了</a> all methods captured，而且浏览器中显示了 user: nenall。说明请求先被第一条路由规则捕获，完成 console.log 使用 next() 转移控制权，又被第二条规则捕获，向浏览器返回了信息。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3><span id=\"模板引擎\">模板引擎</span></h3>\n<h4><span id=\"简介\">简介</span></h4>\n<blockquote>\n<p>模板引擎（Template Engine）是一个从页面模板根据一定的规则生成 HTML 的工具</p>\n</blockquote>\n<p>模板引擎以数据和页面模板为输入，生成 HTML 页面，然后返回给控制器， 由控制器交回客户端。下图是模板引擎在 MVC 架构中的示意图</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222142954.png\" alt></p>\n<h4><span id=\"使用模板引擎\">使用模板引擎</span></h4>\n<blockquote>\n<p>基于 JavaScript 的模板引擎有许多种实现，我们推荐使用 ejs （Embedded JavaScript）， 因为它十分简单，而且与 Express 集成良好。由于它是标准 JavaScript 实现的，因此它不仅 可以运行在服务器端，还可以运行在浏览器中</p>\n<p>ejs 的标签系统非常简单，它只有以下3种标签:</p>\n<ul>\n<li>&lt;% code %&gt;：JavaScript 代码。</li>\n<li>&lt;%= code %&gt;：显示替换过 HTML 特殊字符的内容。</li>\n<li>&lt;%- code %&gt;：显示原始 HTML 内容。</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p>我们在 app.js 中通过以下两个语句设置了模板引擎和页面模板的位置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"comment\">// view engine setup</span></span><br><span class=\"line\">app.set(<span class=\"string\">'views'</span>, path.join(__dirname, <span class=\"string\">'views'</span>));</span><br><span class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'ejs'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 表明要使用的模板引擎是 ejs， 页面模板在 views 子目录下。 在 routes/index.js 的 exports.index 函数中通过如下语句调用模板引擎：</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// router/index.js</span></span><br><span class=\"line\">router.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  res.render(<span class=\"string\">'index'</span>, &#123; <span class=\"attr\">title</span>: <span class=\"string\">'Express'</span> &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// res.render 的功能是调用模板引擎，并将其产生的页面直接返回给客户端。它接受 两个参数，第一个是模板的名称，即 views 目录下的模板文件名，不包含文件的扩展名；第二个参数是传递给模板的数据，用于模板翻译</span></span><br><span class=\"line\"><span class=\"comment\">// res.render('index', &#123; title: 'Express' &#125;); 这句代码的意思：引用了views目录下名为index.ejs文件，并把` &#123; title: 'Express' &#125;`这一个参数过去</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4><span id=\"页面布局\">页面布局</span></h4>\n<blockquote>\n<p>Express3+之后页面布局一起文件放在了/views/index.ejs文件中，在之前是有单独的layout.ejs文件</p>\n</blockquote>\n<h4><span id=\"片段视图\">片段视图</span></h4>\n<blockquote>\n<p>Express 的视图系统还支持片段视图 （partials），它就是一个页面的片段，通常是重复的 内容，用于迭代显示。通过它你可以将相对独立的页面块分割出去</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 在router/index.js 增加如下代码</span></span><br><span class=\"line\">router.get(<span class=\"string\">'/list'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  res.render(<span class=\"string\">'list'</span>, &#123;</span><br><span class=\"line\">  title: <span class=\"string\">'List'</span>,</span><br><span class=\"line\">  items: [<span class=\"number\">1991</span>, <span class=\"string\">'byvoid'</span>, <span class=\"string\">'express'</span>, <span class=\"string\">'Node.js'</span>]</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在 views 目录下新建 list.ejs，内容是：</span></span><br><span class=\"line\">&lt;ul&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%-</span> <span class=\"attr\">partial</span>('<span class=\"attr\">listitem</span>', <span class=\"attr\">items</span>) %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 3. 同时新建 listitem.ejs，内容是：</span></span><br><span class=\"line\">&lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">listitem</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 4.访问 http://localhost:3000/list，可以在源代码中看到刚才的内容：</span></span><br></pre></td></tr></table></figure>\n<p>partial 是一个可以在视图中使用函数，它接受两个参数，第一个是片段视图的名称， 第二个可以是一个对象或一个数组，如果是一个对象，那么片段视图中上下文变量引用的就 是这个对象；如果是一个数组，那么其中每个元素依次被迭代应用到片段视图。片段视图中 上下文变量名就是视图文件名，例如上面的’listitem’。</p>\n<h4><span id=\"视图助手\">视图助手</span></h4>\n<blockquote>\n<p>Express 提供了一种叫做视图助手的工具，它的功能是允许在视图中访问一个全局的函数 或对象，不用每次调用视图解析的时候单独传入。前面提到的 partial 就是一个视图助手。</p>\n<p>视图助手有两类：静态视图助手和动态视图助手。</p>\n<ul>\n<li>静态视图助手：可以是任何类型的对象，包括接受任意参数的函数，但访问到的对象必须是与用户请求无关的，可以通过 app.helpers() 函数注册，它接受一个对象，对象的每个属性名称为视图助手的名称，属性值对应视图助手的值。</li>\n<li>动态视图助手：只能是一个函数，这个函数不能接受参数，但可以访问 req 和 res 对象；通过 app.dynamicHelpers() 注册，方法与静态视图助手相同，但每个属性的值必须为一个函数，该函数提供 req 和 res</li>\n</ul>\n</blockquote>\n<h3><span id=\"建立微博网站\">建立微博网站</span></h3>\n<ul>\n<li>功能点分析：一个完整的微博系统应该支持信息的评论、转发、圈 点用户等功能，但出于演示目的，我们不能一一实现所有功能，只是实现一个微博社交网站 的雏形。</li>\n<li>路由规划：整个网站的骨架部分，因为它处于整个架构的枢纽位置，相当于各个接口之间的粘合剂， 所以应该优先考虑。根据功能设计，我们把路由按照以下方案规划。\n<ul>\n<li>首页</li>\n<li>用户的主页</li>\n<li>发表信息</li>\n<li>用户注册</li>\n<li>用户登录</li>\n<li>用户登出</li>\n<li>用户状态细分：\n<ul>\n<li>发表信息以及用户登出页面必须是已登录用户才能操作的功能</li>\n<li>用户注册和用户登入所面向的对象必须是未登入的用户</li>\n<li>首页和用户主页则 针对已登入和未登入的用户显示不同的内容。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>具体实现省略，主要是用到第三方库</li>\n<li>关键点：app.post(‘/…’, <strong>function</strong>(req, res) {})\n<ul>\n<li>req.body 就是 POST 请求信息解析过后的对象， 例如我们要访问用户传递的<br>\npassword 域的值，只需访问 req.body[‘password’] 即可。</li>\n<li>req.flash 是 Express 提供的一个奇妙的工具，通过它保存的变量只会在用户当前<br>\n和下一次的请求中被访问，之后会被清除，通过它我们可以很方便地实现页面的通知<br>\n和错误信息显示功能。</li>\n<li>res.redirect 是重定向功能，通过它会向用户返回一个 303 See Other 状态，通知<br>\n浏览器转向相应页面。</li>\n<li>crypto 是 Node.js 的一个核心模块，功能是加密并生成各种散列，使用它之前首先<br>\n要声明 var crypto = require(‘crypto’)。我们代码中使用它计算了密码的散<br>\n列值。</li>\n<li>通过 req.session.user = newUser 向会话对象写入了当前用户的信息，在后面<br>\n我们会通过它判断用户是否已经登录。</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Node.js 学习笔记</p>\n<p>[TOC]</p>\n<h2>前言</h2>\n<blockquote>\n<p>本书首先简要介绍 Node.js，然后通过示例讲解 Node.js 的基本特性，再用案例式教学的方式讲述 如何用 Node.js 进行 Web 开发，接着探讨一些 Node.js 进阶话题，最后展示如何将一个 Node.js 应用部署到 生产环境中。</p>\n</blockquote>\n<h2>简介</h2>\n<blockquote>\n<p>本书共6章，分别讨论了 Node.js的背景、安装和配置方法、基本特性、核心模块以及一 些进阶话题。除此之外，还有2个附录，分别介绍了JavaScript 的高级特性和 Node.js 编程规 范。</p>\n<ul>\n<li>Node.js 简介</li>\n<li>安装和配置Node.js</li>\n<li>Node.js 快速入门</li>\n<li>Node.js 核心模块</li>\n<li>使用 Node.js 进行 Web 开发</li>\n<li>Node.js 进阶话题</li>\n<li>附录A JavaScript 的高级特性</li>\n<li>附录B Node.js 编程规范</li>\n</ul>\n</blockquote>\n<h2>第一章 Node.js 简介</h2>\n<h3>Node.js是什么</h3>\n<blockquote>\n<p>Node.js， 或者 Node， 是一个可以让 JavaScript 运行在服务器端的平台。 它可以让 JavaScript 脱离浏览器的束缚运行在一般的服务器环境下，就像运行 Python、Perl、PHP、Ruby 程序一样。你可以用 Node.js 轻松地进行服务器端应用开发，Python、Perl、PHP、Ruby 能 做的事情 Node.js 几乎都能做，而且可以做得更好。</p>\n<p>Node.js 是一个为实时Web（Real-time Web）应用开发而诞生的平台，它从诞生之初就充分 考虑了在实时响应、超大规模数据要求下架构的可扩展性。这使得它摒弃了传统平台依靠多线 程来实现高并发的设计思路，而采用了单线程、异步式I/O、事件驱动式的程序设计模型。这些 特性不仅带来了巨大的性能提升，还减少了多线程程序设计的复杂性，进而提高了开发效率。</p>\n<p>Node.js 不是一种独立的语言，与 PHP、Python、Perl、Ruby 的“既是语言也是平台” 不同。Node.js 也不是一个 JavaScript 框架，不同于 CakePHP、Django、Rails。Node.js 更不 是浏览器端的库，不能与 jQuery、ExtJS 相提并论。Node.js 是一个让 JavaScript 运行在服务 端的开发平台，它让 JavaScript 成为脚本语言世界的一等公民，在服务端堪与 PHP、Python、 Perl、Ruby 平起平坐。</p>\n</blockquote>\n<h3>Node.js能做什么</h3>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  正如 JavaScript 为客户端而生，<span class=\"keyword\">Node</span>.<span class=\"title\">js</span> 为网络而生。<span class=\"keyword\">Node</span>.<span class=\"title\">js</span> 能做的远不止开发一个网 站那么简单，使用 <span class=\"keyword\">Node</span>.<span class=\"title\">js</span>，你可以轻松地开发：</span><br><span class=\"line\">&gt; * 具有复杂逻辑的网站；</span><br><span class=\"line\">&gt; *  基于社交网络的大规模 Web 应用；</span><br><span class=\"line\">&gt; *  Web Socket 服务器；</span><br><span class=\"line\">&gt; *  TCP/UDP 套接字应用程序；</span><br><span class=\"line\">&gt; * 命令行工具；</span><br><span class=\"line\">&gt; * 交互式终端程序；</span><br><span class=\"line\">&gt; *  带有图形用户界面的本地应用程序；</span><br><span class=\"line\">&gt; * 单元测试工具；</span><br><span class=\"line\">&gt; * 客户端 JavaScript 编译器。</span><br><span class=\"line\">&gt;   <span class=\"keyword\">Node</span>.<span class=\"title\">js</span> 内建了 HTTP 服务器支持，也就是说你可以轻而易举地实现一个网站和服务器 的组合。这和 PHP、Perl 不一样，因为在使用 PHP 的时候，必须先搭建一个 Apache 之类的</span><br></pre></td></tr></table></figure>\n<h3>JavaScript 简史</h3>\n<blockquote>\n<p>作为 Node.js 的基础，JavaScript 是一个完全为网络而诞生的语言。在今天看来，JavaScript<br>\n具有其他诸多语言不具备的优势，例如速度快、开销小、容易学习等，但在一开始它却并不<br>\n是这样。多年以来，JavaScript 因为其低效和兼容性差而广受诟病，一直是一个被人嘲笑的 “丑小鸭”，它在成熟之前经历了无数困难和坎坷，个中究竟，还要从它的诞生讲起。</p>\n<p>JavaScript 首次出现在1995年，正如现在的 Node.js 一样，当年 JavaScript 的诞生决不是 偶然的。在1992年，一个叫 Nombas 的公司开发了“C减减”（C minus minus，Cmm）语言， 后来改名为 ScriptEase。ScriptEase 最初的设计是将一种微型脚本语言与一个叫做 Espresso Page 的工具配合，使脚本能够在浏览器中运行，因此 ScriptEase 成为了第一个客户端脚本语言。</p>\n<p>2000年左右，也就是 ASP 蒸蒸日上的年代，很多开发者开始学习 JScript。然而 JScript 在 当时并不是很受欢迎。随着后来 LAMP 的兴起，以及Web 2.0 时代的到来，Ajax 等一系列概念的提出，JavaScript 成了前端开发的代名词，同时服务端 JavaScript 也逐渐被人 遗忘。</p>\n<p>Node.js 是目前 CommonJS 规范最热门的一个实现，它基于 CommonJS 的 Modules/1.0 规 范实现了 Node.js 的模块，同时随着 CommonJS 规范的更新，Node.js 也在不断跟进。</p>\n<p>CommonJS 规范包括了模块（modules）、包（packages）、系统（system）、二进制（binary）、 控制台（console）、编码（encodings）、文件系统（filesystems）、套接字（sockets）、单元测 试（unit testing）等部分。</p>\n</blockquote>\n<ul>\n<li>官方 API 文档http://nodejs.org/api/。</li>\n<li>CNodeJS 社区看看http://cnodejs.org/</li>\n</ul>\n<h2>第二章 安装和配置Node.js</h2>\n<h3>Mac OS X 上安装Node.js</h3>\n<blockquote>\n<p>在官方链接： <a href=\"http://nodejs.org\" target=\"_blank\" rel=\"noopener\">http://nodejs.org</a> 找到Download 链接，然后选择Macintosh Installer，下载安装包。下载完成后运行安装包， 根据提示完成安装；</p>\n<p>Node.js 和 npm 会被安装到 /usr/local/bin 目录下，在macos下源码编译那么需要安装 Xcode</p>\n<p>安装成功后在终端执行命令，确认是正确安装：<code>$ node -v</code> //查看版本号</p>\n</blockquote>\n<h3>Windows 上安装Node.js</h3>\n<blockquote>\n<p>大同小异，或者自行百度</p>\n<p>安装程序不会询问你安装路径， Node.js 会被自动安装到 C:\\Program Files\\nodejs 或 C:\\Program Files (x86)\\nodejs（64位系统）目录下，并且会在系统的 PATH 环境变量中增加该</p>\n<p>源码编译：Node.js 在 Windows 下只能通过 Microsoft Visual Studio 编译</p>\n</blockquote>\n<h3>Linux 上安装Node.js</h3>\n<blockquote>\n<p>大同小异，或者自行百度</p>\n<p>源码编译：Linux上需要使用 g++ 来编译 Node.js。在 Debian/Ubuntu 中，你可以 通过 apt-get install g++ 命令安装g++。在 Fedora/Redhat/CentOS 中，你可以使用 yum install gcc-c++ 安装</p>\n</blockquote>\n<h3>安装多版本管理器</h3>\n<blockquote>\n<p>迄今为止Node.js 更新速度还很快，有时候新版本还会将旧版本的一些 API 废除，以至 于写好的代码不能向下兼容。有时候你可能想要尝试一下新版本有趣的特性，但又想要保持 一个相对稳定的环境。基于这种需求，Node.js 的社区开发了多版本管理器，用于在一台机 器上维护多个版本的 Node.js 实例， 方便按需切换。</p>\n<p>Node 多版本管理器（Node Version Manager，nvm）是一个通用的叫法，它目前有许多不同的实现。通常我们说的 nvm 是指 或者n</p>\n</blockquote>\n<ul>\n<li>\n<p>nvm</p>\n<p><a href=\"https://github.com/creationix/nvm\" target=\"_blank\" rel=\"noopener\">https://github.com/creationix/nvm</a></p>\n<p>如果你已经安装好了 Node.js 和 npm 环境，就可以直接使用 <code>$ npm install -g nvm</code></p>\n</li>\n<li>\n<p>n</p>\n<p><a href=\"https://github.com/visionmedia/n\" target=\"_blank\" rel=\"noopener\">https://github.com/visionmedia/n</a></p>\n<p>如果你已经安装好了 Node.js 和 npm 环境，就可以直接使用 <code>$ npm install -g n</code> n不支持Windows</p>\n<p>安装完 n 以后，在终端中运行 n --help 即可看到它的使用说明</p>\n</li>\n</ul>\n<h2>第三章 Node.js 快速入门</h2>\n<h3>Hello World</h3>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//打开终端</span></span><br><span class=\"line\">$ vim hello.js</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在hello.js文件中写代码</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello World'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行hello.js文件</span></span><br><span class=\"line\">$ node hello.js</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\">Hello World</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//我们可以把要执行的语句作为 node -e 的参数直接执行。</span></span><br><span class=\"line\">$ node -e <span class=\"string\">\"console.log('Hello World');\"</span> </span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\">Hello World</span><br></pre></td></tr></table></figure>\n<h3>使用 <strong>node</strong> 的 REPL 模式</h3>\n<blockquote>\n<p>REPL （Read-eval-print loop），即输入—求值—输出循环，可以进入一个即 时求值的运行环境。运行无参数的 node 将会启动一个 JavaScript 的交互式 shell：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node</span><br><span class=\"line\">&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello World'</span>); Hello World</span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\">&gt; consol.log(<span class=\"string\">'Hello World'</span>);</span><br></pre></td></tr></table></figure>\n<h3>建立 HTTP 服务器</h3>\n<blockquote>\n<p>Node.js 是为网络而诞生的平台，但又与 ASP、PHP 有很大的不同，究竟不同在哪里呢？ 如果你有 PHP 开发经验，会知道在成功运行 PHP 之前先要配置一个功能强大而复杂的 HTTP 服务器，譬如 Apache、IIS 或 Nginx，还需要将 PHP 配置为 HTTP 服务器的模块，或者使用 FastCGI 协议调用 PHP 解释器。这种架构是“浏览器  HTTP 服务器  PHP 解释器”的组织 方式，而Node.js采用了一种不同的组织方式，如下图所示：</p>\n<p>Node.js 将“HTTP服务器”这一层抽离，直接面向浏览器用户。这种架构 从某种意义上来说是颠覆性的， 因而会让人心存疑虑：Node.js作为HTTP服务器的效率足够吗？会不会提高耦合程度？不在这里讨论这种架构的利弊</p>\n</blockquote>\n<p>​\t<img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/Node.js%E4%B8%8EPHP%E7%9A%84%E6%9E%B6%E6%9E%84.png\" alt></p>\n<ul>\n<li>\n<p>建立一个名为 app.js 的文件，内容为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//app.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\"> res.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'text/html'</span>&#125;);</span><br><span class=\"line\"> res.write(<span class=\"string\">'&lt;h1&gt;Node.js&lt;/h1&gt;'</span>);</span><br><span class=\"line\"> res.end(<span class=\"string\">'&lt;p&gt;Hello World&lt;/p&gt;'</span>);</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">3000</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"HTTP server is listening at port 3000.\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>接下来运行 node app.js命令，打开浏览器访问 <a href=\"http://127.0.0.1:3000\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3000</a>，即可看到如下图所示的内容。</p>\n</li>\n<li>\n<p>supervisor</p>\n<blockquote>\n<p>supervisor 可以帮助你实现这个功能，它会监视你对代码的改动，并自动重启 Node.js。 使用方法很简单，首先使用 npm 安装 supervisor：</p>\n<p><code>$ npm install -g supervisor</code></p>\n<p>接下来，使用 supervisor 命令启动 app.js：</p>\n<p><code>$ supervisor app.js</code></p>\n<p>当代码被改动时，运行的脚本会被终止，然后重新启动。</p>\n</blockquote>\n</li>\n</ul>\n<h3>异、同步读取文件</h3>\n<ul>\n<li>\n<p>异步</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 让我们看看在 Node.js 中如何用异步的方式读取一个文件，下面是一个例子：</span></span><br><span class=\"line\"><span class=\"comment\">//readfile.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\">fs.readFile(<span class=\"string\">'file.txt'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'end.'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 运行的结果如下：</span></span><br><span class=\"line\">end.</span><br><span class=\"line\">Contents <span class=\"keyword\">of</span> the file.</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>fs.readFile 调用时所做的工作只是将异步式 I/O 请求发送给了操作系统，然后立即 返回并执行后面的语句，执行完以后进入事件循环监听事件。当 fs 接收到 I/O 请求完成的 事件时，事件循环会主动调用回调函数以完成后续工作</p>\n<p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。在开发者看来，事 件由 EventEmitter 对象提供。前面提到的 fs.readFile 和 http.createServer 的回 调函数都是通过 EventEmitter 来实现的</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>\n<p>同步</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//readfilesync.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = fs.readFileSync(<span class=\"string\">'file.txt'</span>, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'end.'</span>);</span><br><span class=\"line\"><span class=\"comment\">//运行的结果与前面不同， 如下所示：</span></span><br><span class=\"line\">$ node readfilesync.js Contents <span class=\"keyword\">of</span> the file.</span><br><span class=\"line\">end.</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3>Node.js 的事件循环机制</h3>\n<blockquote>\n<p>Node.js 在什么时候会进入事件循环呢？答案是 Node.js 程序由事件循环开始，到事件循 环结束，所有的逻辑都是事件的回调函数，所以 Node.js 始终在事件循环中，程序入口就是 事件循环第一个事件的回调函数。事件的回调函数在执行的过程中，可能会发出 I/O 请求或 直接发射（emit）事件，执行完毕后再返回事件循环，事件循环会检查事件队列中有没有未 处理的事件，直到程序结束。图3-5说明了事件循环的原理。</p>\n</blockquote>\n<p>​\t<img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/node_event_runloop.png\" alt></p>\n<h3>模块和包</h3>\n<blockquote>\n<p>模块（Module）和包（Package）是 Node.js 最重要的支柱。开发一个具有一定规模的程 序不可能只用一个文件，通常需要把各个功能拆分、封装，然后组合起来，模块正是为了实 现这种方式而诞生的。在浏览器 JavaScript 中，脚本模块的拆分和组合通常使用 HTML 的 script 标签来实现。Node.js 提供了 require 函数来调用其他模块，而且模块都是基于文件的，机制十分简单。Node.js 的模块和包机制的实现参照了 CommonJS 的标准， 但并未完全遵循</p>\n</blockquote>\n<h4>什么是模块</h4>\n<blockquote>\n<p>模块是 Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是 JavaScript 代码、JSON 或者编译过的 C/C++ 扩展。</p>\n<p>在前面的例子中，我们曾经用到了 var http = require(‘http’)，其中 http 是 Node.js 的一个核心模块</p>\n</blockquote>\n<ol>\n<li>\n<p>创建模块<br>\n在 Node.js 中，创建一个模块非常简单，因为一个文件就是一个模块，我们要关注的问 题仅仅在于如何在其他文件中获取这个模块。Node.js 提供了 exports 和 require 两个对 象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获 取模块的 exports 对象。</p>\n<ul>\n<li>\n<p>让我们以一个例子来了解模块。创建一个 module.js 的文件，内容是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//module.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name;</span><br><span class=\"line\">exports.setName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">thyName</span>) </span>&#123;</span><br><span class=\"line\">   name = thyName;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">exports.sayHello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello '</span> + name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//在同一目录下创建 getmodule.js， 内容是：</span></span><br><span class=\"line\"><span class=\"comment\">//getmodule.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myModule = <span class=\"built_in\">require</span>(<span class=\"string\">'./module'</span>);</span><br><span class=\"line\">myModule.setName(<span class=\"string\">'mynodetest'</span>); </span><br><span class=\"line\">myModule.sayHello();</span><br><span class=\"line\"><span class=\"comment\">//-------------------------------------------------//</span></span><br><span class=\"line\"><span class=\"comment\">//运行</span></span><br><span class=\"line\">$ node getmodule.js，</span><br><span class=\"line\"><span class=\"comment\">//结果：</span></span><br><span class=\"line\">Hello mynodetest</span><br></pre></td></tr></table></figure>\n<p>在以上示例中，module.js 通过 exports 对象把 setName 和 sayHello 作为模块的访 问接口，在 getmodule.js 中通过 require(’./module’) 加载这个模块，然后就可以直接访 问 module.js 中 exports 对象的成员函数了。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>覆盖 exports</p>\n<ul>\n<li>\n<p>有时候我们只是想把一个对象封装到模块中，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//hello.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Hello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> name;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">thyName</span>) </span>&#123;</span><br><span class=\"line\">      name = thyName;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.sayHello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello '</span> + name);</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = Hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//gethello.js</span></span><br><span class=\"line\"><span class=\"comment\">//这样就可以直接获得这个对象了：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Hello = <span class=\"built_in\">require</span>(<span class=\"string\">'./hello'</span>);</span><br><span class=\"line\">hello = <span class=\"keyword\">new</span> Hello();</span><br><span class=\"line\">hello.setName(<span class=\"string\">'BYVoid'</span>);</span><br><span class=\"line\">hello.sayHello();</span><br></pre></td></tr></table></figure>\n<p>注意，模块接口的唯一变化是使用 module.exports = Hello 代替了 exports.Hello= Hello。在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。事实上，exports 本身仅仅是一个普通的空对象，即 {}，它专门用来声明接口，本 质上是通过它为模块闭包的内部建立了一个有限的访问接口</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4>什么是包</h4>\n<blockquote>\n<p>包是在模块基础上更深一步的抽象，Node.js 的包类似于 C/C++ 的函数库或者 Java/.Net 的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。Node.js 根 据 CommonJS 规范实现了包机制，开发了 npm来解决包的发布和获取需求。<br>\nNode.js 的包是一个目录，其中包含一个 JSON 格式的包说明文件 package.json。严格符 合 CommonJS 规范的包应该具备以下特征：</p>\n<ul>\n<li>package.json 必须在包的顶层目录下；</li>\n<li>二进制文件应该在 bin 目录下；</li>\n<li>JavaScript 代码应该在 lib 目录下；</li>\n<li>文档应该在 doc 目录下；</li>\n<li>单元测试应该在 test 目录下。</li>\n</ul>\n<p>Node.js 对包的要求并没有这么严格，只要顶层目录下有 package.json，并符合一些规范 即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 CommonJS 规范。</p>\n</blockquote>\n<ul>\n<li>\n<p>以文件夹作为模块</p>\n<blockquote>\n<p>模块与文件是一一对应的。文件不仅可以是 JavaScript 代码或二进制代码，还可以是一 个文件夹。最简单的包，就是一个作为文件夹的模块。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//somepackage/index.js exports.hello = function() &#123;</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello.'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//然后在 somepackage 之外建立 getpackage.js，内容如下：</span></span><br><span class=\"line\"><span class=\"comment\">//getpackage.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> somePackage = <span class=\"built_in\">require</span>(<span class=\"string\">'./somepackage'</span>); </span><br><span class=\"line\">somePackage.hello();</span><br><span class=\"line\"><span class=\"comment\">//运行 </span></span><br><span class=\"line\">$ node getpackage.js，</span><br><span class=\"line\"><span class=\"comment\">//控制台将输出结果 Hello.。</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>package.json</p>\n<p>在前面的例子中的somepackage文件夹下，创建一个叫package.json的文件，内容如下：</p>\n<p><strong>还可以进入somepackage目录，使用命令来生成一个package.json:<code>$ npm init -f</code></strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"string\">\"main\"</span> : <span class=\"string\">\"./lib/interface.js\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后将 index.js 重命名为 interface.js 并放入 lib 子文件夹下。以同样的方式再次调用这个 包，依然可以正常使用。</p>\n<p>因为Node.js 在调用某个包时，会首先检查包中 package.json 文件的 main 字段，将其作为 包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作 为包的接口。</p>\n<blockquote>\n<p>package.json 是 CommonJS 规定的用来描述包的文件，完全符合规范的 package.json 文 件应该含有以下字段。</p>\n<ul>\n<li>name：包的名称，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含<br>\n空格。</li>\n<li>description：包的简要说明。</li>\n<li>version：符合语义化版本识别 规范的版本字符串。</li>\n<li>keywords：关键字数组，通常用于搜索。</li>\n<li>maintainers：维护者数组，每个元素要包含 name、email （可选）、web （可选）<br>\n字段。</li>\n<li>contributors：贡献者数组，格式与maintainers相同。包的作者应该是贡献者<br>\n数组的第一个元素。</li>\n<li>bugs：提交bug的地址，可以是网址或者电子邮件地址。</li>\n<li>licenses：许可证数组，每个元素要包含 type （许可证的名称）和 url （链接到<br>\n许可证文本的地址）字段。</li>\n<li>repositories：仓库托管地址数组，每个元素要包含 type（仓库的类型，如 git ）、url （仓库的地址）和 path （相对于仓库的路径，可选）字段。</li>\n<li>dependencies：包的依赖，一个关联数组，由包名称和版本号组成。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h4>Node.js 包管理器</h4>\n<blockquote>\n<p>Node.js包管理器，即npm是 Node.js 官方提供的包管理工具①，它已经成了 Node.js 包的 标准发布平台，用于 Node.js 包的发布、传播、依赖控制。npm 提供了命令行工具，使你可 以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。</p>\n</blockquote>\n<ul>\n<li>\n<p>获取一个包</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用 npm 安装包的命令格式为：</span></span><br><span class=\"line\">npm [install/i] [package_name]</span><br><span class=\"line\"><span class=\"comment\">//例如你要安装 express，可以在命令行运行：</span></span><br><span class=\"line\"><span class=\"symbol\">$</span> npm install express</span><br><span class=\"line\">或者：<span class=\"symbol\">$</span> npm i express</span><br><span class=\"line\"><span class=\"comment\">//安装成功后，放置在当前目录的 node_modules 子目录下</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>本地模式和全局模式</p>\n<blockquote>\n<p>npm在默认情况下会从http://npmjs.org搜索或下载包，将包安装到当前目录的node_modules 子目录下。</p>\n<p>npm 还有另一种不同的安装模式被成为全局模式，使用方法为：</p>\n<p>$ npm [install/i] -g [package_name]</p>\n<p>eg.: $ npm install -g supervisor 命令，就是以全局模式安装 supervisor。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>\n<p>当我们使用全局模 式安装时，npm 会将包安装到系统目录，如 /usr/local/lib/node_modules/，同时 package.json 文 件中 bin 字段包含的文件会被链接到 /usr/local/bin/</p>\n</li>\n<li>\n<p>使用全局模式安装的包并不能直接在 JavaScript 文件中用 require 获得，因为 require 不会搜索 /usr/local/lib/node_modules/。</p>\n<p>​\t\t\t\t<strong>表 - 本地模式与全局模式</strong></p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>可通过 require 使用</th>\n<th>注册PATH</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>本地模式</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>全局模式</td>\n<td>否</td>\n<td>是</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>创建全局链接</p>\n<blockquote>\n<p>npm 提供了一个链接命令 npm link，它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 require 使用，但通过 npm link命令 可以打破这一限制。</p>\n</blockquote>\n<p>例子：</p>\n<p>我们已经通过 npm install -g express 安装了 express， 这时在工程的目录下运行命令：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm link <span class=\"built_in\">express</span></span><br><span class=\"line\">./node_modules/<span class=\"built_in\">express</span> -&gt; /usr/<span class=\"built_in\">local</span>/lib/node_modules/<span class=\"built_in\">express</span></span><br></pre></td></tr></table></figure>\n<p>我们可以在 node_modules 子目录中发现一个指向安装到全局的包的符号链接。通过这 种方法，我们就可以把全局包当本地包来使用了。</p>\n</li>\n</ul>\n<h4>调试</h4>\n<ul>\n<li>命令行调试：在命令行下执行 node debug debug.js，将会启动调试工具</li>\n</ul>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node debug debug.js</span><br><span class=\"line\">&lt; <span class=\"keyword\">debugger</span> listening <span class=\"keyword\">on</span> port <span class=\"number\">5858</span> connecting... ok</span><br><span class=\"line\"><span class=\"keyword\">break</span> <span class=\"keyword\">in</span> /home/byvoid/<span class=\"attribute\">debug.js</span>:<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"keyword\">var</span> b = <span class=\"string\">'world'</span>;</span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"keyword\">var</span> c = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; debug&gt;</span><br></pre></td></tr></table></figure>\n<p>​\t<strong>Node.js 调试命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>run</td>\n<td>执行脚本，在第一行暂停</td>\n</tr>\n<tr>\n<td>restart</td>\n<td>重新执行脚本</td>\n</tr>\n<tr>\n<td>cont, c</td>\n<td>继续执行，直到遇到下一个断点 单步执行</td>\n</tr>\n<tr>\n<td>next, n</td>\n<td>单步执行</td>\n</tr>\n<tr>\n<td>step, s</td>\n<td>单步执行并进入函数</td>\n</tr>\n<tr>\n<td>out, o</td>\n<td>从函数中步出</td>\n</tr>\n<tr>\n<td>setBreakpoint(), sb()</td>\n<td>在当前行设置断点</td>\n</tr>\n<tr>\n<td>setBreakpoint(‘f()’), sb(…)</td>\n<td>在函数f的第一行设置断点</td>\n</tr>\n<tr>\n<td>setBreakpoint(‘script.js’, 20), sb(…)</td>\n<td>在script.js 的第20行设置断点</td>\n</tr>\n<tr>\n<td>clearBreakpoint, cb(…)</td>\n<td>清除所有断点</td>\n</tr>\n<tr>\n<td>backtrace, bt</td>\n<td>显示当前的调用栈</td>\n</tr>\n<tr>\n<td>list(5)</td>\n<td>显示当前执行到的前后5行代码</td>\n</tr>\n<tr>\n<td>watch(expr)</td>\n<td>把表达式 expr 加入监视列表</td>\n</tr>\n<tr>\n<td>unwatch(expr)</td>\n<td>把表达式 expr 加入监视列表</td>\n</tr>\n<tr>\n<td>watchers</td>\n<td>显示监视列表中所有的表达式和值</td>\n</tr>\n<tr>\n<td>repl</td>\n<td>在当前上下文打开即时求值环境</td>\n</tr>\n<tr>\n<td>kill</td>\n<td>终止当前执行的脚本</td>\n</tr>\n<tr>\n<td>scripts</td>\n<td>显示当前已加载的所有脚本</td>\n</tr>\n<tr>\n<td>version</td>\n<td>显示 V8 的版本</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>远程调试：V8 提供的调试功能是基于 TCP 协议的，因此 Node.js 可以轻松地实现远程调试。在命令行下使用以下两个语句之一可以打开调试服务器：</p>\n<ul>\n<li>\n<p>打开调试服务器</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">node</span> <span class=\"title\">--debug</span>[=port] script.js </span><br><span class=\"line\"><span class=\"keyword\">node</span> <span class=\"title\">--debug-brk</span>[=port] script.js</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>当调试服务器启动以后，可以用命令行调试工具作为调试客户端连接，例如：</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在一个终端中</span></span><br><span class=\"line\">$ node --debug-brk debug.js <span class=\"keyword\">debugger</span> listening <span class=\"keyword\">on</span> port <span class=\"number\">5858</span></span><br><span class=\"line\"><span class=\"comment\">//在另一个终端中</span></span><br><span class=\"line\">$ node debug <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">5858</span></span><br><span class=\"line\">connecting... ok</span><br><span class=\"line\">debug&gt; n</span><br><span class=\"line\"><span class=\"keyword\">break</span> <span class=\"keyword\">in</span> /home/byvoid/<span class=\"attribute\">debug.js</span>:<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"keyword\">var</span> b = <span class=\"string\">'world'</span>;</span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"keyword\">var</span> c = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello '</span> + x + a); debug&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>使用 node-inspector 调试 Node.js</p>\n<blockquote>\n<p>大部分基于 Node.js 的应用都是运行在浏览器中的，例如强大的调试工具 node-inspector。 node-inspector 是一个完全基于 Node.js 的开源在线调试工具，提供了强大的调试功能和友好 的用户界面，它的使用方法十分简便。</p>\n</blockquote>\n<ul>\n<li>首先，使用 npm install -g node-inspector 命令安装 node-inspector，然后在终 端中通过 node --debug-brk=5858 debug.js 命令连接你要除错的脚本的调试服务器， 启动 node-inspector：</li>\n<li>$ node-inspector</li>\n<li>在浏览器中打开 <a href=\"http://127.0.0.1:8080/debug?port=5858%EF%BC%8C%E5%8D%B3%E5%8F%AF%E6%98%BE%E7%A4%BA%E5%87%BA%E4%BC%98%E9%9B%85%E7%9A%84\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080/debug?port=5858，即可显示出优雅的</a> Web 调试工 具</li>\n</ul>\n</li>\n<li>\n<p>使用 Eclipse 调试 Node.js(这里不做介绍)</p>\n</li>\n</ul>\n<h2>第四章 Node.js 核心模块</h2>\n<blockquote>\n<p>核心模块是 Node.js 的心脏，它由一些精简而高效的库组成，为 Node.js 提供了基本的 API。本章中，我们挑选了一部分最常用的核心模块加以详细介绍，主要内容包括：</p>\n<ul>\n<li>全局对象；</li>\n<li>常用工具；</li>\n<li>事件机制；</li>\n<li>文件系统访问；</li>\n<li>HTTP 服务器与客户端。</li>\n</ul>\n</blockquote>\n<h3>全局对象</h3>\n<h4>全局对象</h4>\n<blockquote>\n<p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可 以在程序的任何地方访问，即全局变量。在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p>\n</blockquote>\n<h4>全局变量</h4>\n<blockquote>\n<p>global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：</p>\n<ul>\n<li>在最外层定义的变量；</li>\n<li>全局对象的属性；</li>\n<li>隐式定义的变量（未定义直接赋值的变量）。</li>\n</ul>\n</blockquote>\n<h3>常用工具 util</h3>\n<blockquote>\n<p>util 是一个 Node.js 核心模块，提供常用函数的集合，用于弥补核心 JavaScript 的功能 过于精简的不足。</p>\n</blockquote>\n<h4>util.inherits</h4>\n<blockquote>\n<p>util.inherits(constructor, superConstructor) 是一个实现对象间原型继承 的函数。JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的，具体细节我们在附录A中讨论， 在这里我们只介绍 util.inherits 的用法，示例如下：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Base</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'base'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.base = <span class=\"number\">1991</span>,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello :'</span>+ <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Base.prototype.showName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'this.name :'</span>, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sub</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'sub'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">util.inherits(Sub, Base);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> objBase = <span class=\"keyword\">new</span> Base();</span><br><span class=\"line\">objBase.showName();</span><br><span class=\"line\">objBase.sayHello();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(objBase);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> objSub = <span class=\"keyword\">new</span> Sub();</span><br><span class=\"line\">objSub.showName();</span><br><span class=\"line\"><span class=\"comment\">// objSub.sayHello();</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'objSub :'</span>, objSub);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'util.inspect(obj) :'</span>, util.inspect(objBase,<span class=\"literal\">true</span>,<span class=\"number\">2</span>,<span class=\"literal\">true</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输入结果：</span></span><br><span class=\"line\">➜  http0test node <span class=\"built_in\">module</span>.js</span><br><span class=\"line\"><span class=\"keyword\">this</span>.name : base</span><br><span class=\"line\">hello :base</span><br><span class=\"line\">Base &#123; <span class=\"attr\">name</span>: <span class=\"string\">'base'</span>, <span class=\"attr\">base</span>: <span class=\"number\">1991</span>, <span class=\"attr\">sayHello</span>: [<span class=\"built_in\">Function</span>] &#125;</span><br><span class=\"line\"><span class=\"keyword\">this</span>.name : sub</span><br><span class=\"line\">objSub : Sub &#123; <span class=\"attr\">name</span>: <span class=\"string\">'sub'</span> &#125;</span><br><span class=\"line\">util.inspect(obj) : Base &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'base'</span>,</span><br><span class=\"line\">  base: <span class=\"number\">1991</span>,</span><br><span class=\"line\">  sayHello:</span><br><span class=\"line\">   &#123; [<span class=\"built_in\">Function</span>]</span><br><span class=\"line\">     [length]: <span class=\"number\">0</span>,</span><br><span class=\"line\">     [name]: <span class=\"string\">''</span>,</span><br><span class=\"line\">     [<span class=\"built_in\">arguments</span>]: <span class=\"literal\">null</span>,</span><br><span class=\"line\">     [caller]: <span class=\"literal\">null</span>,</span><br><span class=\"line\">     [prototype]: &#123; [<span class=\"keyword\">constructor</span>]: [Circular] &#125; &#125; &#125;</span><br></pre></td></tr></table></figure>\n<h4>util.inspect</h4>\n<blockquote>\n<p>util.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。</p>\n<ul>\n<li>showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。</li>\n<li>depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。</li>\n<li>color 值如果为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。</li>\n</ul>\n</blockquote>\n<h3>事件驱动 events</h3>\n<blockquote>\n<p>events 是 Node.js 最重要的模块，没有“之一”，原因是 Node.js 本身架构就是事件式 的，而它提供了唯一的接口，所以堪称 Node.js 事件编程的基石。events 模块不仅用于用户代码与 Node.js 下层事件循环的交互，还几乎被所有的模块依赖。</p>\n</blockquote>\n<h4>事件发射器（events.EventEmitter）</h4>\n<blockquote>\n<p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就 是事件发射与事件监听器功能的封装</p>\n</blockquote>\n<ul>\n<li>\n<p>常规事件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//我们介绍一下EventEmitter常用的API。</span></span><br><span class=\"line\"><span class=\"comment\">//为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数 listener。</span></span><br><span class=\"line\">EventEmitter.on(event, listener) </span><br><span class=\"line\"><span class=\"comment\">//发射 event 事件，传递若干可选参数到事件监听器的参数表。</span></span><br><span class=\"line\">EventEmitter.emit(event, [arg1], [arg2], [...]) </span><br><span class=\"line\"><span class=\"comment\">//为指定事件注册一个单次监听器， 即监听器最多只会触发一次，触发后立刻解除该监听器。</span></span><br><span class=\"line\">EventEmitter.once(event, listener) </span><br><span class=\"line\"><span class=\"comment\">//移除指定事件的某个监听器，listener 必须是该事件已经注册过的监听器。</span></span><br><span class=\"line\">EventEmitter.removeListener(event, listener) </span><br><span class=\"line\"><span class=\"comment\">//移除所有事件的所有监听器，如果指定 event，则移除指定事件的所有监听器。</span></span><br><span class=\"line\">EventEmitter.removeAllListeners([event]) </span><br><span class=\"line\"><span class=\"comment\">//更详细的 API 文档参见 http://nodejs.org/api/events.html。</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> events = <span class=\"built_in\">require</span>(<span class=\"string\">'events'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> emitter = <span class=\"keyword\">new</span> event.EventEmitter();</span><br><span class=\"line\"></span><br><span class=\"line\">emitter.on(<span class=\"string\">'someEvent'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arg1, arg2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listener1'</span>, arg1, arg2);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">emitter.on(<span class=\"string\">'someEvent'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arg1, arg2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listener2'</span>, arg1, arg2);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">emitter.emit(<span class=\"string\">'someEvent'</span>, <span class=\"string\">'byvoid'</span>, <span class=\"number\">1991</span>);</span><br><span class=\"line\"><span class=\"comment\">// 运行的结果是：</span></span><br><span class=\"line\"><span class=\"comment\">// listener1 byvoid 1991 </span></span><br><span class=\"line\"><span class=\"comment\">// listener2 byvoid 1991</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>error事件</p>\n<blockquote>\n<p>EventEmitter 定义了一个特殊的事件 error，它包含了“错误”的语义，我们在遇到 异常的时候通常会发射 error 事件。当 error 被发射时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并打印调用栈</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> events = <span class=\"built_in\">require</span>(<span class=\"string\">'events'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> emitter = <span class=\"keyword\">new</span> events.EventEmitter();</span><br><span class=\"line\">emitter.emit(<span class=\"string\">'error'</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3>文件系统 fs</h3>\n<blockquote>\n<p>fs 模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接等 POSIX 文件系统操作</p>\n</blockquote>\n<ul>\n<li>\n<p>fs.readFile:</p>\n<p>fs.readFile(filename,[encoding],[callback(err,data)]) 是最简单的读取 文件的函数。它接受一个必选参数 filename，表示要读取的文件名。第二个参数 encoding 是可选的，表示文件的字符编码（不指定编码格式，则data形式输出）。callback 是回调函数，用于接收文件的内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\">fs.readFile(<span class=\"string\">'output.txt'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'fileData: :'</span>, data);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\">➜  nodejs_note node app.js</span><br><span class=\"line\">fileData: : nenhall 学习node.js 笔记</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>fs.readFileSync</p>\n<p>fs.readFileSync(filename, [encoding])是 fs.readFile 同步的版本。它接受 的参数和 fs.readFile 相同，而读取到的文件内容会以函数返回值的形式返回。如果有错 误发生，fs 将会抛出异常，你需要使用 try 和 catch 捕捉并处理异常。</p>\n</li>\n<li>\n<p>fs.open</p>\n<p>fs.open(path, flags, [mode], [callback(err, fd)])是 POSIX open 函数的 封装，与 C 语言标准库中的 fopen 函数类似。它接受两个必选参数，path 为文件的路径， flags 可以是以下值:</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r ：以读取模式打开文件。</span><br><span class=\"line\">r+ ：以读写模式打开文件。</span><br><span class=\"line\">w ：以写入模式打开文件，如果文件不存在则创建。</span><br><span class=\"line\">w+ ：以读写模式打开文件，如果文件不存在则创建。</span><br><span class=\"line\">a ：以追加模式打开文件，如果文件不存在则创建。</span><br><span class=\"line\">a+ ：以读取追加模式打开文件，如果文件不存在则创建。</span><br><span class=\"line\">mode 参数用于创建文件时给文件指定权限，默认是 <span class=\"number\">0666</span></span><br><span class=\"line\">callback：回调函数将会传递一个文 件描述符 fd</span><br><span class=\"line\"></span><br><span class=\"line\">注意：文件权限指的是 POSIX 操作系统中对文件读取和访问权限的规范，通常用一个八进制数来表示。例如 <span class=\"number\">0754</span> 表示文件所有者的权限是 <span class=\"number\">7</span> （读、写、执行），同组的用户权限是 <span class=\"number\">5</span> （读、执行），其他用户的权限是 <span class=\"number\">4</span>（读）， 写成字符表示就是 -rwxr-xr--。</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>fs.read</p>\n<p>fs.read(fd, buffer, offset, length, position, [callback(err, bytesRead, buffer)])是 POSIX read 函数的封装，相比 fs.readFile 提供了更底层的接口。fs.read 的功能是从指定的文件描述符:</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fd 中读取数据并写入 </span><br><span class=\"line\"><span class=\"built_in\">buffer</span> 指向的缓冲区对象。</span><br><span class=\"line\">offset 是 <span class=\"built_in\">buffer</span> 的写入偏移量。</span><br><span class=\"line\">length 是要从文件中读取的字节数。</span><br><span class=\"line\"><span class=\"built_in\">position</span> 是文件读取的起始 位置， 如果 <span class=\"built_in\">position</span> 的值为 null ， 则会从当前文件指针的位置读取。</span><br><span class=\"line\">回调函数传递 bytesRead 和 <span class=\"built_in\">buffer</span>，分别表示读取的字节数和缓冲区对象。</span><br></pre></td></tr></table></figure>\n<p>相关函数：</p>\n<p>fs.openSync(path, flags, [mode]) 对 fs.closeSync(fd)</p>\n<p>fs.read(fd, buffer, offset, length, position, callback()])  对 fs.close(fd, [callback(err)])</p>\n</li>\n</ul>\n<h3>HTTP 服务器与客户端</h3>\n<blockquote>\n<p>Node.js 标准库提供了 http 模块，其中封装了一个高效的 HTTP 服务器和一个简易的 HTTP 客户端。http.Server 是一个基于事件的 HTTP 服务器，它的核心由 Node.js 下层 C++ 部分实现，而接口由 JavaScript 封装，兼顾了高性能与简易性。http.request 则是一个 HTTP 客户端工具，用于向 HTTP 服务器发起请求</p>\n</blockquote>\n<h4>HTTP 服务</h4>\n<blockquote>\n<p>http.Server 是 http 模块中的 HTTP 服务器对象，用 Node.js 做的所有基于 HTTP 协 议的系统，如网站、社交应用甚至代理服务器，都是基于 http.Server 实现的。它提供了 一套封装级别很低的 API，仅仅是流控制和简单的消息解析，所有的高层功能都要通过它的 接口来实现。</p>\n</blockquote>\n<ul>\n<li>\n<p>实现一个服务器</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//app.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 创建了一个 http.Server 的实例</span></span><br><span class=\"line\"><span class=\"comment\">// 将一个函数作为 HTTP 请求处理函数,这个函数接受两个参数，分别是请求对象(req)和响应对象(res)</span></span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//响应代码200（表示请求成功）,指定响应头为'Content-Type': 'text/html'</span></span><br><span class=\"line\">   res.writeHead(<span class=\"number\">200</span>, &#123;</span><br><span class=\"line\">      <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'text/html'</span></span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">   <span class=\"comment\">// 写入响应体 '&lt;h1&gt;Node.js&lt;/h1&gt;'</span></span><br><span class=\"line\">   res.write(<span class=\"string\">'&lt;h1&gt;Node.js&lt;/h1&gt;'</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 通过 res.end 结束并发送</span></span><br><span class=\"line\">   res.end(<span class=\"string\">'&lt;p&gt;Hello World&lt;/p&gt;'</span>);</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">3000</span>);<span class=\"comment\">//listen 函数，启动服务器并监听 3000 端口</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"HTTP server is listening at port 3000.\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong>http.Server</strong> 的事件</p>\n<p>http.Server 是一个基于事件的 HTTP 服务器，所有的请求都被封装为独立的事件， 开发者只需要对它的事件编写响应函数即可实现 HTTP 服务器的所有功能。它继承自 EventEmitter</p>\n<ul>\n<li>request：当客户端请求到来时，该事件被触发，提供两个参数 req 和res，分别是http.ServerRequest 和 http.ServerResponse 的实例，表示请求和响应信息。</li>\n<li>connection ：当 TCP 连接建立时， 该事件被触发， 提供一个参数 socket ， 为net.Socket 的实例。connection 事件的粒度要大于 request ， 因为客户端在Keep-Alive 模式下可能会在同一个连接内发送多次请求。</li>\n<li>close ：当服务器关闭时，该事件被触发。注意不是在用户连接断开时。</li>\n</ul>\n</li>\n<li>\n<p><strong>http.ServerRequest</strong></p>\n<ol>\n<li>\n<p>http.ServerRequest 是 HTTP 请求的信息，是后端开发者最关注的内容。它一般由 http.Server 的 request 事件发送，作为第一个参数传递，通常简称 request 或 req</p>\n</li>\n<li>\n<p>HTTP 请求一般可以分为两部分：请求头（Request Header）和请求体（Requset Body）。 以上内容由于长度较短都可以在请求头解析完成后立即读取。</p>\n</li>\n<li>\n<p>请求体可能相对较长， 需要一定的时间传输，因此 http.ServerRequest 提供了以下3个事件用于控制请求体 传输。</p>\n<ul>\n<li>data ：当请求体数据到来时，该事件被触发。该事件提供一个参数 chunk，表示接收到的数据。如果该事件没有被监听，那么请求体将会被抛弃。该事件可能会被调用多次。</li>\n<li>end ：当请求体数据传输完成时，该事件被触发，此后将不会再有数据到来。</li>\n<li>close： 用户当前请求结束时，该事件被触发。不同于 end，如果用户强制终止了传输，也还是调用close。</li>\n</ul>\n</li>\n<li>\n<p><strong>ServerRequest</strong> 的属性表</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>complete</td>\n<td>客户端请求是否已经发送完成</td>\n</tr>\n<tr>\n<td>httpVersion</td>\n<td>HTTP 协议版本，通常是 1.0 或 1.1</td>\n</tr>\n<tr>\n<td>method</td>\n<td>HTTP 请求方法，如 GET、POST、PUT、DELETE 等</td>\n</tr>\n<tr>\n<td>url</td>\n<td>原始的请求路径，例如/static/image/x.jpg 或/user?name=byvoid</td>\n</tr>\n<tr>\n<td>headers</td>\n<td>HTTP 请求头</td>\n</tr>\n<tr>\n<td>trailers</td>\n<td>HTTP 请求尾（不常见）</td>\n</tr>\n<tr>\n<td>connection</td>\n<td>当前 HTTP 连接套接字，为 net.Socket 的实例</td>\n</tr>\n<tr>\n<td>socket</td>\n<td>connection 属性的别名</td>\n</tr>\n<tr>\n<td>client</td>\n<td>client 属性的别名</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>获取 GET 请求内容</p>\n<p>由于 GET 请求直接被嵌入在路径 中，URL是完整的请求路径，包括了 ? 后面的部分，因此你可以手动解析后面的内容作为 GET 请求的参数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">   res.writeHead(<span class=\"number\">200</span>, &#123;</span><br><span class=\"line\">      <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'text/plain'</span></span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">   res.end(util.inspect(url.parse(req.url, <span class=\"literal\">true</span>)));</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">3000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//浏览器中输入：http://127.0.0.1:3000/user?name=byvoid&amp;email=byvoid@byvoid.com</span></span><br><span class=\"line\"><span class=\"comment\">//展示：</span></span><br><span class=\"line\">Url &#123;</span><br><span class=\"line\">  protocol: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  slashes: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  auth: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  host: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  port: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  hostname: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  hash: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  search: <span class=\"string\">'?name=byvoid&amp;email=byvoid@byvoid.com'</span>,</span><br><span class=\"line\">  query:</span><br><span class=\"line\">   [<span class=\"built_in\">Object</span>: <span class=\"literal\">null</span> prototype] &#123; <span class=\"attr\">name</span>: <span class=\"string\">'byvoid'</span>, <span class=\"attr\">email</span>: <span class=\"string\">'byvoid@byvoid.com'</span> &#125;,</span><br><span class=\"line\">  pathname: <span class=\"string\">'/user'</span>,</span><br><span class=\"line\">  path: <span class=\"string\">'/user?name=byvoid&amp;email=byvoid@byvoid.com'</span>,</span><br><span class=\"line\">  href: <span class=\"string\">'/user?name=byvoid&amp;email=byvoid@byvoid.com'</span> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<ol start=\"6\">\n<li>\n<p>获取 POST 请求内容</p>\n<p>HTTP 协议 1.1 版本提供了8种标准的请求方法，其中最常见的就是 GET 和 POST。相比 GET 请求把所有的内容编码到访问路径中， POST 请求的内容全部都在请求体中。 http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作，譬如上传文件。而很多时候我们可能并不需要理会请求体的内容，恶意的POST 请求会大大消耗服务器的资源。所以 Node.js 默认是不会解析请求体的，当你需要的时候， 需要手动来做</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> post = <span class=\"string\">''</span>;</span><br><span class=\"line\">   req.on(<span class=\"string\">'end'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      post = querystring.parse(post);</span><br><span class=\"line\">      res.end(util.inspect(post));</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<p>上面代码并没有在请求响应函数中向客户端返回信息，而是定义了一个 post 变量。通过 req 的 data 事件监听函数，每当接受到请求体的数据， 就累加到 post 变量中。在 end 事件触发后，通过 querystring.parse 将 post 解析为真正的 POST 请求格式，然后向客户端返回</p>\n<p>**注意：**不要在真正的生产应用中使用上面这种简单的方法来获取 POST 请求，因为它有严重的效率和安全问题</p>\n</li>\n</ol>\n<ol start=\"7\">\n<li>\n<p><strong>http.ServerResponse</strong><br>\nhttp.ServerResponse 是返回给客户端的信息，决定了用户最终能看到的结果。它 也是由 http.Server 的 request 事件发送的， 作为第二个参数传递， 一般简称为 response 或 res。</p>\n<blockquote>\n<p>http.ServerResponse 有三个重要的成员函数，用于返回响应头、响应内容以及结束 请求。</p>\n<ul>\n<li>response.writeHead(statusCode, [headers])：向请求的客户端发送响应头。<br>\nstatusCode 是 HTTP 状态码，如 200 （请求成功）、404 （未找到）等。headers<br>\n是一个类似关联数组的对象，表示响应头的每个属性。该函数在一个请求内最多只<br>\n能调用一次，如果不调用，则会自动生成一个响应头。</li>\n<li>response.write(data, [encoding])：向请求的客户端发送响应内容。data 是<br>\n一个 Buffer 或字符串，表示要发送的内容。如果 data 是字符串，那么需要指定<br>\nencoding 来说明它的编码方式，默认是 utf-8。在 response.end 调用之前，<br>\nresponse.write 可以被多次调用。</li>\n<li>response.end([data], [encoding])：结束响应，告知客户端所有发送已经完<br>\n成。当所有要返回的内容发送完毕的时候，该函数 必须 被调用一次。它接受两个可<br>\n选参数，意义和 response.write 相同。如果不调用该函数，客户端将永远处于<br>\n等待状态。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h4>HTTP 客户端</h4>\n<blockquote>\n<p>http 模块提供了两个函数 http.request 和 http.get，功能是作为客户端向 HTTP 服务器发起请求。</p>\n<p>http.request(options, callback) 发起 HTTP 请求。接受两个参数，option 是<br>\n一个类似关联数组的对象，表示请求的参数，callback 是请求的回调函数。option<br>\n常用的参数如下所示。</p>\n<ul>\n<li>host ：请求网站的域名或 IP 地址。</li>\n<li>port ：请求网站的端口，默认 80。</li>\n<li>method ：请求方法，默认是 GET。</li>\n<li>path ：请求的相对于根的路径，默认是“/”。QueryString 应该包含在其中。例如 /search?query=byvoid。</li>\n<li>headers ：一个关联数组对象，为请求头的内容。</li>\n<li>callback 传递一个参数，为 http.ClientResponse 的实例。<br>\nhttp.request 返回一个 http.ClientRequest 的实例。</li>\n</ul>\n</blockquote>\n<p>下面是一个通过 http.request 发送 POST 请求的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//httprequest.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> contents = querystring.stringify(&#123;</span><br><span class=\"line\">   name: <span class=\"string\">'byvoid'</span>,</span><br><span class=\"line\">   email: <span class=\"string\">'byvoid@byvoid.com'</span>,</span><br><span class=\"line\">   address: <span class=\"string\">'Zijing 2#, Tsinghua University'</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> options = &#123;</span><br><span class=\"line\">   host: <span class=\"string\">'www.byvoid.com'</span>,</span><br><span class=\"line\">   path: <span class=\"string\">'/application/node/post.php'</span>,</span><br><span class=\"line\">   method: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">   headers: &#123;</span><br><span class=\"line\">      <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/x-www-form-urlencoded'</span>,</span><br><span class=\"line\">      <span class=\"string\">'Content-Length'</span>: contents.length</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> req = http.request(options, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">   res.setEncoding(<span class=\"string\">'utf8'</span>);</span><br><span class=\"line\">   res.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">req.write(contents);</span><br><span class=\"line\">req.end();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>http.get(options, callback) http 模块还提供了一个更加简便的方法用于处理GET请求：http.get。它是 http.request 的简化版，唯一的区别在于：http.get自动将请求方法设为了 GET 请求，同时不需要手动调用 req.end()。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//httprequest.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\">http.get(&#123;</span><br><span class=\"line\">   host: <span class=\"string\">'www.byvoid.com'</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">   res.setEncoding(<span class=\"string\">'utf8'</span>);</span><br><span class=\"line\">   res.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>http.ClientRequest 是由 http.request 或 http.get 返回产生的对象，表示一 个已经产生而且正在进行中的 HTTP 请求，它提供一个 response 事件，即 http.request 或 http.get 第二个参数指定的回调函数的绑定对象。我们也可以显式地绑定这个事件的监听函数：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//httpresponse.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> req = http.get(&#123;<span class=\"attr\">host</span>: <span class=\"string\">'www.byvoid.com'</span>&#125;);</span><br><span class=\"line\">req.on(<span class=\"string\">'response'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\"> \tres.setEncoding(<span class=\"string\">'utf8'</span>);</span><br><span class=\"line\"> \tres.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\"> \t<span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>http.ClientRequest 像 http.ServerResponse 一样也提供了 write 和 end 函 数，用于向服务器发送请求体，通常用于 POST、PUT 等操作。所有写结束以后必须调用 end 函数以通知服务器，否则请求无效。相关函数：</p>\n<ul>\n<li>request.abort()：终止正在发送的请求。</li>\n<li>request.setTimeout(timeout, [callback])：设置请求超时时间，timeout 为毫秒数。当请求超时以后，callback 将会被调用</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p>http.clientResponse</p>\n<p>http.ClientResponse 与 http.ServerRequest 相似，提供了三个事件 data、end 和 close，分别在数据到达、传输结束和连接结束时触发，其中 data 事件传递一个参数 chunk，表示接收到的数据。</p>\n<p>http.ClientResponse 也提供了一些属性，用于表示请求的结果状态:</p>\n<blockquote>\n<p>statusCode : HTTP 状态码，如 200、404、500</p>\n<p>httpVersion : HTTP 协议版本，通常是 1.0 或 1.1</p>\n<p>headers : HTTP 请求头</p>\n<p>trailers : HTTP 请求尾（不常见）</p>\n<p><strong>http.ClientResponse 还提供了以下几个特殊的函数</strong></p>\n<p>response.setEncoding([encoding])：设置默认的编码，当 data 事件被触发<br>\n时，数据将会以 encoding 编码。默认值是 null，即不编码，以 Buffer 的形式存<br>\n储。常用编码为 utf8。<br>\nresponse.pause()：暂停接收数据和发送事件，方便实现下载功能。<br>\nresponse.resume()：从暂停的状态中恢复。</p>\n<p>参考资料：<a href=\"http://nodejs.org/api/index.html\" target=\"_blank\" rel=\"noopener\">http://nodejs.org/api/index.html</a></p>\n</blockquote>\n</li>\n</ul>\n<h2>第五章 Node.js Web开发实战</h2>\n<h3>Node.js 工作原理</h3>\n<p>Node.js 实现网站的工作原理。Node.js 和 PHP、 Perl、ASP、JSP 一样，目的都是实现动态网页，也就是说由服务器动态生成 HTML 页面。 之所以要这么做，是因为静态 HTML 的可扩展性非常有限，无法与用户有效交互。同时如 果有大量相似的内容，例如产品介绍页面，那么1000个产品就要1000个静态的 HTML 页面， 维护这1000个页面简直是一场灾难，因此动态生成 HTML 页面的技术应运而生。是在以 HTML 为主的模板中插入程序代码。这种方 式在2002年前后非常流行，但它的问题是页面和程序逻辑紧密耦合，任何一个网站规模变大 以后，都会遇到结构混乱，难以处理的问题。为了解决这种问题，以 MVC 架构为基础的平台逐渐兴起；Node.js 本质上和 Perl 或 C++ 一样，都可以作为 CGI 扩展被调用，但它还可以跳过 HTTP 服务器，因为它本身就是。传统的架构中 HTTP 服务器的角色会由 Apache、Nginx、IIS 之类 的软件来担任，而 Node.js 不需要。Node.js 提供了 http 模块，它是由 C++ 实现的，性能可靠，可以直接应用到生产环境。</p>\n<blockquote>\n<p>MVC （Model-View-Controller，模型视图控制器）是一种软件的设计模式，它最早是 由 20 世纪 70 年代的 Smalltalk 语言提出的，即把一个复杂的软件工程分解为三个层面：模 型、视图和控制器。</p>\n<ul>\n<li>模型是对象及其数据结构的实现，通常包含数据库操作。</li>\n<li>视图表示用户界面，在网站中通常就是 HTML 的组织结构。</li>\n<li>控制器用于处理用户请求和数据流、复杂模型，将输出传递给视图。</li>\n</ul>\n</blockquote>\n<h4>了解 <strong>http</strong> 模块</h4>\n<p>Node.js 由于不需要另外的 HTTP 服务器，因此减少了一层抽象，给性能带来不少提升， 但同时也因此而提高了开发难度。举例来说，下面是一个简单的HTTP服务，提交时以 POST 的方式将请求发送，然后将发送过来内容原封不动的返回给用户</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> server = http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> post = <span class=\"string\">''</span>;</span><br><span class=\"line\">   <span class=\"comment\">// req.headers;</span></span><br><span class=\"line\">   <span class=\"comment\">// req.method;</span></span><br><span class=\"line\">   <span class=\"comment\">// req.url;</span></span><br><span class=\"line\">   <span class=\"comment\">// req.client;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   req.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">chunk</span>) </span>&#123;</span><br><span class=\"line\">      post += chunk;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">   req.on(<span class=\"string\">'end'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      post = querystring.parse(post);</span><br><span class=\"line\">      <span class=\"comment\">//以流的方式持续回给发送端</span></span><br><span class=\"line\">      res.write(post.title);</span><br><span class=\"line\">      res.write(post.text);</span><br><span class=\"line\">      res.statusCode(<span class=\"number\">200</span>);</span><br><span class=\"line\">      res.end();</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<h3>Express框架</h3>\n<h4>简介</h4>\n<blockquote>\n<p>npm 提供了大量的第三方模块，其中不乏许多 Web 框架，我们没有必要重复发明轮子， 因而选择使用 Express 作为开发框架，因为它是目前最稳定、使用最广泛，而且 Node.js 官 方推荐的唯一一个 Web 开发框架。<br>\nExpress （ <a href=\"http://expressjs.com/\" target=\"_blank\" rel=\"noopener\">http://expressjs.com/</a> ） 除了为 http 模块提供了更高层的接口外，还实现了 许多功能，其中包括：</p>\n<ul>\n<li>路由控制；</li>\n<li>模板解析支持；</li>\n<li>动态视图；</li>\n<li>用户会话；</li>\n<li>CSRF 保护；</li>\n<li>静态文件服务；</li>\n<li>错误控制器；</li>\n<li>访问日志；</li>\n<li>缓存；</li>\n<li>插件支持。</li>\n</ul>\n<p>需要指出的是，Express 不是一个无所不包的全能框架，像 Rails 或 Django 那样实现了 模板引擎甚至 ORM （Object Relation Model，对象关系模型）。它只是一个轻量级的 Web 框架，多数功能只是对 HTTP 协议中常用操作的封装，更多的功能需要插件或者整合其他模块 来完成。</p>\n</blockquote>\n<h4>安装</h4>\n<ul>\n<li>\n<p>安装<code>$ npm install -g express</code></p>\n</li>\n<li>\n<p>查看帮助：$ express --help</p>\n</li>\n<li>\n<p>Express 例子(重新实现前面)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express.createServer();</span><br><span class=\"line\">app.use(express.bodyParser());</span><br><span class=\"line\">app.all(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">   res.send(req.body.title + req.body.text);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4>创建工程</h4>\n<blockquote>\n<p>Express 在初始化一个项目的时候需要指定模板引擎，默认支持Jade和ejs，为了降低学<br>\n习难度我们推荐使用 ejs ，同时暂时不添加 CSS 引擎和会话支持。</p>\n</blockquote>\n<ol>\n<li>\n<p>建立网站：</p>\n<ol>\n<li>\n<p>新起一个文件目录</p>\n<p><code>$ mkdir nodetest &amp;&amp; cd nodetest</code></p>\n</li>\n<li>\n<p>express创建ejs模板，如下右图</p>\n<p><code>$ npm install -g express &amp;&amp; npm install -g express-generator</code></p>\n<p><code>$ express -e nodeblog(-e 是ejs模板)</code></p>\n<p>//<code>$express -t nodeblog(-t 是jade模板引擎)</code></p>\n<p>// express3之前 不需要另外install ，可直接创建ejs模板：$ express -t ejs nodeblog</p>\n<p>//原因：express3+已经把创建一个APP的功能分离出来为express-generator，没它你创建不了应用程序</p>\n</li>\n<li>\n<p>进入生成的文件夹，打开package.json文件查看模板引擎，如下左图</p>\n</li>\n<li>\n<p>进入nodeblog文件夹</p>\n<p><code>$ cd nodeblog/</code></p>\n</li>\n<li>\n<p>安装相关依赖模块</p>\n<p><code>$ npm install</code></p>\n</li>\n<li>\n<p>启动服务</p>\n<p><code>$ npm start</code></p>\n<p>执行npm start其实是执行package.json中的script对应的对象中的start属性所对应的命令行</p>\n</li>\n<li>\n<p>可以用浏览器打开：<a href=\"http://localhost:3000\" target=\"_blank\" rel=\"noopener\">http://localhost:3000</a> 看到 Welcome to Express</p>\n</li>\n</ol>\n<p>**注：**ejs（Embedded JavaScript）是一个标签替换引擎，其语法与 ASP、PHP 相似，易于学习，目前被广泛应用。Express 默认提供的引擎是 jade，它颠覆了传统的模板引擎，制定了一套完整的语法用来生成 HTML 的每个标签结构，功能强大但不易学习。</p>\n<table>\n<thead>\n<tr>\n<th>左图</th>\n<th>右图</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222110947.png\" alt></td>\n<td><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222112735.png\" alt></td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>基本结构</p>\n<ul>\n<li>\n<p>首先我们导入了 Express 模块，前面已经通过 npm 安装到了本地，在这里可以直接通过 require 获取</p>\n</li>\n<li>\n<p>app.js文件结构说明：</p>\n<p>app.set 是 Express 的参数设置工具，接受一个键（key）和一个值（value），可用的参数如下所示。</p>\n<ul>\n<li>basepath：基础地址，通常用于 res.redirect() 跳转。</li>\n<li>views：视图文件的目录，存放模板文件。</li>\n<li>view engine：视图模板引擎。</li>\n<li>view options：全局视图参数对象。</li>\n<li>view cache：启用视图缓存。</li>\n<li>case sensitive routes：路径区分大小写。</li>\n<li>strict routing：严格路径，启用后不会忽略路径末尾的“ / ”。</li>\n<li>jsonp callback：开启透明的 JSONP 支持。</li>\n</ul>\n</li>\n<li>\n<p>routes/index.js 是路由文件，相当于控制器，用于组织展示的内容;</p>\n</li>\n<li>\n<p>index.ejs 是模板文件，即 routes/index.js 中调用的模板;</p>\n</li>\n</ul>\n</li>\n<li>\n<p>工作原理</p>\n<ul>\n<li>当通过浏览器访问 app.js 建立的服务器时， 会看到一个简单的页面， 实际上它已经完成了许多透明的工作， 现在就让我们来解释一下它的工作机制， 以帮助理解网站的整 体架构。访问 <a href=\"http://localhost:3000\" target=\"_blank\" rel=\"noopener\">http://localhost:3000</a>，浏览器会向服务器发送以下请求：</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET <span class=\"regexp\">/ HTTP/</span><span class=\"number\">1.1</span></span><br><span class=\"line\"><span class=\"string\">Host:</span> <span class=\"string\">localhost:</span><span class=\"number\">3000</span></span><br><span class=\"line\"><span class=\"string\">Connection:</span> keep-alive</span><br><span class=\"line\">Cache-<span class=\"string\">Control:</span> max-age=<span class=\"number\">0</span></span><br><span class=\"line\">User-<span class=\"string\">Agent:</span> Mozilla<span class=\"regexp\">/5.0 AppleWebKit/</span><span class=\"number\">535.19</span> (KHTML, like Gecko) Chrome/<span class=\"number\">18.0</span><span class=\"number\">.1025</span><span class=\"number\">.142</span></span><br><span class=\"line\"> Safari/<span class=\"number\">535.19</span></span><br><span class=\"line\"><span class=\"string\">Accept:</span> text<span class=\"regexp\">/html,application/</span>xhtml+xml,application<span class=\"regexp\">/xml;q=0.9,*/</span>*;q=<span class=\"number\">0.8</span></span><br><span class=\"line\">Accept-<span class=\"string\">Encoding:</span> gzip,deflate,sdch</span><br><span class=\"line\">Accept-<span class=\"string\">Language:</span> zh;q=<span class=\"number\">0.8</span>,en-US;q=<span class=\"number\">0.6</span>,en;q=<span class=\"number\">0.4</span></span><br><span class=\"line\">Accept-<span class=\"string\">Charset:</span> UTF<span class=\"number\">-8</span>,*;q=<span class=\"number\">0.5</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>app 会 解析请求的路径，调用相应的逻辑。app.js 中有一行内容是 app.get(’/’, routes.index)， 它的作用是规定路径为“/”的 GET 请求由 routes.index 函数处理。routes.index 通 过 res.render(‘index’, { title: ‘Express’ }) 调用视图模板 index，传递 title 变量。最终视图模板生成 HTML 页面，返回给浏览器</p>\n</li>\n<li>\n<p>浏览器在接收到内容以后，经过分析发现要获取 /stylesheets/style.css，因此会再次向服 务器发起请求。 app.js 中并没有一个路由规则指派到 /stylesheets/style.css， 但 app 通过 app.use(express.static(__dirname + ‘/public’)) 配置了静态文件服务器，因此 /stylesheets/style.css 会定向到 app.js 所在目录的子目录中的文件 public/stylesheets/style.css；由 Express 创建的网站架构如下图所示。</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222124034.png\" alt></p>\n</li>\n</ul>\n</li>\n<li>\n<p>创建路由规则</p>\n<blockquote>\n<p>我们在浏览器中访问譬如 <a href=\"http://localhost:3000/abc\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/abc</a> 这样不存在的页面时，服务器会在 响应头中返回 404 Not Found 错误，这是因为 /abc 是一个不存在的路由规则，而且它也不是一个 public 目录下的文件，所以 Express返回了404 Not Found的错误</p>\n</blockquote>\n<ul>\n<li>\n<p>路径匹配</p>\n<p>Express 还支持更高级的路径匹配模式。例 如我们想要展示一个用户的个人页面，路径为 /user/[username]，可以用下面的方法定义路由 规则：</p>\n<p>将routes/index.js文件改成如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* GET home page. */</span></span><br><span class=\"line\">router.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  res.render(<span class=\"string\">'index'</span>, &#123; <span class=\"attr\">title</span>: <span class=\"string\">'Express'</span> &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//增加的代码</span></span><br><span class=\"line\">router.get(<span class=\"string\">'/user/:username'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  res.render(<span class=\"string\">'index'</span>, &#123; <span class=\"attr\">title</span>: <span class=\"string\">'Express'</span>+ <span class=\"string\">\" \"</span> + req.params.username &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = router;</span><br></pre></td></tr></table></figure>\n<p>然后重启app.js，访问：<a href=\"http://localhost:3000/user/nenhall\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/user/nenhall</a></p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222140808.png\" alt></p>\n<p>路径规则 /user/:username 会被自动编译为正则表达式，类似于<code>\\/user\\/(\\[^\\/]+)\\/?</code> 这样的形式。路径参数可以在响应函数中通过 req.params 的属性访问。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>控制权转移</p>\n<ul>\n<li>\n<p>Express 支持同一路径绑定多个路由响应函数，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//router/index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">router.all(<span class=\"string\">'/user/:username'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  res.send(<span class=\"string\">'all methods captured'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(<span class=\"string\">'/user/:username'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  res.render(<span class=\"string\">'index'</span>, &#123; <span class=\"attr\">title</span>: <span class=\"string\">'Express'</span>+ <span class=\"string\">\" \"</span> + req.params.username &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>当你访问任何被两条同样的规则匹配到的路径时，会发现请求总是被前一条路由规则捕获，后面的规则会被忽略，原因是Express在处理路由规则时，会优先匹配定义的路由规则，因此后面相同的规则被屏蔽。</p>\n</li>\n<li>\n<p>Express 提供了路由控制权转移的方法， 通过调用 next()，会将路由控制权转移给后面的规则</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//router/index.js</span></span><br><span class=\"line\">router.all(<span class=\"string\">'/user/:username'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'all methods captured'</span>);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">    <span class=\"comment\">//这个路由规则实际上起到了中间件的作用，我们还可以改成下面这样，在这进行检查用户名的合法性，eg.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (req.params.username == xxxxx) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//do something</span></span><br><span class=\"line\">        next();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(<span class=\"string\">'/user/:username'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  res.render(<span class=\"string\">'index'</span>, &#123; <span class=\"attr\">title</span>: <span class=\"string\">'Express'</span>+ <span class=\"string\">\" \"</span> + req.params.username &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>当访问被匹配到的路径时，如 <a href=\"http://localhost:3000/user/nenhall%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%8E%B0%E7%BB%88%E7%AB%AF%E4%B8%AD%E6%89%93%E5%8D%B0%E4%BA%86\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/user/nenhall，会发现终端中打印了</a> all methods captured，而且浏览器中显示了 user: nenall。说明请求先被第一条路由规则捕获，完成 console.log 使用 next() 转移控制权，又被第二条规则捕获，向浏览器返回了信息。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3>模板引擎</h3>\n<h4>简介</h4>\n<blockquote>\n<p>模板引擎（Template Engine）是一个从页面模板根据一定的规则生成 HTML 的工具</p>\n</blockquote>\n<p>模板引擎以数据和页面模板为输入，生成 HTML 页面，然后返回给控制器， 由控制器交回客户端。下图是模板引擎在 MVC 架构中的示意图</p>\n<p><img src=\"https://blogimage-1257063273.cos.ap-guangzhou.myqcloud.com/20190222142954.png\" alt></p>\n<h4>使用模板引擎</h4>\n<blockquote>\n<p>基于 JavaScript 的模板引擎有许多种实现，我们推荐使用 ejs （Embedded JavaScript）， 因为它十分简单，而且与 Express 集成良好。由于它是标准 JavaScript 实现的，因此它不仅 可以运行在服务器端，还可以运行在浏览器中</p>\n<p>ejs 的标签系统非常简单，它只有以下3种标签:</p>\n<ul>\n<li>&lt;% code %&gt;：JavaScript 代码。</li>\n<li>&lt;%= code %&gt;：显示替换过 HTML 特殊字符的内容。</li>\n<li>&lt;%- code %&gt;：显示原始 HTML 内容。</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p>我们在 app.js 中通过以下两个语句设置了模板引擎和页面模板的位置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"comment\">// view engine setup</span></span><br><span class=\"line\">app.set(<span class=\"string\">'views'</span>, path.join(__dirname, <span class=\"string\">'views'</span>));</span><br><span class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'ejs'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 表明要使用的模板引擎是 ejs， 页面模板在 views 子目录下。 在 routes/index.js 的 exports.index 函数中通过如下语句调用模板引擎：</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// router/index.js</span></span><br><span class=\"line\">router.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  res.render(<span class=\"string\">'index'</span>, &#123; <span class=\"attr\">title</span>: <span class=\"string\">'Express'</span> &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// res.render 的功能是调用模板引擎，并将其产生的页面直接返回给客户端。它接受 两个参数，第一个是模板的名称，即 views 目录下的模板文件名，不包含文件的扩展名；第二个参数是传递给模板的数据，用于模板翻译</span></span><br><span class=\"line\"><span class=\"comment\">// res.render('index', &#123; title: 'Express' &#125;); 这句代码的意思：引用了views目录下名为index.ejs文件，并把` &#123; title: 'Express' &#125;`这一个参数过去</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4>页面布局</h4>\n<blockquote>\n<p>Express3+之后页面布局一起文件放在了/views/index.ejs文件中，在之前是有单独的layout.ejs文件</p>\n</blockquote>\n<h4>片段视图</h4>\n<blockquote>\n<p>Express 的视图系统还支持片段视图 （partials），它就是一个页面的片段，通常是重复的 内容，用于迭代显示。通过它你可以将相对独立的页面块分割出去</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 在router/index.js 增加如下代码</span></span><br><span class=\"line\">router.get(<span class=\"string\">'/list'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  res.render(<span class=\"string\">'list'</span>, &#123;</span><br><span class=\"line\">  title: <span class=\"string\">'List'</span>,</span><br><span class=\"line\">  items: [<span class=\"number\">1991</span>, <span class=\"string\">'byvoid'</span>, <span class=\"string\">'express'</span>, <span class=\"string\">'Node.js'</span>]</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在 views 目录下新建 list.ejs，内容是：</span></span><br><span class=\"line\">&lt;ul&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%-</span> <span class=\"attr\">partial</span>('<span class=\"attr\">listitem</span>', <span class=\"attr\">items</span>) %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 3. 同时新建 listitem.ejs，内容是：</span></span><br><span class=\"line\">&lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">listitem</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 4.访问 http://localhost:3000/list，可以在源代码中看到刚才的内容：</span></span><br></pre></td></tr></table></figure>\n<p>partial 是一个可以在视图中使用函数，它接受两个参数，第一个是片段视图的名称， 第二个可以是一个对象或一个数组，如果是一个对象，那么片段视图中上下文变量引用的就 是这个对象；如果是一个数组，那么其中每个元素依次被迭代应用到片段视图。片段视图中 上下文变量名就是视图文件名，例如上面的’listitem’。</p>\n<h4>视图助手</h4>\n<blockquote>\n<p>Express 提供了一种叫做视图助手的工具，它的功能是允许在视图中访问一个全局的函数 或对象，不用每次调用视图解析的时候单独传入。前面提到的 partial 就是一个视图助手。</p>\n<p>视图助手有两类：静态视图助手和动态视图助手。</p>\n<ul>\n<li>静态视图助手：可以是任何类型的对象，包括接受任意参数的函数，但访问到的对象必须是与用户请求无关的，可以通过 app.helpers() 函数注册，它接受一个对象，对象的每个属性名称为视图助手的名称，属性值对应视图助手的值。</li>\n<li>动态视图助手：只能是一个函数，这个函数不能接受参数，但可以访问 req 和 res 对象；通过 app.dynamicHelpers() 注册，方法与静态视图助手相同，但每个属性的值必须为一个函数，该函数提供 req 和 res</li>\n</ul>\n</blockquote>\n<h3>建立微博网站</h3>\n<ul>\n<li>功能点分析：一个完整的微博系统应该支持信息的评论、转发、圈 点用户等功能，但出于演示目的，我们不能一一实现所有功能，只是实现一个微博社交网站 的雏形。</li>\n<li>路由规划：整个网站的骨架部分，因为它处于整个架构的枢纽位置，相当于各个接口之间的粘合剂， 所以应该优先考虑。根据功能设计，我们把路由按照以下方案规划。\n<ul>\n<li>首页</li>\n<li>用户的主页</li>\n<li>发表信息</li>\n<li>用户注册</li>\n<li>用户登录</li>\n<li>用户登出</li>\n<li>用户状态细分：\n<ul>\n<li>发表信息以及用户登出页面必须是已登录用户才能操作的功能</li>\n<li>用户注册和用户登入所面向的对象必须是未登入的用户</li>\n<li>首页和用户主页则 针对已登入和未登入的用户显示不同的内容。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>具体实现省略，主要是用到第三方库</li>\n<li>关键点：app.post(‘/…’, <strong>function</strong>(req, res) {})\n<ul>\n<li>req.body 就是 POST 请求信息解析过后的对象， 例如我们要访问用户传递的<br>\npassword 域的值，只需访问 req.body[‘password’] 即可。</li>\n<li>req.flash 是 Express 提供的一个奇妙的工具，通过它保存的变量只会在用户当前<br>\n和下一次的请求中被访问，之后会被清除，通过它我们可以很方便地实现页面的通知<br>\n和错误信息显示功能。</li>\n<li>res.redirect 是重定向功能，通过它会向用户返回一个 303 See Other 状态，通知<br>\n浏览器转向相应页面。</li>\n<li>crypto 是 Node.js 的一个核心模块，功能是加密并生成各种散列，使用它之前首先<br>\n要声明 var crypto = require(‘crypto’)。我们代码中使用它计算了密码的散<br>\n列值。</li>\n<li>通过 req.session.user = newUser 向会话对象写入了当前用户的信息，在后面<br>\n我们会通过它判断用户是否已经登录。</li>\n</ul>\n</li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/Mac开机一直卡在进度条界面/note_head_img.jpg","slug":"note_head_img.jpg","post":"cjsh3gt4l0003ncezglifk3ue","modified":1,"renderable":0},{"_id":"source/_posts/iOS-Category/note_head_img.jpg","slug":"note_head_img.jpg","post":"cjsh3gt4s0009ncezgyojielq","modified":1,"renderable":0},{"_id":"source/_posts/1677ziyouxing/1677ziyouxing.png","slug":"1677ziyouxing.png","post":"cjsh3gt6b0014ncezhsldbqn9","modified":1,"renderable":0},{"_id":"source/_posts/最后一支烟/psb.jpeg","post":"cjsh3gt54000encezmmi1qhgx","slug":"psb.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/Runtime/note_head_img.jpg","post":"cjsh3gt6d0017ncez1q0wlnz3","slug":"note_head_img.jpg","modified":1,"renderable":1},{"_id":"source/_posts/iOS-Block本质/note_head_img.jpg","post":"cjsh3gt6e0019ncezn34suc4o","slug":"note_head_img.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Nodejs-入门篇/note_head_img.jpg","post":"cjsh3gt73001jncezrv4upza3","slug":"note_head_img.jpg","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cjsh3gt4g0001ncez7g9ctwws","tag_id":"cjsh3gt4n0005ncezxxi2qi14","_id":"cjsh3gt55000fncezgo8yyoy1"},{"post_id":"cjsh3gt4g0001ncez7g9ctwws","tag_id":"cjsh3gt4v000ancezgauejlc7","_id":"cjsh3gt58000hncezwpc0k4cz"},{"post_id":"cjsh3gt4l0003ncezglifk3ue","tag_id":"cjsh3gt51000dncezgs5ap3lg","_id":"cjsh3gt5g000kncezf22fdnsn"},{"post_id":"cjsh3gt4p0006ncez1bzbecfc","tag_id":"cjsh3gt4n0005ncezxxi2qi14","_id":"cjsh3gt5t000nncezim4bnd00"},{"post_id":"cjsh3gt4p0006ncez1bzbecfc","tag_id":"cjsh3gt4v000ancezgauejlc7","_id":"cjsh3gt5t000oncez1py15tob"},{"post_id":"cjsh3gt4r0008ncezwfd7ltua","tag_id":"cjsh3gt4n0005ncezxxi2qi14","_id":"cjsh3gt5u000qncezx44xr7wh"},{"post_id":"cjsh3gt4r0008ncezwfd7ltua","tag_id":"cjsh3gt4v000ancezgauejlc7","_id":"cjsh3gt5u000rncezn8jpy06o"},{"post_id":"cjsh3gt4s0009ncezgyojielq","tag_id":"cjsh3gt4n0005ncezxxi2qi14","_id":"cjsh3gt5v000tncez447dvhaa"},{"post_id":"cjsh3gt4s0009ncezgyojielq","tag_id":"cjsh3gt4v000ancezgauejlc7","_id":"cjsh3gt5v000uncezt1aum8p7"},{"post_id":"cjsh3gt4w000bncez85zgryaz","tag_id":"cjsh3gt5v000sncez0n5amowy","_id":"cjsh3gt5w000wncez8tuseurs"},{"post_id":"cjsh3gt4y000cnceza60kqreb","tag_id":"cjsh3gt5v000sncez0n5amowy","_id":"cjsh3gt5w000yncezzq6tebww"},{"post_id":"cjsh3gt54000encezmmi1qhgx","tag_id":"cjsh3gt5v000sncez0n5amowy","_id":"cjsh3gt5x0010ncezj3hqjkw5"},{"post_id":"cjsh3gt57000gnceza0maoszw","tag_id":"cjsh3gt5v000sncez0n5amowy","_id":"cjsh3gt5y0012ncezd7pt00sn"},{"post_id":"cjsh3gt5f000jncezaz2hb2ta","tag_id":"cjsh3gt5v000sncez0n5amowy","_id":"cjsh3gt5y0013ncezel0884fo"},{"post_id":"cjsh3gt6c0015ncezai2002ny","tag_id":"cjsh3gt4n0005ncezxxi2qi14","_id":"cjsh3gt6e0018ncezpioaidr5"},{"post_id":"cjsh3gt6c0015ncezai2002ny","tag_id":"cjsh3gt4v000ancezgauejlc7","_id":"cjsh3gt6f001ancezsa6wz942"},{"post_id":"cjsh3gt6d0017ncez1q0wlnz3","tag_id":"cjsh3gt4n0005ncezxxi2qi14","_id":"cjsh3gt6g001cncezn5w5wj7n"},{"post_id":"cjsh3gt6d0017ncez1q0wlnz3","tag_id":"cjsh3gt4v000ancezgauejlc7","_id":"cjsh3gt6i001dncezw7z5f3k3"},{"post_id":"cjsh3gt6e0019ncezn34suc4o","tag_id":"cjsh3gt4n0005ncezxxi2qi14","_id":"cjsh3gt6j001encez2ny36oge"},{"post_id":"cjsh3gt6e0019ncezn34suc4o","tag_id":"cjsh3gt4v000ancezgauejlc7","_id":"cjsh3gt6j001fncez1vbd3tse"},{"post_id":"cjsh3gt6b0014ncezhsldbqn9","tag_id":"cjsh3gt6c0016ncez74qmg348","_id":"cjsh3gt6j001gncezn5ckz515"},{"post_id":"cjsh3gt6f001bncezpzb128gf","tag_id":"cjsh3gt4n0005ncezxxi2qi14","_id":"cjsh3gt6j001hncez8naf9s8l"},{"post_id":"cjsh3gt6f001bncezpzb128gf","tag_id":"cjsh3gt4v000ancezgauejlc7","_id":"cjsh3gt6j001incezztnotle8"},{"post_id":"cjsh3gt73001jncezrv4upza3","tag_id":"cjsh3gt4n0005ncezxxi2qi14","_id":"cjsh3gt74001kncez6bwunsai"},{"post_id":"cjsh3gt73001jncezrv4upza3","tag_id":"cjsh3gt4v000ancezgauejlc7","_id":"cjsh3gt74001lncezflxzaxna"}],"Tag":[{"name":"NSObject","_id":"cjsh3gt4n0005ncezxxi2qi14"},{"name":"底层原理","_id":"cjsh3gt4v000ancezgauejlc7"},{"name":"电脑常识","_id":"cjsh3gt51000dncezgs5ap3lg"},{"name":"生活随笔","_id":"cjsh3gt5v000sncez0n5amowy"},{"name":"游记","_id":"cjsh3gt6c0016ncez74qmg348"}]}}